{
  "openapi": "3.0.1",
  "info": {
    "title": "Macrometa GDN API",
    "description": "Macrometa Global Data Network API.",
    "license": {
      "name": "Macrometa License, Version 2.0"
    },
    "version": "0.16.0"
  },
  "servers": [
    {
      "url": "/"
    }
  ],
  "paths": {
    "/_api/key/validate": {
      "post": {
        "tags": [
          "API Keys"
        ],
        "summary": "Validate Api Key",
        "description": "\nA JSON object with these properties is required:\n\n  - **apikey**: The api key as a string.\n  You can validate api keys only if you have admin permissions.\n\n  - **jwt**: The JWT token as a string.\n  You can validate jwt token only if you have admin permissions.\n\n",
        "operationId": "ValidateApiKey",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/apikey_validate"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the api key can be added by the server.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing from the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "409": {
            "description": "Returned if a api key with the same id already exists.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_api/key": {
      "get": {
        "tags": [
          "API Keys"
        ],
        "summary": "List available api keys",
        "description": "\n\nFetches data about all api keys.  You can list only yours api keys.\n\nThe call will return a JSON object with at least the following attributes on success:\n\n- *keyid*: The id of the api key as a string.\n- *parent*: The user to who this api key belongs.\n- *tenant*: The api key tenant.\n\n\n",
        "operationId": "ListAvailableApiKeys",
        "responses": {
          "200": {
            "description": "The api keys that were found.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        }
      },
      "post": {
        "tags": [
          "API Keys"
        ],
        "summary": "Create Api Key",
        "description": "\nA JSON object with these properties is required:\n\n  - **keyid**: The id of the api key as a string.\n  You can create api keys only for yourself.\n\n",
        "operationId": "CreateApiKey",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/apikey_create"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the api key can be added by the server.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing from the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "409": {
            "description": "Returned if a api key with the same id already exists.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_api/key/{keyid}": {
      "get": {
        "tags": [
          "API Keys"
        ],
        "summary": "Get available api key.",
        "description": "\n\nFetches an existing api key, identified by *keyid*.  You can get only yours api keys.\n\nThe call will return a JSON object with at least the following attributes on success:\n\n- *keyid*: The id of the api key as a string.\n- *parent*: The user to who this api key belongs.\n- *tenant*: The api key tenant.\n\n\n",
        "operationId": "GetAvailableApiKey",
        "parameters": [
          {
            "name": "keyid",
            "in": "path",
            "description": "The id of the api key.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The api key that was found.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if invalid api key provided.\n\n",
            "content": {}
          }
        }
      },
      "delete": {
        "tags": [
          "API Keys"
        ],
        "summary": "Remove Api Key.",
        "description": "\nRemoves an existing api key, identified by *keyid*.  You can remove only yours api keys.\n\n",
        "operationId": "RemoveApiKey",
        "parameters": [
          {
            "name": "keyid",
            "in": "path",
            "description": "The id of the api key.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Returned if the api key was removed by the server.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the specified api key does not exist.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if invalid api key provided.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_api/key/{keyid}/database": {
      "get": {
        "tags": [
          "API Keys"
        ],
        "summary": "List the accessible databases for a keyid",
        "description": "\nFetch the list of databases available to the specified *keyid*. You need *Administrate* for the server access level in order to execute this REST call.\n\nThe call will return a JSON object with the per-database access privileges for the specified keyid . The *result* object will contain the databases names as object keys, and the associated privileges for the database as values.\n\nIn case you specified *full*, the result will contain the permissions for the databases as well as the permissions for the collections and streams.\n\n\n",
        "operationId": "ListTheAccessibleDatabasesForApiKey",
        "parameters": [
          {
            "name": "keyid",
            "in": "path",
            "description": "The id of the api key for which you want to query the databases.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "full",
            "in": "query",
            "description": "Return the full set of access levels for all databases and all collections.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the list of available databases can be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "REturned if the access privileges are not right etc.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if invalid api key provided.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_api/key/{keyid}/database/{dbname}": {
      "get": {
        "tags": [
          "API Keys"
        ],
        "summary": "Get the database access level",
        "description": "\nFetch the database access level for a specific database.\n\n",
        "operationId": "GetTheDatabaseAccessLevelForApiKey",
        "parameters": [
          {
            "name": "keyid",
            "in": "path",
            "description": "The id of the api key.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database to query.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the access level can be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the access privileges are not right etc.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if invalid api key provided.\n\n",
            "content": {}
          }
        }
      },
      "put": {
        "tags": [
          "API Keys"
        ],
        "summary": "Set the database access level",
        "description": "\nA JSON object with these properties is required:\n\n  - **grant**: Use \"rw\" to set the database access level to *Administrate* .\n   Use \"ro\" to set the database access level to *Access*.\n   Use \"none\" to set the database access level to *No access*.\n\nSets the database access levels for the database *dbname* of api key with *keyid*. You need the *Administrate* server access level in order to execute this REST call.\n\n\n",
        "operationId": "SetTheDatabaseAccessLevelForApiKey",
        "parameters": [
          {
            "name": "keyid",
            "in": "path",
            "description": "The id of the api key.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_grant_database"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the access level was changed successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing\nfrom the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if invalid api key provided.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "API Keys"
        ],
        "summary": "Clear the database access level",
        "description": "\nClears the database access level for the database *dbname* of api key with *keyid*. As consequence the default database access level is used. If there is no defined default database access level, it defaults to *No access*. You need permission to the *_system* database in order to execute this REST call.\n\n",
        "operationId": "ClearTheDatabaseAccessLevelForApiKey",
        "parameters": [
          {
            "name": "keyid",
            "in": "path",
            "description": "The id of the api key.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Returned if the access permissions were changed successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing\nfrom the request.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if invalid api key provided.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_api/key/{keyid}/database/{dbname}/collection": {
      "get": {
        "tags": [
          "API Keys"
        ],
        "summary": "Get the specific collection access level",
        "description": "\nFetch the list of collections access level for a specific *user*\n\n If access level for collection is not set then default(\"&#42;\") access level will be use. If default(\"&#42;\") access level is also not set then database access level will be use.\n\n\n",
        "operationId": "GetTheApiKeyCollectionsAccessLevel",
        "parameters": [
          {
            "name": "keyid",
            "in": "path",
            "description": "The id of the api key.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database to query.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "full",
            "in": "query",
            "description": "Return the full set of access levels for all collections.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the access level can be returned\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the access privileges are not right etc.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if invalid api key provided.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_api/key/{keyid}/database/{dbname}/collection/{collection}": {
      "get": {
        "tags": [
          "API Keys"
        ],
        "summary": "Get the specific collection access level",
        "description": "\nReturns the collection access level for a specific collection\n\n If access level for collection is not set then default(\"&#42;\") access level will be use. If default(\"&#42;\") access level is also not set then database access level will be use.\n\n\n",
        "operationId": "GetTheSpecificCollectionAccessLevelForApiKey",
        "parameters": [
          {
            "name": "keyid",
            "in": "path",
            "description": "The id of the api key.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database to query.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the access level can be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the access privileges are not right etc.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if invalid api key provided.\n\n",
            "content": {}
          }
        }
      },
      "put": {
        "tags": [
          "API Keys"
        ],
        "summary": "Set the collection access level",
        "description": "\nA JSON object with these properties is required:\n\n  - **grant**: Use \"rw\" to set the collection level access to *Read/Write*. Use \"ro\" to set the collection level access to  *Read Only*. Use \"none\" to set the collection level access to *No access*.\n\n - **collection**: Use \"&#42;\" to set default access level for all collections.\n\nIf access level for collection is not set then default(\"&#42;\") access level will be use. If default(\"&#42;\") access level is also not set then database access level will be use.\n\nSets the collection access level for the *collection* in the database *dbname* for api key with *keyid*. You need the *Administrate* server access level in order to execute this REST call.\n\n",
        "operationId": "SetTheCollectionAccessLevelForApiKey",
        "parameters": [
          {
            "name": "keyid",
            "in": "path",
            "description": "The id of the api key.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "*"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_grant_collection"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the access permissions were changed successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing\nfrom the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if invalid api key provided.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "API Keys"
        ],
        "summary": "Clear the collection access level.",
        "description": "\n\nClears the collection access level for the collection *collection* in the database *dbname* of api key with *keyid*.  As consequence the default collection access level is used. If there is no defined default collection access level, it defaults to *No access*.  You need permissions to the *_system* database in order to execute this REST call.\n\n",
        "operationId": "ClearTheCollectionAccessLevelForApiKey",
        "parameters": [
          {
            "name": "keyid",
            "in": "path",
            "description": "The id of the api key.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Returned if the access permissions were changed successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if there is an error.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if invalid api key provided.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_api/key/{keyid}/database/{dbname}/stream": {
      "get": {
        "tags": [
          "API Keys"
        ],
        "summary": "List the accessible streams",
        "description": "\nFetch the list of streams available to the specified *keyid*. You need *Administrate* for the server access level in order to execute this REST call.\nThe call will return a JSON object with the per-stream access privileges for the specified keyid. The *result* object will contain the stream names as object keys, and the associated privileges for the stream as values.\n\n If access level for stream is not set then default(\"&#42;\") access level will be use. If default(\"&#42;\") access level is also not set then database access level will be use.\n\n\n",
        "operationId": "ListTheAccessibleStreamsForApiKey",
        "parameters": [
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "keyid",
            "in": "path",
            "description": "The id of the api key for which you want to query the streams.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "full",
            "in": "query",
            "description": "Return the full set of access levels for all streams.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the list of available streams can be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the access privileges are not right etc.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if invalid api key provided.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_api/key/{keyid}/database/{dbname}/stream/{stream}": {
      "get": {
        "tags": [
          "API Keys"
        ],
        "summary": "Get the stream access level",
        "description": "\nFetch the stream access level for a specific stream.\n\n",
        "operationId": "GetTheStreamAccessLevelForApiKey",
        "parameters": [
          {
            "name": "keyid",
            "in": "path",
            "description": "The id of the api key for which you want to query the streams.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "stream",
            "in": "path",
            "description": "The name of the stream to query.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the access level can be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the access privileges are not right etc.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        }
      },
      "put": {
        "tags": [
          "API Keys"
        ],
        "summary": "Set the stream access level",
        "description": "\nA JSON object with these properties is required:\n\n  - **grant**: Use \"ro\" to set the stream access level to Subscribe.\n   Use \"wo\" to set the stream access level to Publish.\n Use \"rw\" to set the stream access level to Publish and Subscribe.\n  Use \"none\" to set the stream access level to *No access*.\n\n - **stream**: Use \"&#42;\" to set default access level for all streams.\n\nIf access level for stream is not set then default(\"&#42;\") access level will be use. If default(\"&#42;\") access level is also not set then database access level will be use.\n\n Sets the stream access levels for the *stream* of api key with *keyid*. You need the *Administrate* server access level in order to execute this REST call.\n\n\n\n",
        "operationId": "SetTheStreamAccessLevelForApiKey",
        "parameters": [
          {
            "name": "keyid",
            "in": "path",
            "description": "The id of the api key.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "stream",
            "in": "path",
            "description": "The name of the stream.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "*"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_grant_database"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the access level was changed successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing\nfrom the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if invalid api key provided.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "API Keys"
        ],
        "summary": "Clear the stream access level",
        "description": "\nClears the stream access level for the *stream* of api key with *keyid*. As consequence the default stream access level is used. If there is no defined default stream access level, it defaults to *No access*.\n\n\n\n",
        "operationId": "ClearTheStreamAccessLevelForApiKey",
        "parameters": [
          {
            "name": "keyid",
            "in": "path",
            "description": "The id of the api key.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "stream",
            "in": "path",
            "description": "The name of the stream.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Returned if the access permissions were changed successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing\nfrom the request.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if invalid api key provided.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_api/key/{keyid}/billing": {
      "get": {
        "tags": [
          "API Keys"
        ],
        "summary": "Get the billing access level",
        "description": "\nFetch the billing access level.\n\n",
        "operationId": "GetTheBillingAccessLevelForApiKey",
        "parameters": [
          {
            "name": "keyid",
            "in": "path",
            "description": "The id of the api key for which you want to query the billing.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the access level can be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the access privileges are not right etc.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if invalid api key provided.\n\n",
            "content": {}
          }
        }
      },
      "put": {
        "tags": [
          "API Keys"
        ],
        "summary": "Set the billing access level",
        "description": "\nA JSON object with these properties is required:\n\n  - **grant**: Use \"rw\" to set the billing access level to *Administrate*.\n   Use \"ro\" to set the billing access level to *Access*.\n   Use \"none\" to set the billing access level to *No access*.\n\nSets the billing access levels for api key with *keyid*. You need the *Administrate* server access level in order to execute this REST call.\n\n\n",
        "operationId": "SetTheBillingAccessLevelForApiKey",
        "parameters": [
          {
            "name": "keyid",
            "in": "path",
            "description": "The id of the api key.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_grant_database"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the access level was changed successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing\nfrom the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if invalid api key provided.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "API Keys"
        ],
        "summary": "Clear the billing access level",
        "description": "\nClears the billing access level of *keyid*.\n\n",
        "operationId": "ClearTheBillingAccessLevelForApiKey",
        "parameters": [
          {
            "name": "keyid",
            "in": "path",
            "description": "The id of the api key.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Returned if the access permissions were changed successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing\nfrom the request.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if invalid api key provided.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_open/auth": {
      "post": {
        "tags": [
          "Authentication"
        ],
        "summary": "Obtain JWT Authentication token for user.",
        "description": "\n\nObtain a JWT Authentication for a user. After obtaining the token, REST API\ncalls may be invoked by passing the obtained token in the REST header.\nEither email or both tenant and username must be specified.\nAdd the following to your header when you make REST calls:\n*\"Authorization: bearer TOKEN\"*\n\n\nA JSON object with these properties is required:\n\n  - **username**: The name of the user for whom we want the auth token.\n  - **password**: The user password as a string. \n  - **email**: The email of the user for whom we want the auth token.\n  - **tenant**: The name of the tenant for whose user we want the auth token.\n\n",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/auth_token"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the call succeeded.\n\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if a user is not authorized to execute the request.\n\n",
            "content": {}
          },
          "429": {
            "description": "Returned if the request count from this IP exceeds the rate limit.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/kv/{collection}/count": {
      "get": {
        "tags": [
          "Key Value"
        ],
        "summary": "Gets kv count in given collection.",
        "description": "Gets kv count in given collection.\n",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {}
          },
          "404": {
            "description": "NOT_FOUND",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/kv/{collection}/keys": {
      "get": {
        "tags": [
          "Key Value"
        ],
        "summary": "Gets keys from given collection.",
        "description": "Gets keys from given collection.\n",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "This option can be used to simulate paging. **Default: 0**.\n\n",
            "schema": {
              "type": "string",
              "default": "0"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "This option can be used to simulate paging. Limit the result. **Default: 20**, **Max: 100**.\n\n",
            "schema": {
              "type": "string",
              "default": "20"
            }
          },
          {
            "name": "order",
            "in": "query",
            "description": "Order the results asc or desc. **Default: asc**.\n\n",
            "schema": {
              "type": "string",
              "default": "asc"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/keys_array"
                }
              }
            }
          },
          "404": {
            "description": "NOT FOUND",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/kv": {
      "get": {
        "tags": [
          "Key Value"
        ],
        "summary": "Lists all collections.",
        "description": "\nLists all collections.\n",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {}
          },
          "404": {
            "description": "NOT FOUND",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/kv/{collection}": {
      "post": {
        "tags": [
          "Key Value"
        ],
        "summary": "Create collection",
        "description": "Creates collection.\n",
        "operationId": "CreateNamespace",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "expiration",
            "in": "query",
            "description": "If it is set then this namespace supports TTL.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/key_value"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/key_value_response"
                }
              }
            }
          },
          "404": {
            "description": "NOT FOUND",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/key_value_response_error"
                }
              }
            }
          },
          "409": {
            "description": "Duplicate name.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/key_value_response_error"
                }
              }
            }
          },
          "429": {
            "description": "Too many collections.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/key_value_response_error"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Key Value"
        ],
        "summary": "Delete collection",
        "description": "Delete collection.\n",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {}
          },
          "404": {
            "description": "NOT FOUND",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/kv/{collection}/value/{key}": {
      "get": {
        "tags": [
          "Key Value"
        ],
        "summary": "Get value",
        "description": "Get value.\n",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "key",
            "in": "path",
            "description": "The key.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {}
          },
          "404": {
            "description": "NOT_FOUND",
            "content": {}
          }
        }
      },
      "delete": {
        "tags": [
          "Key Value"
        ],
        "summary": "Delete entry for given key",
        "description": "\nDelete entry for given key.\n",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "key",
            "in": "path",
            "description": "The key.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {}
          },
          "404": {
            "description": "NOT FOUND",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/kv/{collection}/values": {
      "post": {
        "tags": [
          "Key Value"
        ],
        "summary": "Get values",
        "description": "Get collection values\n  Optional list of keys.  Max limit is 1000 keys per request.\n\n",
        "operationId": "GetValues",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "description": "This option can be used to simulate paging. **Default: 0**.\n\n",
            "schema": {
              "type": "string",
              "default": "0"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "This option can be used to simulate paging. Limit the result. **Default: 20**, **Max: 100**\n\n",
            "schema": {
              "type": "string",
              "default": "20"
            }
          }
        ],
        "requestBody": {
          "description": "An optional JSON array of strings (keys).\n\n",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/keys_array"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "properties": {
                    "error": {
                      "type": "boolean",
                      "description": "Flag if there is an error in response. Returns true in case of success. False in case of failure.",
                      "default": "false"
                    },
                    "code": {
                      "type": "integer",
                      "description": "The response code for the error."
                    },
                    "result": {
                      "type": "Array of strings",
                      "description": "An array of collection values. If there are no results, the array is returned as empty."
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "NOT_FOUND",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/key_value_response_error"
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "Json Body"
      },
      "delete": {
        "tags": [
          "Key Value"
        ],
        "summary": "Delete entries for given keys.",
        "description": "\nDelete key/value pairs. Requires a list of keys.  Max limit is 1000 keys per request.",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "description": "A JSON array of strings (keys).\n\n",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/keys_array"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {}
          },
          "404": {
            "description": "NOT FOUND",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Body"
      }
    },
    "/_fabric/{fabric}/_api/kv/{collection}/value": {
      "put": {
        "tags": [
          "Key Value"
        ],
        "summary": "Set one or more key-value pairs in given collection.",
        "description": "\nSet one or more key-value pairs in given collection. \nIf the input is an array of objects then KV pairs are created in batch.\nSpecify expiration in UTC timestamp.\n\n**Note:** \n  Max limit is **100** KV pairs per request.\n",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "description": "A JSON representation of a single document or of an array of documents.\n\nFields:\n* \"_key\" - if it is not set, it will be generated by the system\n* \"value\" - string or json object. Mandatory\n* \"expireAt\" - unix timestamp, indicating when the value will expire (-1 means no expiration)\n\n",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/key_value_array"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {}
          },
          "404": {
            "description": "NOT FOUND",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/kv/{collection}/truncate": {
      "put": {
        "tags": [
          "Key Value"
        ],
        "summary": "Truncates a given collection.",
        "description": "\nTruncates a collection.\n",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {}
          },
          "404": {
            "description": "NOT FOUND",
            "content": {}
          }
        }
      }
    },
    "/_api/dynamo": {
      "post": {
        "tags": [
          "Dynamo"
        ],
        "summary": "Dynamo-like API interface",
        "description": "\nDynamo-like API interface.\n\nSet your JWT token or APIKEY as a aws_access_key_id (ex. '*bearer XXXXX*' or '*apikey XXXXX*').\n\nCurrently supported Dynamo actions (set as *'x-amz-target'* header tag): \n\n  - **CreateTable**\n  - **CreateGlobalTable**\n  - **DeleteItem**\n  - **DeleteTable**\n  - **DescribeGlobalTable**\n  - **DescribeTable**\n  - **DescribeTimeToLive**\n  - **GetItem**\n  - **ListGlobalTables**\n  - **ListTables**\n  - **PutItem**\n  - **Query**\n  - **UpdateItem**\n  - **UpdateTable**\n  - **UpdateTimeToLive**\n  - **Scan**\n  - **BatchGetItem**\n  - **BatchWriteItem**\n",
        "operationId": "DynamoLikeInterfaceAPI",
        "requestBody": {
          "description": "The body depends on the action.\n\n",
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": {
                  "type": "object"
                }
              }
            }
          },
          "required": false
        },
        "responses": {
          "200": {
            "description": "\n\n",
            "content": {}
          }
        },
        "x-filename": "",
        "x-hints": "",
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/document/{collection}": {
      "put": {
        "tags": [
          "Documents"
        ],
        "summary": "Replace documents",
        "description": "\nReplaces multiple documents in the specified collection with the ones in the body, the replaced documents are specified by the *_key* attributes in the body documents.\n\nIf *ignoreRevs* is *false* and there is a *_rev* attribute in a document in the body and its value does not match the revision of the corresponding document in the database, the precondition is violated.\n\nIf the document exists and can be updated, then an *HTTP 201* or an *HTTP 202* is returned (depending on *waitForSync*, see below).\n\nThe body of the response contains a JSON array of the same length as the input array with the information about the handle and the revision of the replaced documents. In each entry, the attribute *_id* contains the known *document-handle* of each updated document, *_key* contains the key which uniquely identifies a document in a given collection, and the attribute *_rev* contains the new document revision. In case of an error or violated precondition, an error object with the attribute *error* set to *true* and the attribute *errorCode* set to the error code is built.\n\nIf the query parameter *returnOld* is *true*, then, for each generated document, the complete previous revision of the document is returned under the *old* attribute in the result.\n\nIf the query parameter *returnNew* is *true*, then, for each generated document, the complete new document is returned under the *new* attribute in the result.\n\nNote that if any precondition is violated or an error occurred with some of the documents, the return code is still 201 or 202, but the additional HTTP header *X-database-Error-Codes* is set, which contains a map of the error codes that occurred together with their multiplicities, as in: *1200:17,1205:10* which means that in 17 cases the error 1200 \"revision conflict\" and in 10 cases the error 1205 \"illegal document handle\" has happened.\n\n",
        "operationId": "replaceDocument:multiple",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "This URL parameter is the name of the collection in which the documents are replaced.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "ignoreRevs",
            "in": "query",
            "description": "By default, or if this is set to *true*, the *_rev* attributes in the given documents are ignored. If this is set to *false*, then any *_rev* attribute given in a body document is taken as a precondition. The document is only replaced if the current revision is the one specified.\n\n",
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "returnOld",
            "in": "query",
            "description": "Return additionally the complete previous revision of the changed documents under the attribute *old* in the result.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "returnNew",
            "in": "query",
            "description": "Return additionally the complete new documents under the attribute *new* in the result.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "description": "A JSON representation of an array of documents.\n\n",
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the documents were replaced successfully and *waitForSync* was *true*.\n\n",
            "content": {}
          },
          "202": {
            "description": "Returned if the documents were replaced successfully and *waitForSync* was *false*.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the body does not contain a valid JSON representation of an array of documents. The response body contains an error document in this case.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the collection was not found.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "post": {
        "tags": [
          "Documents"
        ],
        "summary": "Create document",
        "description": "\nCreates a new document from the document given in the body, unless there is already a document with the *_key* given. If no *_key* is given, a new unique *_key* is generated automatically.\n\nThe body can be an array of documents, in which case all documents in the array are inserted with the same semantics as for a single document. The result body will contain a JSON array of the same length as the input array, and each entry contains the result of the operation for the corresponding input. In case of an error the entry is a document with attributes *error* set to *true* and errorCode set to the error code that has happened.\n\nPossibly given *_id* and *_rev* attributes in the body are always ignored, the URL part or the query parameter collection respectively counts.\n\nIf the document was created successfully, then the *Location* header contains the path to the newly created document. The *Etag* header field contains the revision of the document. Both are only set in the single document case.\n\nIf *silent* is not set to *true*, the body of the response contains a JSON object (single document case) with the following attributes:\n\n  - *_id* contains the document handle of the newly created document\n  - *_key* contains the document key\n  - *_rev* contains the document revision\n\nIn the multi case the body is an array of such objects. If the query parameter *returnNew* is *true*, then, for each generated document, the complete new document is returned under the *new* attribute in the result.\n",
        "operationId": "insertDocument",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The *collection* in which the collection is to be created.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "collection",
            "in": "query",
            "description": "The name of the collection. This is only for backward compatibility.\n",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "returnNew",
            "in": "query",
            "description": "Additionally return the complete new document under the attribute *new* in the result.\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "returnOld",
            "in": "query",
            "description": "Additionally return the complete old document under the attribute *old* in the result. Only available if the overwrite option is used.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "silent",
            "in": "query",
            "description": "If set to *true*, an empty object will be returned as response. No meta-data will be returned for the created document. This option can be used to save some network traffic.\n\n",
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "overwrite",
            "in": "query",
            "description": "If set to *true*, the insert becomes a replace-insert. If a document with the same *_key* already exists the new document is not rejected with unique constraint violated but will replace the old document.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "description": "A JSON representation of a single document or of an array of documents.\n\n",
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the documents were created successfully and *waitForSync* was *true*.\n\n",
            "content": {}
          },
          "202": {
            "description": "Returned if the documents were created successfully and *waitForSync* was *false*.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the body does not contain a valid JSON representation of one document or an array of documents. The response body contains an error document in this case.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the collection specified by *collection* is unknown. The response body contains an error document in this case.\n\n",
            "content": {}
          },
          "409": {
            "description": "Returned in the single document case if a document with the same qualifiers in an indexed attribute conflicts with an already existing document and thus violates that unique constraint. The response body contains an error document in this case. In the array case only 201 or 202 is returned, but if an error occurred, the additional HTTP header *X-database-Error-Codes* is set, which contains a map of the error codes that occurred together with their multiplicities, as in: *1205:10,1210:17* which means that in 10 cases the error 1205 \"illegal document handle\" and in 17 cases the error 1210 \"unique constraint violated\" has happened.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "Documents"
        ],
        "summary": "Removes multiple documents",
        "description": "The body of the request is an array consisting of selectors for documents. A selector can either be a string with a key or a string with a document handle or an object with a *_key* attribute. \n\nThis API call removes all specified documents from *collection*. If the selector is an object and has a *_rev* attribute, it is a precondition that the actual revision of the removed document in the collection is the specified one.\n\nThe body of the response is an array of the same length as the input array. For each input selector, the output contains a JSON object with the information about the outcome of the operation. If no error occurred, an object is built in which the attribute *_id* contains the known *document-handle* of the removed document, *_key* contains the key which uniquely identifies a document in a given collection, and the attribute *_rev* contains the document revision. \n\nIn case of an error, an object with the attribute *error* set to *true* and *errorCode* set to the error code is built. If the query parameter *returnOld* is *true*, then the complete previous revision of the document is returned under the *old* attribute in the result.\n\nNote that if any precondition is violated or an error occurred with some of the documents, the return code is still 200 or 202, but the additional HTTP header *X-database-Error-Codes* is set, which contains a map of the error codes that occurred together with their multiplicities, as in: *1200:17,1205:10* which means that in 17 cases the error 1200 \"revision conflict\" and in 10 cases the error 1205 \"illegal document handle\" has happened.\n\n",
        "operationId": "removeDocument",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "Collection from which documents are removed.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "returnOld",
            "in": "query",
            "description": "Return additionally the complete previous revision of the changed document under the attribute *old* in the result.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "ignoreRevs",
            "in": "query",
            "description": "If set to *true*, ignore any *_rev* attribute in the selectors. No revision check is performed.\n\n",
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "requestBody": {
          "description": "An array of keys or documents.\n",
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if *waitForSync* was *true*.\n\n",
            "content": {}
          },
          "202": {
            "description": "Returned if *waitForSync* was *false*.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the collection was not found. The response body contains an error document in this case.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "patch": {
        "tags": [
          "Documents"
        ],
        "summary": "Update documents",
        "description": "\nPartially updates documents, the documents to update are specified by the *_key* attributes in the body objects. The body of the request must contain a JSON array of document updates with the attributes to patch (the patch documents). All attributes from the patch documents will be added to the existing documents if they do not yet exist, and overwritten in the existing documents if they do exist there.\n\nSetting an attribute value to *null* in the patch documents will cause a value of *null* to be saved for the attribute by default.\n\nIf *ignoreRevs* is *false* and there is a *_rev* attribute in a document in the body and its value does not match the revision of the corresponding document in the database, the precondition is violated.\n\nIf the document exists and can be updated, then an *HTTP 201* or an *HTTP 202* is returned (depending on *waitForSync*, see below).\n\nThe body of the response contains a JSON array of the same length as the input array with the information about the handle and the revision of the updated documents. In each entry, the attribute *_id* contains the known *document-handle* of each updated document, *_key* contains the key which uniquely identifies a document in a given collection, and the attribute *_rev* contains the new document revision. In case of an error or violated precondition, an error object with the attribute *error* set to *true* and the attribute *errorCode* set to the error code is built.\n\nIf the query parameter *returnOld* is *true*, then, for each generated document, the complete previous revision of the document is returned under the *old* attribute in the result.\n\nIf the query parameter *returnNew* is *true*, then, for each generated document, the complete new document is returned under the *new* attribute in the result.\n\nNote that if any precondition is violated or an error occurred with some of the documents, the return code is still 201 or 202, but the additional HTTP header *X-database-Error-Codes* is set, which contains a map of the error codes that occurred together with their multiplicities, as in: *1200:17,1205:10* which means that in 17 cases the error 1200 \"revision conflict\" and in 10 cases the error 1205 \"illegal document handle\" has happened.\n\n",
        "operationId": "updateDocument",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "This URL parameter is the name of the collection in which the documents are updated.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "keepNull",
            "in": "query",
            "description": "If the intention is to delete existing attributes with the patch command, the URL query parameter *keepNull* can be used with a value of *false*. This will modify the behavior of the patch command to remove any attributes from the existing document that are contained in the patch document with an attribute value of *null*.\n\n",
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "mergeObjects",
            "in": "query",
            "description": "Controls whether objects (not arrays) will be merged if present in both the existing and the patch document. If set to *false*, the value in the patch document will overwrite the existing document's value. If set to *true*, objects will be merged. The default is *true*.\n\n",
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "ignoreRevs",
            "in": "query",
            "description": "By default, or if this is set to *true*, the *_rev* attributes in the given documents are ignored. If this is set to *false*, then any *_rev* attribute given in a body document is taken as a precondition. The document is only updated if the current revision is the one specified.\n\n",
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "returnOld",
            "in": "query",
            "description": "Return additionally the complete previous revision of the changed documents under the attribute *old* in the result.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "returnNew",
            "in": "query",
            "description": "Return additionally the complete new documents under the attribute *new* in the result.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "description": "A JSON representation of an array of document updates as objects.\n\n",
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the documents were updated successfully and *waitForSync* was *true*.\n\n",
            "content": {}
          },
          "202": {
            "description": "Returned if the documents were updated successfully and *waitForSync* was *false*.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the body does not contain a valid JSON representation of an array of documents. The response body contains an error document in this case.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the collection was not found.\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/document/{collection}/{key}": {
      "get": {
        "tags": [
          "Documents"
        ],
        "summary": "Read document",
        "description": "Returns the document identified by key. The returned document contains three special attributes: _id containing the document handle, _key containing key which uniquely identifies a document in a given collection and _rev containing the revision.\n\n",
        "operationId": "readDocument",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "key",
            "in": "path",
            "description": "The key of the document.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "If-None-Match",
            "in": "header",
            "description": "If the \"If-None-Match\" header is given, then it must contain exactly one Etag. The document is returned, if it has a different revision than the given Etag. Otherwise an *HTTP 304* is returned.\n\n",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "If-Match",
            "in": "header",
            "description": "If the \"If-Match\" header is given, then it must contain exactly one Etag. The document is returned, if it has the same revision as the given Etag. Otherwise a *HTTP 412* is returned.\n\n",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the document was found.\n\n",
            "content": {}
          },
          "304": {
            "description": "Returned if the \"If-None-Match\" header is given and the document has the same version.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the document or collection was not found.\n\n",
            "content": {}
          },
          "412": {
            "description": "Returned if an \"If-Match\" header is given and the found document has a different version. The response will also contain the found document's current revision in the *_rev* attribute. Additionally, the attributes *_id* and *_key* will be returned.\n\n",
            "content": {}
          }
        }
      },
      "put": {
        "tags": [
          "Documents"
        ],
        "summary": "Replace document",
        "description": "\nReplaces the document with key <key> with the one in the body, provided there is such a document and no precondition is violated.\n\nIf the *If-Match* header is specified and the revision of the document in the database is unequal to the given revision, the precondition is violated.\n\nIf *If-Match* is not given and *ignoreRevs* is *false* and there is a *_rev* attribute in the body and its value does not match the revision of the document in the database, the precondition is violated.\n\nIf a precondition is violated, an *HTTP 412* is returned.\n\nIf the document exists and can be updated, then an *HTTP 201* or an *HTTP 202* is returned (depending on *waitForSync*, see below), the *Etag* header field contains the new revision of the document and the *Location* header contains a complete URL under which the document can be queried.\n\nIf *silent* is not set to *true*, the body of the response contains a JSON object with the information about the handle and the revision. The attribute *_id* contains the known *document-handle* of the updated document, *_key* contains the key which uniquely identifies a document in a given collection, and the attribute *_rev* contains the new document revision.\n\nIf the query parameter *returnOld* is *true*, then the complete previous revision of the document is returned under the *old* attribute in the result.\n\nIf the query parameter *returnNew* is *true*, then the complete new document is returned under the *new* attribute in the result.\n\nIf the document does not exist, then a *HTTP 404* is returned and the body of the response contains an error document.\n\n",
        "operationId": "replaceDocument",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "key",
            "in": "path",
            "description": "This URL parameter must be a document key.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "ignoreRevs",
            "in": "query",
            "description": "By default, or if this is set to *true*, the *_rev* attributes in the given document is ignored. If this is set to *false*, then the *_rev* attribute given in the body document is taken as a precondition. The document is only replaced if the current revision is the one specified.\n\n",
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "returnOld",
            "in": "query",
            "description": "Return additionally the complete previous revision of the changed document under the attribute *old* in the result.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "returnNew",
            "in": "query",
            "description": "Return additionally the complete new document under the attribute *new* in the result.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "silent",
            "in": "query",
            "description": "If set to *true*, an empty object will be returned as response. No meta-data will be returned for the replaced document. This option can be used to save some network traffic.\n\n",
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "If-Match",
            "in": "header",
            "description": "You can conditionally replace a document based on a target revision id by using the *if-match* HTTP header.\n\n",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "A JSON representation of a single document.\n\n",
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the document was replaced successfully and *waitForSync* was *true*.\n\n",
            "content": {}
          },
          "202": {
            "description": "Returned if the document was replaced successfully and *waitForSync* was *false*.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the body does not contain a valid JSON representation of a document. The response body contains an error document in this case.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the collection or the document was not found.\n\n",
            "content": {}
          },
          "412": {
            "description": "Returned if the precondition was violated. The response will also contain the found documents' current revisions in the *_rev* attributes. Additionally, the attributes *_id* and *_key* will be returned.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "Documents"
        ],
        "summary": "Removes a document",
        "description": "If *silent* is not set to *true*, the body of the response contains a  JSON object with the information about the handle and the revision.                 \n\nThe attribute *_id* contains the known *key* of the removed document, *_key* contains the key which uniquely identifies a document in a given collection, and the attribute *_rev* contains the document revision.\n\nIf the query parameter *returnOld* is *true*, then the complete previous revision of the document is returned under the *old* attribute in the result.\n\n",
        "operationId": "removeDocument2",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "Removes the document identified by *collection*.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "key",
            "in": "path",
            "description": "Removes the document identified by *key*.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "returnOld",
            "in": "query",
            "description": "Return additionally the complete previous revision of the changed document under the attribute *old* in the result.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "silent",
            "in": "query",
            "description": "If set to *true*, an empty object will be returned as response. No meta-data will be returned for the removed document. This option can be used to save some network traffic.\n\n",
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "If-Match",
            "in": "header",
            "description": "You can conditionally remove a document based on a target revision id by using the *if-match* HTTP header.\n\n",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the document was removed successfully and *waitForSync* was *true*.\n\n",
            "content": {}
          },
          "202": {
            "description": "Returned if the document was removed successfully and *waitForSync* was *false*.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the collection or the document was not found. The response body contains an error document in this case.\n\n",
            "content": {}
          },
          "412": {
            "description": "Returned if a \"If-Match\" header or *rev* is given and the found document has a different version. The response will also contain the found document's current revision in the *_rev* attribute. Additionally, the attributes *_id* and *_key* will be returned.\n\n",
            "content": {}
          }
        }
      },
      "head": {
        "tags": [
          "Documents"
        ],
        "summary": "Read document header",
        "description": "Like GET, but only returns the header fields and not the body. You can use this call to get the current revision of a document or check if the document was deleted.\n",
        "operationId": "checkDocument",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "key",
            "in": "path",
            "description": "The key of the document.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "If-None-Match",
            "in": "header",
            "description": "If the \"If-None-Match\" header is given, then it must contain exactly one Etag. If the current document revision is not equal to the specified Etag, an *HTTP 200* response is returned. If the current document revision is identical to the specified Etag, then an *HTTP 304* is returned.\n\n",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "If-Match",
            "in": "header",
            "description": "If the \"If-Match\" header is given, then it must contain exactly one Etag. The document is returned, if it has the same revision as the given Etag. Otherwise a *HTTP 412* is returned.\n\n",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the document was found.\n\n",
            "content": {}
          },
          "304": {
            "description": "Returned if the \"If-None-Match\" header is given and the document has the same version.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the document or collection was not found.\n\n",
            "content": {}
          },
          "412": {
            "description": "Returned if an \"If-Match\" header is given and the found document has a different version. The response will also contain the found document's current revision in the *Etag* header.\n\n",
            "content": {}
          }
        }
      },
      "patch": {
        "tags": [
          "Documents"
        ],
        "summary": "Update document",
        "description": "\nPartially updates the document identified by *key*. The body of the request must contain a JSON document with the attributes to patch (the patch document). All attributes from the patch document will be added to the existing document if they do not yet exist, and overwritten in the existing document if they do exist there.\n\nSetting an attribute value to *null* in the patch document will cause a value of *null* to be saved for the attribute by default.\n\nIf the *If-Match* header is specified and the revision of the document in the database is unequal to the given revision, the precondition is violated.\n\nIf *If-Match* is not given and *ignoreRevs* is *false* and there is a *_rev* attribute in the body and its value does not match the revision of the document in the database, the precondition is violated.\n\nIf a precondition is violated, an *HTTP 412* is returned.\n\nIf the document exists and can be updated, then an *HTTP 201* or an *HTTP 202* is returned, the *Etag* header field contains the new revision of the document (in double quotes) and the *Location* header contains a complete URL under which the document can be queried.\n\nIf *silent* is not set to *true*, the body of the response contains a JSON object with the information about the handle and the revision. The attribute *_id* contains the known *document-handle* of the updated document, *_key* contains the key which uniquely identifies a document in a given collection, and the attribute *_rev* contains the new document revision.\n\nIf the query parameter *returnOld* is *true*, then the complete previous revision of the document is returned under the *old* attribute in the result.\n\nIf the query parameter *returnNew* is *true*, then the complete new document is returned under the *new* attribute in the result.\n\nIf the document does not exist, then a *HTTP 404* is returned and the body of the response contains an error document.\n\n",
        "operationId": "updateDocument2",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "key",
            "in": "path",
            "description": "This URL parameter must be a document key.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "keepNull",
            "in": "query",
            "description": "If the intention is to delete existing attributes with the patch command, the URL query parameter *keepNull* can be used with a value of *false*. This will modify the behavior of the patch command to remove any attributes from the existing document that are contained in the patch document with an attribute value of *null*.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "mergeObjects",
            "in": "query",
            "description": "Controls whether objects (not arrays) will be merged if present in both the existing and the patch document. If set to *false*, the value in the patch document will overwrite the existing document's value. If set to *true*, objects will be merged. The default is *true*.\n\n",
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "ignoreRevs",
            "in": "query",
            "description": "By default, or if this is set to *true*, the *_rev* attributes in the given document is ignored. If this is set to *false*, then the *_rev* attribute given in the body document is taken as a precondition. The document is only updated if the current revision is the one specified.\n\n",
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "returnOld",
            "in": "query",
            "description": "Return additionally the complete previous revision of the changed document under the attribute *old* in the result.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "returnNew",
            "in": "query",
            "description": "Return additionally the complete new document under the attribute *new* in the result.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "silent",
            "in": "query",
            "description": "If set to *true*, an empty object will be returned as response. No meta-data will be returned for the updated document. This option can be used to save some network traffic.\n\n",
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "If-Match",
            "in": "header",
            "description": "You can conditionally update a document based on a target revision id by using the *if-match* HTTP header.\n\n",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "A JSON representation of a document update as an object.\n\n",
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the document was updated successfully and *waitForSync* was *true*.\n\n",
            "content": {}
          },
          "202": {
            "description": "Returned if the document was updated successfully and *waitForSync* was *false*.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the body does not contain a valid JSON representation of a document. The response body contains an error document in this case.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the collection or the document was not found.\n\n",
            "content": {}
          },
          "412": {
            "description": "Returned if the precondition was violated. The response will also contain the found documents' current revisions in the *_rev* attributes. Additionally, the attributes *_id* and *_key* will be returned.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/collection": {
      "get": {
        "tags": [
          "Collections"
        ],
        "summary": "reads all collections",
        "description": "Returns an object with an attribute *collections* containing an array of all collection descriptions. The same information is also available in the *names* as an object with the collection names as keys. By providing the optional query parameter *excludeSystem* with a value of *true*, all system collections will be excluded from the response.\n",
        "operationId": "handleCommandGet",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "excludeSystem",
            "in": "query",
            "description": "Whether or not system collections should be excluded from the result.\n",
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The list of collections\n\n",
            "content": {}
          }
        }
      },
      "post": {
        "tags": [
          "Collections"
        ],
        "summary": "Create collection",
        "description": "\nCreates a new collection with a given name. The request must contain an object with the following attributes.\n\nA JSON object with these properties is required:\n - **keyOptions**:\n    - **allowUserKeys**: if set to *true*, then it is allowed to supply own key values in the *_key* attribute of a document. If set to *false*, then the key generator will solely be responsible for generating keys and supplying own key values in the *_key* attribute of documents is considered an error.\n    - **type**: specifies the type of the key generator. The currently available generators are *traditional*, *autoincrement*, *uuid* and *padded*. The *traditional* key generator generates numerical keys in ascending order. The *autoincrement* key generator generates numerical keys in ascending order, the initial offset and the spacing can be configured The *padded* key generator generates keys of a fixed length (16 bytes) in ascending lexicographical sort order. This is ideal for usage with the _RocksDB_ engine, which will slightly benefit keys that are inserted in lexicographically ascending order. The key generator can be used in a single-server or cluster. The *uuid* key generator generates universally unique 128 bit keys, which are stored in hexadecimal human-readable format. This key generator can be used in a single-server or cluster to generate \"seemingly random\" keys. The keys produced by this key generator are not lexicographically sorted.\n    - **increment**: increment value for *autoincrement* key generator. Not used for other key generator types.\n    - **offset**: Initial offset value for *autoincrement* key generator. Not used for other key generator types.\n  - **name**: The name of the collection.\n  - **isSystem**: If *true*, create a  system collection. In this case *collection-name* should start with an underscore. End users should normally create non-system collections only. API implementors may be required to create system collections in very special occasions, but normally a regular collection will do. (The default is *false*)\n  - **type**: (The default is *2*): the type of the collection to create.\n   The following values for *type* are valid:\n    - *2*: document collection\n    - *3*: edge collection.\n",
        "operationId": "handleCommandPost:CreateCollection",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/api_collection"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/collection_info"
                }
              }
            },
            "x-description-offset": 234
          },
          "400": {
            "description": "Returned if the *collection-name* is missing, then a *HTTP 400* is returned.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the *collection-name* is unknown, then a *HTTP 404* is returned.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/collection/{collection-name}": {
      "get": {
        "tags": [
          "Collections"
        ],
        "summary": "Return information about a collection",
        "description": "The result is an object describing the collection with the following attributes:\n- *id*: The identifier of the collection. - *name*: The name of the collection. - *status*: The status of the collection as number.\n - 1: new born collection\n - 2: unloaded\n - 3: loaded\n - 4: in the process of being unloaded\n - 5: deleted\n - 6: loading\n\nEvery other status indicates a corrupted collection.\n- *type*: The type of the collection as number.\n  - 2: document collection (normal case)\n  - 3: edges collection\n- *isSystem*: If *true* then the collection is a system collection.",
        "operationId": "handleCommandGet:collectionGetProperties",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection-name",
            "in": "path",
            "description": "The name of the collection.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "Returned if the *collection-name* is unknown, then a *HTTP 404* is returned.\n",
            "content": {}
          }
        }
      },
      "delete": {
        "tags": [
          "Collections"
        ],
        "summary": "Drops a collection",
        "description": "\nDrops the collection identified by *collection-name*. If the collection was successfully dropped, an object is returned with the following attributes:\n- *error*: *false*\n- *id*: The identifier of the dropped collection.\n",
        "operationId": "handleCommandDelete:collection",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection-name",
            "in": "path",
            "description": "The name of the collection to drop.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "isSystem",
            "in": "query",
            "description": "Whether or not the collection to drop is a system collection. This parameter must be set to *true* in order to drop a system collection.\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "400": {
            "description": "Returned if the *collection-name* is missing, then a *HTTP 400* is returned.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the *collection-name* is unknown, then a *HTTP 404* is returned.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/collection/{collection-name}/count": {
      "get": {
        "tags": [
          "Collections"
        ],
        "summary": "Return number of documents in a collection",
        "description": "\nResult contains the number of documents.\n**Note** that this will always load the collection into memory.\n- *count*: The number of documents inside the collection.\n",
        "operationId": "handleCommandGet:getCollectionCount",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection-name",
            "in": "path",
            "description": "The name of the collection.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "400": {
            "description": "Returned if the *collection-name* is missing, then a *HTTP 400* is returned.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the *collection-name* is unknown, then a *HTTP 404* is returned.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/collection/{collection-name}/truncate": {
      "put": {
        "tags": [
          "Collections"
        ],
        "summary": "Truncate collection",
        "description": "Removes all documents from the collection, but leaves the indexes intact.\n",
        "operationId": "handleCommandPut:truncateCollection",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection-name",
            "in": "path",
            "description": "The name of the collection.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "400": {
            "description": "Returned if the *collection-name* is missing, then a *HTTP 400* is returned.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the *collection-name* is unknown, then a *HTTP 404* is returned.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/cursor": {
      "post": {
        "tags": [
          "Query"
        ],
        "summary": "Create cursor",
        "description": "\nA JSON object with these properties is required:\n - **ttl**: The time-to-live for the cursor (in seconds). The cursor will be removed on the server automatically after the specified amount of time. This is useful to ensure garbage collection of cursors that are not fully fetched by clients. If not set, a server-defined value will be used (default: 30 seconds).\n  - **query**: contains the query string to be executed\n  - **bindVars** (object): key/value pairs representing the bind parameters.\n  - **options**:\n    - **failOnWarning**: When set to *true*, the query will throw an exception and abort instead of producing a warning. This option should be used during development to catch potential issues early. When the attribute is set to *false*, warnings will not be propagated to exceptions and will be returned with the query result. There is also a server configuration option `--query.fail-on-warning` for setting the default value for *failOnWarning* so it does not need to be set on a per-query level.\n    - **profile**: If set to *true* or *1*, then the additional query profiling information will be returned in the sub-attribute *profile* of the *extra* return attribute, if the query result is not served from the query cache. Set to *2* the query will include execution stats per query plan node in sub-attribute *stats.nodes* of the *extra* return attribute. Additionally the query plan is returned in the sub-attribute *extra.plan*.\n    - **maxTransactionSize**: Transaction size limit in bytes. \n    - **stream**: Specify *true* and the query will be executed in a **streaming** fashion. The query result is not stored on the server, but calculated on the fly. *Beware*: long-running queries will need to hold the collection locks for as long as the query cursor exists. When set to *false* a query will be executed right away in its entirety. In that case query results are either returned right away (if the result set is small enough), or stored on the database instance and accessible via the cursor API (with respect to the `ttl`). It is advisable to *only* use this option on short-running queries or without exclusive locks . Query statistics, warnings and profiling data will only be available after the query is finished.\n    The default value is *false*\n    - **skipInaccessibleCollections**: C8QL queries (especially graph traversals) will treat collection to which a user has no access rights as if these collections were empty. Instead of returning a forbidden access error, your queries will execute normally. \n    - **maxWarningCount**: Limits the maximum number of warnings a query will return. The number of warnings a query will return is limited to 10 by default, but that number can be increased or decreased by setting this attribute.\n    - **intermediateCommitCount**: Maximum number of operations after which an intermediate commit is performed automatically. \n  - **fullCount**: if set to *true* and the query contains a *LIMIT* clause, then the result will have an *extra* attribute with the sub-attributes *stats* and *fullCount*, `{ ... , \"extra\": { \"stats\": { \"fullCount\": 123 } } }`. The *fullCount* attribute will contain the number of documents in the result before the last top-level LIMIT in the query was applied. It can be used to count the number of documents that match certain filter criteria, but only return a subset of them, in one go. It is thus similar to MySQL's *SQL_CALC_FOUND_ROWS* hint. Note that setting the option will disable a few LIMIT optimizations and may lead to more documents being processed, and thus make queries run longer. Note that the *fullCount* attribute may only be present in the result if the query has a top-level LIMIT clause and the LIMIT clause is actually used in the query.\n    - **intermediateCommitSize**: Maximum total size of operations after which an intermediate commit is performed automatically. \n    - **optimizer.rules** (string): A list of to-be-included or to-be-excluded optimizer rules can be put into this attribute, telling the optimizer to include or exclude specific rules. To disable a rule, prefix its name with a `-`, to enable a rule, prefix it with a `+`. There is also a pseudo-rule `all`, which will match all optimizer rules.\n \nThe query details include the query string plus optional query options and bind parameters. These values need to be passed in a JSON representation in the body of the POST request.\n\n**HTTP 201**\n*A json document with these Properties is returned:* is returned if the result set can be created by the server.\n- **count**: the total number of result documents available (only available if the query was executed with the *count* attribute set)\n- **code**: the HTTP status code\n- **extra**: an optional JSON object with extra information about the query result contained in its *stats* sub-attribute. For data-modification queries, the *extra.stats* sub-attribute will contain the number of modified documents and the number of documents that could not be modified due to an error (if *ignoreErrors* query option is specified)\n- **cached**: a boolean flag indicating whether the query result was served from the query cache or not. If the query result is served from the query cache, the *extra* return attribute will not contain any *stats* sub-attribute and no *profile* sub-attribute.\n- **hasMore**: A boolean indicator whether there are more results available for the cursor on the server\n- **result** (anonymous json object): an array of result documents (might be empty if query has no results)\n- **error**: A flag to indicate that an error occurred (*false* in this case)\n- **id**: id of temporary cursor created on the server (optional, see above)\n\n\n**HTTP 400**\n*A json document with these Properties is returned:* is returned if the JSON representation is malformed or the query specification is missing from the request. If the JSON representation is malformed or the query specification is missing from the request, the server will respond with *HTTP 400*. The body of the response will contain a JSON object with additional error details. The object has the following attributes:\n\n- **errorMessage**: a descriptive error message If the query specification is complete, the server will process the query. If an error occurs during query processing, the server will respond with *HTTP 400*. Again, the body of the response will contain details about the error.\n- **errorNum**: the server error number\n- **code**: the HTTP status code\n- **error**: boolean flag to indicate that an error occurred (*true* in this case)\n",
        "operationId": "createQueryCursor",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/api_cursor"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the result set can be created by the server.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/api_cursor_rc_201"
                }
              }
            },
            "x-description-offset": 305
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or the query specification is missing from the request. If the JSON representation is malformed or the query specification is missing from the request, the server will respond with *HTTP 400*. The body of the response will contain a JSON object with additional error details. The object has the following attributes:\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/api_cursor_rc_400"
                }
              }
            },
            "x-description-offset": 372
          },
          "404": {
            "description": "The server will respond with *HTTP 404* in case a non-existing collection is accessed in the query.\n\n",
            "content": {}
          },
          "405": {
            "description": "The server will respond with *HTTP 405* if an unsupported HTTP method is used.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/cursor/{cursor-identifier}": {
      "put": {
        "tags": [
          "Query"
        ],
        "summary": "Read next batch from cursor",
        "description": "If the cursor is still alive, returns an object with the following attributes:\n\n- *id*: the *cursor-identifier*\n- *result*: a list of documents for the current batch\n- *hasMore*: *false* if this was the last batch\n- *count*: if present the total number of elements\n\nNote that even if *hasMore* returns *true*, the next call might still return no documents. If, however, *hasMore* is *false*, then the cursor is exhausted.  Once the *hasMore* attribute has a value of *false*, the client can stop.\n\n",
        "operationId": "modifyQueryCursor",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "cursor-identifier",
            "in": "path",
            "description": "The name of the cursor.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The server will respond with *HTTP 200* in case of success.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the cursor identifier is omitted, the server will respond with *HTTP 404*.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if no cursor with the specified identifier can be found, the server will respond with *HTTP 404*.\n",
            "content": {}
          }
        }
      },
      "delete": {
        "tags": [
          "Query"
        ],
        "summary": "Delete cursor",
        "description": "Deletes the cursor and frees the resources associated with it. The cursor will automatically be destroyed on the server when the client has retrieved all documents from it. The client can also explicitly destroy the cursor at any earlier time using an HTTP DELETE request. The cursor id must be included as part of the URL. Note: the server will also destroy abandoned cursors automatically after a certain server-controlled timeout to avoid resource leakage.\n\n",
        "operationId": "deleteQueryCursor",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "cursor-identifier",
            "in": "path",
            "description": "The id of the cursor.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Returned if the server is aware of the cursor.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the server is not aware of the cursor. It is also returned if a cursor is used after it has been destroyed.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/query": {
      "post": {
        "tags": [
          "Query"
        ],
        "summary": "Parse an C8QL query",
        "description": "\nThis endpoint is for query validation only. To actually query the database, see `/api/cursor`.\n\nA JSON object with these properties is required:\n\n  - **query**: To validate a query string without executing it, the query string can be passed to the server via an HTTP POST request.\n\n",
        "operationId": "parseQuery",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/api_query_properties"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the query is valid, the server will respond with *HTTP 200* and return the names of the bind parameters it found in the query (if any) in the *bindVars* attribute of the response. It will also return an array of the collections used in the query in the *collections* attribute.\n\nIf a query can be parsed successfully, the *ast* attribute of the returned JSON will contain the abstract syntax tree representation of the query. The format of the *ast* is subject to change in future versions of database, but it can be used to inspect how database interprets a given query. Note that the abstract syntax tree will be returned without any optimizations applied to it.\n\n",
            "content": {}
          },
          "400": {
            "description": "The server will respond with *HTTP 400* in case of a malformed request, or if the query contains a parse error. The body of the response will contain the error details embedded in a JSON object.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/query/explain": {
      "post": {
        "tags": [
          "Query"
        ],
        "summary": "Explain an C8QL query",
        "description": "\nA JSON object with these properties is required:\n\n  - **query**: the query which you want explained; If the query references any bind variables, these must also be passed in the attribute *bindVars*. Additional options for the query can be passed in the *options* attribute.\n  - **options**:\n  - **bindVars** (object): key/value pairs representing the bind parameters.\n\nTo explain how an C8QL query would be executed on the server, the query string can be sent to the server via an HTTP POST request. The server will then validate the query and create an execution plan for it. The execution plan will be returned, but the query will not be executed.\n\nThe execution plan that is returned by the server can be used to estimate the probable performance of the query. Though the actual performance will depend on many different factors, the execution plan normally can provide some rough estimates on the amount of work the server needs to do in order to actually run the query.\n\nBy default, the explain operation will return the optimal plan as chosen by the query optimizer The optimal plan is the plan with the lowest total estimated cost. The plan will be returned in the attribute *plan* of the response object. If the option *allPlans* is specified in the request, the result will contain all plans created by the optimizer. The plans will then be returned in the attribute *plans*.\n\nThe result will also contain an attribute *warnings*, which is an array of warnings that occurred during optimization or execution plan creation. Additionally, a *stats* attribute is contained in the result with some optimizer statistics. If *allPlans* is set to *false*, the result will contain an attribute *cacheable* that states whether the query results can be cached on the server if the query result cache were used. The *cacheable* attribute is not present when *allPlans* is set to *true*.\n\nEach plan in the result is a JSON object with the following attributes:\n- *nodes*: the array of execution nodes of the plan.  \n- *estimatedCost*: the total estimated cost for the plan. If there are multiple plans, the optimizer will choose the plan with the lowest total cost. \n- *collections*: an array of collections used in the query \n- *rules*: an array of rules the optimizer applied.  \n- *variables*: array of variables used in the query \n\n",
        "operationId": "explainQuery",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/api_explain"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the query is valid, the server will respond with *HTTP 200* and return the optimal execution plan in the *plan* attribute of the response. If option *allPlans* was set in the request, an array of plans will be returned in the *allPlans* attribute instead.\n\n",
            "content": {}
          },
          "400": {
            "description": "The server will respond with *HTTP 400* in case of a malformed request, or if the query contains a parse error. The body of the response will contain the error details embedded in a JSON object. Omitting bind variables if the query references any will also result in an *HTTP 400* error.\n\n",
            "content": {}
          },
          "404": {
            "description": "The server will respond with *HTTP 404* in case a non-existing collection is accessed in the query.\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/restql": {
      "post": {
        "tags": [
          "Query as API"
        ],
        "summary": "Save restql by name",
        "description": "\nA JSON object with these properties is required:\n\n  - **query**:\n    - **parameter**: bindVars for the query \n    - **name**: Name for the query \n    - **value**: value of the query \n\nsaves a query for a user for a given fabric.\n\n",
        "operationId": "SaveRestqlByName",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name for which to save user query.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_queries_create_user_queries"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Accepted.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n",
            "content": {}
          }
        },
        "x-hints": "",
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/restql/execute/{name}": {
      "post": {
        "tags": [
          "Query as API"
        ],
        "summary": "Execute restql by name",
        "description": "\nA JSON object with these properties is required:\n\n  - **bindVars**: specify the bindVars of the query\n\nexecutes a saved query for a given fabric.\n\n",
        "operationId": "ExecuteRestqlByName",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name of the saved user query.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "name",
            "in": "path",
            "description": "Query name to execute.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_queries_execute_saved_queries"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Accepted.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n",
            "content": {}
          }
        },
        "x-hints": "",
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/restql/fetch/{id}": {
      "put": {
        "tags": [
          "Query as API"
        ],
        "summary": "Read next batch from cursor",
        "description": "If the restql cursor is still alive, returns an object with the following attributes:\n\n- *id*: the *cursor-identifier*\n- *result*: a list of documents for the current batch\n- *hasMore*: *false* if this was the last batch\n- *count*: if present the total number of elements\n\nNote that even if *hasMore* returns *true*, the next call might still return no documents. If, however, *hasMore* is *false*, then the cursor is exhausted.  Once the *hasMore* attribute has a value of *false*, the client can stop.\n\n",
        "operationId": "fetchRestqlCursor",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "id",
            "in": "path",
            "description": "The id of the cursor.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The server will respond with *HTTP 200* in case of success.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the cursor identifier is omitted, the server will respond with *HTTP 404*.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if no cursor with the specified identifier can be found, the server will respond with *HTTP 404*.\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/restql/user": {
      "get": {
        "tags": [
          "Query as API"
        ],
        "summary": "List restql associated with current user",
        "description": "\nGet list of saved user queries under the given fabric. \n\n",
        "operationId": "ListRestqlAssociatedWithCurrentUser",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name for which to list saved user queries.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n",
            "content": {}
          }
        },
        "x-hints": ""
      }
    },
    "/_fabric/{fabric}/_api/restql/{name}": {
      "put": {
        "tags": [
          "Query as API"
        ],
        "summary": "Update restql by name",
        "description": "\nA JSON object with these properties is required:\n\n  - **query**:\n    - **parameter**: bindVars for the query \n    - **value**: value for the query \n\nUpdate a saved query for a given fabric.\n\n",
        "operationId": "UpdateRestqlByName",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name for which to update a query.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "name",
            "in": "path",
            "description": "Query name to update.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_queries_update_user_queries"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Accepted.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n",
            "content": {}
          }
        },
        "x-hints": "",
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "Query as API"
        ],
        "summary": "Delete restql by name",
        "description": "Delete a query under the given fabric.\n\n",
        "operationId": "DeleteRestqlByName",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name for which to delete a query.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "name",
            "in": "path",
            "description": "Query name to be deleted.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n\n",
            "content": {}
          }
        },
        "x-hints": ""
      }
    },
    "/_fabric/{fabric}/_api/index": {
      "get": {
        "tags": [
          "Indexes"
        ],
        "summary": "Read all indexes of a collection",
        "description": "Returns an object with an attribute *indexes* containing an array of all index descriptions for the given collection. The same information is also available in the *identifiers* as an object with the index handles as keys.\n\n",
        "operationId": "getIndexes",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "query",
            "description": "The collection name.\n\n",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns a JSON object containing a list of indexes on that collection.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/index/fulltext": {
      "post": {
        "tags": [
          "Indexes"
        ],
        "summary": "Create fulltext index",
        "description": "\nA JSON object with these properties is required:\n\n  - **fields** (string): an array of attribute names. Currently, the array is limited\n   to exactly one attribute.\n  - **type**: must be equal to *\"fulltext\"*.\n  - **minLength**: Minimum character length of words to index. Will default to a server-defined value if unspecified. It is thus recommended to set this value explicitly when creating the index.\n\nCreates a fulltext index for the collection *collection-name*, if it does not already exist. The call expects an object containing the index details.\n\n",
        "operationId": "createIndex#fulltext",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "query",
            "description": "The collection name.\n\n",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/api_index_fulltext"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the index already exists, then a *HTTP 200* is returned.\n\n",
            "content": {}
          },
          "201": {
            "description": "Returned if the index does not already exist and could be created, then a *HTTP 201* is returned.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the *collection-name* is unknown, then a *HTTP 404* is returned.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/index/general": {
      "post": {
        "tags": [
          "Indexes"
        ],
        "summary": "Create index",
        "description": "\nCreates a new index in the collection *collection*. Expects an object containing the index details.\n\nThe type of the index to be created must specified in the *type* attribute of the index details. Depending on the index type, additional other attributes may need to specified in the request in order to create the index.\n\nIndexes require the to be indexed attribute(s) in the *fields* attribute of the index details. Depending on the index type, a single attribute or multiple attributes can be indexed. In the latter case, an array of strings is expected.\n\nIndexing the system attribute *_id* is not supported for user-defined indexes. Manually creating an index using *_id* as an index attribute will fail with an error.\n\nOptionally, an index name may be specified as a string in the *name* attribute. Index names have the same restrictions as collection names. If no value is specified, one will be auto-generated.\n\nSome indexes can be created as unique or non-unique variants. Uniqueness can be controlled for most indexes by specifying the *unique* flag in the index details. Setting it to *true* will create a unique index. Setting it to *false* or omitting the *unique* attribute will create a non-unique index.\n\n**Note**: \nThe following index types do not support uniqueness, and using the *unique* attribute with these types may lead to an error:\n- geo indexes\n- fulltext indexes\n\n**Note**: \nUnique indexes on non-shard keys are not supported in a cluster.\n\nHash, skiplist and persistent indexes can optionally be created in a sparse variant. A sparse index will be created if the *sparse* attribute in the index details is set to *true*. Sparse indexes do not index documents for which any of the index attributes is either not set or is *null*. \n\nThe optional attribute **deduplicate** is supported by array indexes of type *hash* or *skiplist*. It controls whether inserting duplicate index values from the same document into a unique array index will lead to a unique constraint error or not. The default value is *true*, so only a single instance of each non-unique index value will be inserted into the index per document. \n\nTrying to insert a value into the index that already exists in the index will always fail, regardless of the value of this attribute.\n\n",
        "operationId": "createIndex:general",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "query",
            "description": "The collection name.\n\n",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the index already exists, then an *HTTP 200* is returned.\n\n",
            "content": {}
          },
          "201": {
            "description": "Returned if the index does not already exist and could be created, then an *HTTP 201* is returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if an invalid index description is posted or attributes are used that the target index will not support, then an *HTTP 400* is returned.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if *collection* is unknown, then an *HTTP 404* is returned.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/index/geo": {
      "post": {
        "tags": [
          "Indexes"
        ],
        "summary": "Create geo-spatial index",
        "description": "\nA JSON object with these properties is required:\n\n  - **fields** (string): An array with one or two attribute paths. If it is an array with one attribute path *location*, then a geo-spatial index on all documents is created using *location* as path to the coordinates. The value of the attribute must be an array with at least two double values. The array must contain the latitude (first value) and the longitude (second value). \n  \n  All documents, which do not have the attribute path or with value that are not suitable, are ignored.If it is an array with two attribute paths *latitude* and *longitude*, then a geo-spatial index on all documents is created using *latitude* and *longitude* as paths the latitude and the longitude. The value of the attribute *latitude* and of the attribute *longitude* must a double. All documents, which do not have the attribute paths or which values are not suitable, are ignored.\n  - **type**: must be equal to *\"geo\"*.\n  - **geoJson**: If a geo-spatial index on a *location* is constructed and *geoJson* is *true*, then the order within the array is longitude followed by latitude. This corresponds to the format described in http://geojson.org/geojson-spec.html#positions\n\nCreates a geo-spatial index in the collection *collection-name*, if it does not already exist. Expects an object containing the index details. Geo indexes are always sparse, meaning that documents that do not contain the index attributes or have non-numeric values in the index attributes will not be indexed.\n\n",
        "operationId": "createIndex#geo",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "query",
            "description": "The collection name.\n\n",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/api_index_geo"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the index already exists, then a *HTTP 200* is returned.\n\n",
            "content": {}
          },
          "201": {
            "description": "Returned if the index does not already exist and could be created, then a *HTTP 201* is returned.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the *collection-name* is unknown, then a *HTTP 404* is returned.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/index/hash": {
      "post": {
        "tags": [
          "Indexes"
        ],
        "summary": "Create hash index",
        "description": "\nA JSON object with these properties is required:\n\n  - **fields** (string): an array of attribute paths.\n  - **unique**: if *true*, then create a unique index.\n  - **type**: must be equal to *\"hash\"*.\n  - **sparse**: if *true*, then create a sparse index.\n  - **deduplicate**: if *false*, the deduplication of array values is turned off.\n\nCreates a hash index for the collection *collection-name* if it does not already exist. The call expects an object containing the index details.\n\nIn a sparse index all documents will be excluded from the index that do not contain at least one of the specified index attributes (i.e. *fields*) or that have a value of *null* in any of the specified index attributes. Such documents will not be indexed, and not be taken into account for uniqueness checks if the *unique* flag is set.\n\nIn a non-sparse index, these documents will be indexed (for non-present indexed attributes, a value of *null* will be used) and will be taken into account for uniqueness checks if the *unique* flag is set.\n\n**Note**: unique indexes on non-shard keys are not supported in a cluster.\n\n",
        "operationId": "createIndex:hash",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "query",
            "description": "The collection name.\n\n",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/api_index_hash"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the index already exists, then a *HTTP 200* is returned.\n\n",
            "content": {}
          },
          "201": {
            "description": "Returned if the index does not already exist and could be created, then a *HTTP 201* is returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the collection already contains documents and you try to create a unique hash index in such a way that there are documents violating the uniqueness, then a *HTTP 400* is returned.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the *collection-name* is unknown, then a *HTTP 404* is returned.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/index/persistent": {
      "post": {
        "tags": [
          "Indexes"
        ],
        "summary": "Create a persistent index",
        "description": "\nA JSON object with these properties is required:\n\n  - **fields** (string): an array of attribute paths.\n  - **unique**: if *true*, then create a unique index.\n  - **type**: must be equal to *\"persistent\"*.\n  - **sparse**: if *true*, then create a sparse index.\n\n\nCreates a persistent index for the collection *collection-name*, if it does not already exist. The call expects an object containing the index details.\n\nIn a sparse index all documents will be excluded from the index that do not contain at least one of the specified index attributes (i.e. *fields*) or that have a value of *null* in any of the specified index attributes. Such documents will not be indexed, and not be taken into account for uniqueness checks if the *unique* flag is set.\n\nIn a non-sparse index, these documents will be indexed (for non-present indexed attributes, a value of *null* will be used) and will be taken into account for uniqueness checks if the *unique* flag is set.\n\n**Note**: unique indexes on non-shard keys are not supported in a cluster.\n\n",
        "operationId": "createIndex:persistent",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "query",
            "description": "The collection name.\n\n",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/api_index_persistent"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the index already exists, then a *HTTP 200* is returned.\n\n",
            "content": {}
          },
          "201": {
            "description": "Returned if the index does not already exist and could be created, then a *HTTP 201* is returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the collection already contains documents and you try to create a unique persistent index in such a way that there are documents violating the uniqueness, then a *HTTP 400* is returned.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the *collection-name* is unknown, then a *HTTP 404* is returned.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/index/skiplist": {
      "post": {
        "tags": [
          "Indexes"
        ],
        "summary": "Create skip list",
        "description": "\nA JSON object with these properties is required:\n\n  - **fields** (string): an array of attribute paths.\n  - **unique**: if *true*, then create a unique index.\n  - **type**: must be equal to *\"skiplist\"*.\n  - **sparse**: if *true*, then create a sparse index.\n  - **deduplicate**: if *false*, the deduplication of array values is turned off.\n\n\nCreates a skip-list index for the collection *collection-name*, if it does not already exist. The call expects an object containing the index details.\n\nIn a sparse index all documents will be excluded from the index that do not contain at least one of the specified index attributes (i.e. *fields*) or that have a value of *null* in any of the specified index attributes. Such documents will not be indexed, and not be taken into account for uniqueness checks if the *unique* flag is set.\n\nIn a non-sparse index, these documents will be indexed (for non-present indexed attributes, a value of *null* will be used) and will be taken into account for uniqueness checks if the *unique* flag is set.\n\n**Note**: unique indexes on non-shard keys are not supported in a cluster.\n\n",
        "operationId": "createIndex:skiplist",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "query",
            "description": "The collection name.\n\n",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/api_index_skiplist"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the index already exists, then a *HTTP 200* is returned.\n\n",
            "content": {}
          },
          "201": {
            "description": "Returned if the index does not already exist and could be created, then a *HTTP 201* is returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the collection already contains documents and you try to create a unique skip-list index in such a way that there are documents violating the uniqueness, then a *HTTP 400* is returned.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the *collection-name* is unknown, then a *HTTP 404* is returned.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/index/ttl": {
      "post": {
        "tags": [
          "Indexes"
        ],
        "summary": "Create TTL index",
        "description": "\nA JSON object with these properties is required:\n\n  - **fields** (string): an array with exactly one attribute path.\n  - **type**: must be equal to *\"ttl\"*.\n  - **expireAfter**: The time (in seconds) after a document's creation after which the documents count as \"expired\".\n\nCreates a TTL index for the collection *collection-name* if it does not already exist. The call expects an object containing the index details.\n\n\n",
        "operationId": "createIndex:ttl",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "query",
            "description": "The collection name.\n\n",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/api_index_ttl"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the index already exists, then a *HTTP 200* is returned.\n\n",
            "content": {}
          },
          "201": {
            "description": "Returned if the index does not already exist and could be created, then a *HTTP 201* is returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the collection already contains another TTL index, then an *HTTP 400* is returned, as there can be at most one TTL index per collection.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the *collection-name* is unknown, then a *HTTP 404* is returned.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/index/{collection}/{indexName}": {
      "get": {
        "tags": [
          "Indexes"
        ],
        "summary": "Read index",
        "description": "\n\nThe result is an object describing the index. It has at least the following attributes:\n- *id*: the identifier of the index - *type*: the index type\n\nAll other attributes are type-dependent. For example, some indexes provide *unique* or *sparse* flags, whereas others don't. Some indexes also provide a selectivity estimate in the *selectivityEstimate* attribute of the result.\n\n",
        "operationId": "getIndexes:handle",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The collection name.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "indexName",
            "in": "path",
            "description": "The name of the index.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the index exists, then a *HTTP 200* is returned.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the index does not exist, then a *HTTP 404* is returned.\n\n",
            "content": {}
          }
        },
        "x-filename": "database/Documentation/DocuBlocks/Rest/Indexes/get_api_reads_index.md",
        "x-hints": ""
      },
      "delete": {
        "tags": [
          "Indexes"
        ],
        "summary": "Delete index",
        "description": "\nDeletes an index with *indexName*.\n\n",
        "operationId": "dropIndex",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The collection name.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "indexName",
            "in": "path",
            "description": "The name of the index.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the index could be deleted, then an *HTTP 200* is\nreturned.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the *indexName* is unknown, then an *HTTP 404* is returned.\n",
            "content": {}
          }
        },
        "x-filename": "database/Documentation/DocuBlocks/Rest/Indexes/api_index_delete.md",
        "x-hints": ""
      }
    },
    "/_fabric/{fabric}/_api/transaction": {
      "post": {
        "tags": [
          "Transactions"
        ],
        "summary": "Execute transaction",
        "description": "\nA JSON object with these properties is required:\n\n  - **allowImplicit**: Allow reading from undeclared collections.\n  - **params**: optional arguments passed to *action*.\n  - **action**: the actual transaction operations to be executed, in the form of stringified JavaScript code. The code will be executed on server side, with late binding. It is thus critical that the code specified in *action* properly sets up all the variables it needs. If the code specified in *action* ends with a return statement, the value returned will also be returned by the REST API in the *result* attribute if the transaction committed successfully.\n  - **collections**: *collections* must be a JSON object that can have one or all sub-attributes *read*, *write* or *exclusive*, each being an array of collection names or a single collection name as string. Collections that will be written to in the transaction must be declared with the *write* or *exclusive* attribute or it will fail, whereas non-declared collections from which is solely read will be added lazily. The optional sub-attribute *allowImplicit* can be set to *false* to let transactions fail in case of undeclared collections for reading. Collections for reading should be fully declared if possible, to avoid deadlocks.\n   \nThe transaction description must be passed in the body of the POST request. If the transaction is fully executed and committed on the server, *HTTP 200* will be returned. Additionally, the return value of the code defined in *action* will be returned in the *result* attribute.\n\nFor successfully committed transactions, the returned JSON object has the following properties:\n\n- *error*: boolean flag to indicate if an error occurred (*false* in this case)\n- *code*: the HTTP status code\n- *result*: the return value of the transaction\n\nIf the transaction specification is either missing or malformed, the server will respond with *HTTP 400*.\n\nThe body of the response will then contain a JSON object with additional error details. The object has the following attributes:\n\n- *error*: boolean flag to indicate that an error occurred (*true* in this case)\n- *code*: the HTTP status code\n- *errorNum*: the server error number\n- *errorMessage*: a descriptive error message\n\nIf a transaction fails to commit, either by an exception thrown in the *action* code, or by an internal error, the server will respond with an error.\nAny other errors will be returned with any of the return codes *HTTP 400*, *HTTP 409*, or *HTTP 500*.\n\n\n",
        "operationId": "executeCommit",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/api_transaction"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the transaction is fully executed and committed on the server, *HTTP 200* will be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the transaction specification is either missing or malformed, the server will respond with *HTTP 400*.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the transaction specification contains an unknown collection, the server will respond with *HTTP 404*.\n\n",
            "content": {}
          },
          "500": {
            "description": "Exceptions thrown by users will make the server respond with a return code of *HTTP 500*\n\n",
            "content": {}
          }
        },
        "x-filename": "database/Documentation/DocuBlocks/Rest/Transactions/api_transaction.md",
        "x-hints": "",
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/transaction/begin": {
      "post": {
        "tags": [
          "Transactions"
        ],
        "summary": "Begin transaction",
        "description": "\nA JSON object with these properties is required:\n\n  - **allowImplicit**: Allow reading from undeclared collections.\n  - **collections**: *collections* must be a JSON object that can have one or all sub-attributes *read*, *write* or *exclusive*, each being an array of collection names or a single collection name as string. Collections that will be written to in the transaction must be declared with the *write* or *exclusive* attribute or it will fail, whereas non-declared collections from which is solely read will be added lazily. The optional sub-attribute *allowImplicit* can be set to *false* to let transactions fail in case of undeclared collections for reading. Collections for reading should be fully declared if possible, to avoid deadlocks.\n\nThe transaction description must be passed in the body of the POST request. If the transaction can be started on the server, *HTTP 201* will be returned. \n\nFor successfully started transactions, the returned JSON object has the following properties:\n- *error*: boolean flag to indicate if an error occurred (*false* in this case)\n- *code*: the HTTP status code\n- *result*: result containing\n    - *id*: the identifier of the transaction\n    - *status*: containing the string 'running'\n\nIf the transaction specification is either missing or malformed, the server will respond with *HTTP 400* or *HTTP 404*. The body of the response will then contain a JSON object with additional error details. The object has the following attributes:\n- *error*: boolean flag to indicate that an error occurred (*true* in this case)\n- *code*: the HTTP status code\n- *errorNum*: the server error number\n- *errorMessage*: a descriptive error message.\n\n\n",
        "operationId": "executeBegin",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/api_transaction_begin"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the transaction is running on the server,\n*HTTP 201* will be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the transaction specification is either missing or malformed, the server\nwill respond with *HTTP 400*.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the transaction specification contains an unknown collection, the server\nwill respond with *HTTP 404*.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/transaction/{transaction-id}": {
      "get": {
        "tags": [
          "Transactions"
        ],
        "summary": "Get transaction status",
        "description": "\nThe result is an object describing the status of the transaction. \n\nIt has at least the following attributes:\n- *id*: the identifier of the transaction\n- *status*: the status of the transaction. One of \"running\", \"committed\" or \"aborted\".\n\n",
        "operationId": "executeGetState:transaction",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "transaction-id",
            "in": "path",
            "description": "The transaction identifier.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the transaction is fully executed and committed on the server,\n*HTTP 200* will be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the transaction identifier specified is either missing or malformed, the server\nwill respond with *HTTP 400*.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the transaction was not found with the specified identifier, the server\nwill respond with *HTTP 404*.\n\n",
            "content": {}
          }
        }
      },
      "put": {
        "tags": [
          "Transactions"
        ],
        "summary": "Commit transaction",
        "description": "\nCommit a running server-side transaction. Committing is an idempotent operation. It is not an error to commit a transaction more than once. If the transaction can be committed, *HTTP 200* will be returned. The returned JSON object has the following properties:\n\n- *error*: boolean flag to indicate if an error occurred (*false* in this case)\n- *code*: the HTTP status code\n- *result*: result containing\n    - *id*: the identifier of the transaction\n    - *status*: containing the string 'committed'\n\nIf the transaction cannot be found, committing is not allowed or the transaction was aborted, the server will respond with *HTTP 400*, *HTTP 404* or *HTTP 409*.\n\nThe body of the response will then contain a JSON object with additional error details. The object has the following attributes:\n\n- *error*: boolean flag to indicate that an error occurred (*true* in this case)\n- *code*: the HTTP status code\n- *errorNum*: the server error number\n- *errorMessage*: a descriptive error message.\n\n\n",
        "operationId": "executeCommit:Transaction",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "transaction-id",
            "in": "path",
            "description": "The transaction identifier,\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the transaction was committed,\n*HTTP 200* will be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the transaction cannot be committed, the server\nwill respond with *HTTP 400*.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the transaction was not found, the server\nwill respond with *HTTP 404*.\n\n",
            "content": {}
          },
          "409": {
            "description": "Returned if the transaction was already aborted, the server\nwill respond with *HTTP 409*.\n\n",
            "content": {}
          }
        }
      },
      "delete": {
        "tags": [
          "Transactions"
        ],
        "summary": "Abort transaction",
        "description": "\nAbort a running server-side transaction. Aborting is an idempotent operation. It is not an error to abort a transaction more than once. If the transaction can be aborted, *HTTP 200* will be returned. \nThe returned JSON object has the following properties:\n\n- *error*: boolean flag to indicate if an error occurred (*false* in this case)\n\n- *code*: the HTTP status code\n\n- *result*: result containing\n    - *id*: the identifier of the transaction\n    - *status*: containing the string 'aborted'\n\nIf the transaction cannot be found, aborting is not allowed or the transaction was already committed, the server will respond with *HTTP 400*, *HTTP 404* or *HTTP 409*.\n\nThe body of the response will then contain a JSON object with additional error details. The object has the following attributes:\n- *error*: boolean flag to indicate that an error occurred (*true* in this case)\n- *code*: the HTTP status code\n- *errorNum*: the server error number\n- *errorMessage*: a descriptive error message.\n\n",
        "operationId": "executeAbort:transaction",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "transaction-id",
            "in": "path",
            "description": "The transaction identifier,\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the transaction was aborted,\n*HTTP 200* will be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the transaction cannot be aborted, the server\nwill respond with *HTTP 400*.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the transaction was not found, the server\nwill respond with *HTTP 404*.\n\n",
            "content": {}
          },
          "409": {
            "description": "Returned if the transaction was already committed, the server\nwill respond with *HTTP 409*.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/graph": {
      "get": {
        "tags": [
          "Graphs"
        ],
        "summary": "List all graphs",
        "description": "\nLists all graphs stored in this database.\n\n**HTTP 200**\n*A json document with these Properties is returned:*\n\nReturned if the module is available and the graphs could be listed.\n\n- **graphs**: \n  - **graph**:\n    - **orphanCollections** (string): An array of additional vertex collections. Documents within these collections do not have edges within this graph.\n    - **name**: The name of the graph.\n    - **_rev**: The revision of this graph. Can be used to make sure to not override concurrent modifications to this graph.\n    - **_id**: The internal id value of this graph. \n    - **edgedefinitions**: An array of definitions for the relations of the graph.\n  Each has the following type:\n    - **to** (string): List of vertex collection names. Edges in collection can only be inserted if their _to is in any of the collections here.\n    - **from** (string): List of vertex collection names. Edges in collection can only be inserted if their _from is in any of the collections here.\n    - **collection**: Name of the edge collection, where the edge are stored in.\n- **code**: The response code.\n- **error**: Flag if there was an error (true) or not (false). It is false in this response.\n\n",
        "operationId": "ListAllGraphs",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the module is available and the graphs could be listed.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_list_http_examples_rc_200"
                }
              }
            },
            "x-description-offset": 112
          }
        }
      },
      "post": {
        "tags": [
          "Graphs"
        ],
        "summary": "Create a graph",
        "description": "The creation of a graph requires the name of the graph and a definition of its edges.\nA JSON object with these properties is required:\n\n  - **edgedefinitions**: An array of definitions for the relations of the graph.\n   Each has the following type:\n    - **to** (string): List of vertex collection names. Edges in collection can only be inserted if their _to is in any of the collections here.\n    - **from** (string): List of vertex collection names. Edges in collection can only be inserted if their _from is in any of the collections here.\n    - **collection**: Name of the edge collection, where the edge are stored in.\n  - **name**: Name of the graph.\n\n**HTTP 201**\n*A json document with these Properties is returned:*\nReturned if the graph could be created and waitForSync is enabled for the `_graphs` collection, or given in the request.\nThe response body contains the graph configuration that has been stored.\n- **graph**:\n  - **orphanCollections** (string): An array of additional vertex collections. Documents within these collections do not have edges within this graph.\n  - **name**: The name of the graph.\n  - **_rev**: The revision of this graph. Can be used to make sure to not override concurrent modifications to this graph.\n  - **_id**: The internal id value of this graph. \n  - **edgedefinitions**: An array of definitions for the relations of the graph.\n   Each has the following type:\n    - **to** (string): List of vertex collection names. Edges in collection can only be inserted if their _to is in any of the collections here.\n    - **from** (string): List of vertex collection names. Edges in collection can only be inserted if their _from is in any of the collections here.\n    - **collection**: Name of the edge collection, where the edge are stored in.\n- **code**: The response code. - **error**: Flag if there was an error (true) or not (false). It is false in this response.\n**HTTP 202**\n*A json document with these Properties is returned:* Returned if the graph could be created and waitForSync is disabled for the `_graphs` collection and not given in the request.\nThe response body contains the graph configuration that has been stored.\n- **graph**:\n - **orphanCollections** (string): An array of additional vertex collections. Documents within these collections do not have edges within this graph.\n  - **name**: The name of the graph.\n  - **_rev**: The revision of this graph. Can be used to make sure to not override concurrent modifications to this graph.\n  - **_id**: The internal id value of this graph. \n  - **edgedefinitions**: An array of definitions for the relations of the graph.\n   Each has the following type:\n    - **to** (string): List of vertex collection names. Edges in collection can only be inserted if their _to is in any of the collections here.\n    - **from** (string): List of vertex collection names. Edges in collection can only be inserted if their _from is in any of the collections here.\n    - **collection**: Name of the edge collection, where the edge are stored in.\n- **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n**HTTP 400**\n*A json document with these Properties is returned:*\nReturned if the request is in a wrong format.\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n**HTTP 403**\n*A json document with these Properties is returned:*\nReturned if your user has insufficient rights.\nIn order to create a graph you at least need to have the following privileges:\n  1. `Administrate` access on the Database.\n  2. `Read Only` access on every collection used within this graph.\n\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n**HTTP 409**\n*A json document with these Properties is returned:*\nReturned if there is a conflict storing the graph.  This can occur either if a graph with this name is already stored, or if there is one edge definition with a the same [edge collection](../../Manual/Appendix/Glossary.html#edge-collection) but a different signature used in any other graph.\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n",
        "operationId": "CreateAGraph",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/graph_create_http_examples"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the graph could be created and waitForSync is enabled for the `_graphs` collection, or given in the request. The response body contains the graph configuration that has been stored.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_create_http_examples_rc_201"
                }
              }
            },
            "x-description-offset": 307
          },
          "202": {
            "description": "Returned if the graph could be created and waitForSync is disabled for the `_graphs` collection and not given in the request. The response body contains the graph configuration that has been stored.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_create_http_examples_rc_202"
                }
              }
            },
            "x-description-offset": 374
          },
          "400": {
            "description": "Returned if the request is in a wrong format.\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_create_http_examples_rc_400"
                }
              }
            },
            "x-description-offset": 441
          },
          "403": {
            "description": "Returned if your user has insufficient rights. In order to create a graph you at least need to have the following privileges:\n\n  1. `Administrate` access on the Database.\n  2. `Read Only` access on every collection used within this graph.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_create_http_examples_rc_403"
                }
              }
            },
            "x-description-offset": 508
          },
          "409": {
            "description": "Returned if there is a conflict storing the graph.  This can occur either if a graph with this name is already stored, or if there is one edge definition with a the same [edge collection](../../Manual/Appendix/Glossary.html#edge-collection) but a different signature used in any other graph.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_create_http_examples_rc_409"
                }
              }
            },
            "x-description-offset": 575
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/graph/{graph}": {
      "get": {
        "tags": [
          "Graphs"
        ],
        "summary": "Get a graph",
        "description": "Selects information for a given graph. Will return the edge definitions as well as the orphan collections. Or returns a 404 if the graph does not exist.\n\n\n**HTTP 200**\n*A json document with these Properties is returned:*\n\nReturns the graph if it could be found.\nThe result will have the following format:\n\n- **graph**:\n  - **orphanCollections** (string): An array of additional vertex collections. Documents within these collections do not have edges within this graph.\n  - **name**: The name of the graph.\n  - **_rev**: The revision of this graph. Can be used to make sure to not override concurrent modifications to this graph.\n  - **_id**: The internal id value of this graph. \n  - **edgedefinitions**: An array of definitions for the relations of the graph.\n   Each has the following type:\n    - **to** (string): List of vertex collection names. Edges in collection can only be inserted if their _to is in any of the collections here.\n    - **from** (string): List of vertex collection names. Edges in collection can only be inserted if their _from is in any of the collections here.\n    - **collection**: Name of the edge collection, where the edge are stored in.\n- **code**: The response code.\n- **error**: Flag if there was an error (true) or not (false). It is false in this response.\n\n\n**HTTP 404**\n*A json document with these Properties is returned:*\n\nReturned if no graph with this name could be found.\n\n- **errorMessage**: A message created for this error.\n- **errorNum**: database error number for the error that occurred.\n- **code**: The response code.\n- **error**: Flag if there was an error (true) or not (false). It is true in this response.\n\n",
        "operationId": "GetAGraph",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the graph if it could be found. The result will have the following format:\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_get_http_examples_rc_200"
                }
              }
            },
            "x-description-offset": 223
          },
          "404": {
            "description": "Returned if no graph with this name could be found.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_get_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 290
          }
        }
      },
      "delete": {
        "tags": [
          "Graphs"
        ],
        "summary": "Drop a graph",
        "description": "Drops an existing graph object by name. Optionally all collections not used by other graphs can be dropped as well.\n**HTTP 403**\n*A json document with these Properties is returned:*\nReturned if your user has insufficient rights.\nIn order to drop a graph you at least need to have the following privileges:\n  1. `Administrate` access on the Database.\n\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n**HTTP 404**\n*A json document with these Properties is returned:*\nReturned if no graph with this name could be found.\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
        "operationId": "DropAGraph",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dropCollections",
            "in": "query",
            "description": "Drop collections of this graph as well.  Collections will only be dropped if they are not used in other graphs.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Returned if the graph could be dropped and waitForSync is enabled for the `_graphs` collection, or given in the request.\n\n",
            "content": {}
          },
          "202": {
            "description": "Returned if the graph could be dropped and waitForSync is disabled for the `_graphs` collection and not given in the request.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if your user has insufficient rights.\nIn order to drop a graph you at least need to have the following privileges:\n  1. `Administrate` access on the Database.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_drop_http_examples_rc_403"
                }
              }
            },
            "x-description-offset": 186
          },
          "404": {
            "description": "Returned if no graph with this name could be found.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_drop_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 253
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/graph/{graph}/edge": {
      "get": {
        "tags": [
          "Graphs"
        ],
        "summary": "List edge definitions",
        "description": "\n\nLists all edge collections within this graph.\n**HTTP 200**\n*A json document with these Properties is returned:*\nReturned if the edge definitions could be listed.\n- **code**: The response code. - **collections** (string): The list of all vertex collections within this graph. Includes collections in edgedefinitions as well as orphans. - **error**: Flag if there was an error (true) or not (false). It is false in this response.\n**HTTP 404**\n*A json document with these Properties is returned:*\nReturned if no graph with this name could be found.\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false). It is true in this response.\n\n",
        "operationId": "ListEdgedefinitions",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the edge definitions could be listed.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_list_edge_http_examples_rc_200"
                }
              }
            },
            "x-description-offset": 116
          },
          "404": {
            "description": "Returned if no graph with this name could be found.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_list_edge_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 183
          }
        }
      },
      "post": {
        "tags": [
          "Graphs"
        ],
        "summary": "Add edge definition",
        "description": "Adds an additional edge definition to the graph.\nThis edge definition has to contain a *collection* and an array of each *from* and *to* vertex collections.  An edge definition can only be added if this definition is either not used in any other graph, or it is used with exactly the same definition. It is not possible to store a definition \"e\" from \"v1\" to \"v2\" in the one graph, and \"e\" from \"v2\" to \"v1\" in the other graph.\nA JSON object with these properties is required:\n\n  - **to** (string): One or many vertex collections that can contain target vertices.\n  - **from** (string): One or many vertex collections that can contain source vertices.\n  - **collection**: The name of the edge collection to be used.\n\n**HTTP 201**\n*A json document with these Properties is returned:*\nReturned if the definition could be added successfully and waitForSync is enabled for the `_graphs` collection. The response body contains the graph configuration that has been stored.\n- **graph**:\n  - **orphanCollections** (string): An array of additional vertex collections. Documents within these collections do not have edges within this graph.\n  - **name**: The name of the graph.\n  - **_rev**: The revision of this graph. Can be used to make sure to not override concurrent modifications to this graph.\n - **_id**: The internal id value of this graph. \n  - **edgedefinitions**: An array of definitions for the relations of the graph.\n   Each has the following type:\n    - **to** (string): List of vertex collection names. Edges in collection can only be inserted if their _to is in any of the collections here.\n    - **from** (string): List of vertex collection names. Edges in collection can only be inserted if their _from is in any of the collections here.\n    - **collection**: Name of the edge collection, where the edge are stored in.\n- **code**: The response code. - **error**: Flag if there was an error (true) or not (false). It is false in this response.\n**HTTP 202**\n*A json document with these Properties is returned:*\nReturned if the definition could be added successfully and waitForSync is disabled for the `_graphs` collection. The response body contains the graph configuration that has been stored.\n- **graph**:\n  - **orphanCollections** (string): An array of additional vertex collections. Documents within these collections do not have edges within this graph.\n  - **name**: The name of the graph.\n  - **_rev**: The revision of this graph. Can be used to make sure to not override concurrent modifications to this graph.\n - **_id**: The internal id value of this graph. \n  - **edgedefinitions**: An array of definitions for the relations of the graph.\n   Each has the following type:\n    - **to** (string): List of vertex collection names. Edges in collection can only be inserted if their _to is in any of the collections here.\n    - **from** (string): List of vertex collection names. Edges in collection can only be inserted if their _from is in any of the collections here.\n    - **collection**: Name of the edge collection, where the edge are stored in.\n- **code**: The response code. - **error**: Flag if there was an error (true) or not (false). It is false in this response.\n\n\n**HTTP 400**\n*A json document with these Properties is returned:*\nReturned if the definition could not be added. This could be because it is ill-formed, or if the definition is used in an other graph with a different signature.\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false). It is true in this response.\n**HTTP 403**\n*A json document with these Properties is returned:*\nReturned if your user has insufficient rights.\nIn order to modify a graph you at least need to have the following privileges:\n  1. `Administrate` access on the Database.\n\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false). It is true in this response.\n**HTTP 404**\n*A json document with these Properties is returned:*\nReturned if no graph with this name could be found.\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false). It is true in this response.\n\n",
        "operationId": "AddEdgedefinition",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/graph_edge_definition_add_http_examples"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the definition could be added successfully and waitForSync is enabled for the `_graphs` collection. The response body contains the graph configuration that has been stored.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_definition_add_http_examples_rc_201"
                }
              }
            },
            "x-description-offset": 553
          },
          "202": {
            "description": "Returned if the definition could be added successfully and waitForSync is disabled for the `_graphs` collection. The response body contains the graph configuration that has been stored.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_definition_add_http_examples_rc_202"
                }
              }
            },
            "x-description-offset": 620
          },
          "400": {
            "description": "Returned if the definition could not be added. This could be because it is ill-formed, or if the definition is used in an other graph with a different signature.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_definition_add_http_examples_rc_400"
                }
              }
            },
            "x-description-offset": 687
          },
          "403": {
            "description": "Returned if your user has insufficient rights.\nIn order to modify a graph you at least need to have the following privileges:\n\n  1. `Administrate` access on the Database.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_definition_add_http_examples_rc_403"
                }
              }
            },
            "x-description-offset": 754
          },
          "404": {
            "description": "Returned if no graph with this name could be found.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_definition_add_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 821
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/graph/{graph}/edge/{edgeCollection}": {
      "put": {
        "tags": [
          "Graphs"
        ],
        "summary": "Replace an edge definition",
        "description": "\n\nChange one specific edge definition.\nThis will modify all occurrences of this definition in all graphs known to your database.\n\nA JSON object with these properties is required:\n\n  - **to** (string): One or many vertex collections that can contain target vertices.\n  - **from** (string): One or many vertex collections that can contain source vertices.\n  - **collection**: The name of the edge collection to be used.\n\n**HTTP 201**\n*A json document with these Properties is returned:*\nReturned if the request was successful and waitForSync is true.\n\n - **graph**:\n   - **orphanCollections** (string): An array of additional vertex collections.\n   Documents within these collections do not have edges within this graph.\n  - **name**: The name of the graph.\n  - **_rev**: The revision of this graph. Can be used to make sure to not override concurrent modifications to this graph.\n  - **_id**: The internal id value of this graph. \n  - **edgedefinitions**: An array of definitions for the relations of the graph.\n   Each has the following type:\n    - **to** (string): List of vertex collection names. Edges in collection can only be inserted if their _to is in any of the collections here.\n    - **from** (string): List of vertex collection names. Edges in collection can only be inserted if their _from is in any of the collections here.\n    - **collection**: Name of the edge collection, where the edge are stored in.\n- **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n**HTTP 202**\n*A json document with these Properties is returned:*\nReturned if the request was successful but waitForSync is false.\n\n - **graph**:\n   - **orphanCollections** (string): An array of additional vertex collections.\n   Documents within these collections do not have edges within this graph.\n  - **name**: The name of the graph.\n  - **_rev**: The revision of this graph. Can be used to make sure to not override concurrent modifications to this graph.\n  - **_id**: The internal id value of this graph. \n  - **edgedefinitions**: An array of definitions for the relations of the graph.\n   Each has the following type:\n    - **to** (string): List of vertex collection names. Edges in collection can only be inserted if their _to is in any of the collections here.\n    - **from** (string): List of vertex collection names. Edges in collection can only be inserted if their _from is in any of the collections here.\n    - **collection**: Name of the edge collection, where the edge are stored in.\n- **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n**HTTP 400**\n*A json document with these Properties is returned:*\nReturned if no edge definition with this name is found in the graph, or of the new definition is ill-formed and cannot be used.\n- **errorMessage**: A message created for this error. \n- **errorNum**: database error number for the error that occurred. \n- **code**: The response code. \n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n**HTTP 403**\n*A json document with these Properties is returned:*\nReturned if your user has insufficient rights.\nIn order to drop a vertex you at least need to have the following privileges:\n  1. `Administrate` access on the Database.\n\n- **errorMessage**: A message created for this error. \n- **errorNum**: database error number for the error that occurred. \n- **code**: The response code. \n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n**HTTP 404**\n*A json document with these Properties is returned:*\n\nReturned if no graph with this name could be found.\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
        "operationId": "ReplaceAnEdgedefinition",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "edgeCollection",
            "in": "path",
            "description": "The name of the edge collection the edge belongs to.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dropCollections",
            "in": "query",
            "description": "Drop the collection as well.\nCollection will only be dropped if it is not used in other graphs.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/graph_edge_definition_modify_http_examples"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the request was successful and waitForSync is true.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_definition_modify_http_examples_rc_201"
                }
              }
            },
            "x-description-offset": 251
          },
          "202": {
            "description": "Returned if the request was successful but waitForSync is false.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_definition_modify_http_examples_rc_202"
                }
              }
            },
            "x-description-offset": 318
          },
          "400": {
            "description": "Returned if no edge definition with this name is found in the graph, or of the new definition is ill-formed and cannot be used.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_definition_modify_http_examples_rc_400"
                }
              }
            },
            "x-description-offset": 385
          },
          "403": {
            "description": "Returned if your user has insufficient rights.\nIn order to drop a vertex you at least need to have the following privileges:\n  1. `Administrate` access on the Database.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_definition_modify_http_examples_rc_403"
                }
              }
            },
            "x-description-offset": 452
          },
          "404": {
            "description": "Returned if no graph with this name could be found.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_definition_modify_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 519
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "post": {
        "tags": [
          "Graphs"
        ],
        "summary": "Create an edge",
        "description": "Creates a new edge in the collection.\nWithin the body the edge has to contain a *_from* and *_to* value referencing to valid vertices in the graph. Furthermore the edge has to be valid in the definition of the used edge collection.\nA JSON object with these properties is required:\n\n  - **_from**: The source vertex of this edge. Has to be valid within the used edge definition.\n  - **_to**: The target vertex of this edge. Has to be valid within the used edge definition.\n\n**HTTP 201**\n*A json document with these Properties is returned:*\nReturned if the edge could be created and waitForSync is true.\n- **edge**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **code**: The response code.\n- **new**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **error**: Flag if there was an error (true) or not (false). It is false in this response.\n**HTTP 202**\n*A json document with these Properties is returned:*\nReturned if the request was successful but waitForSync is false.\n- **edge**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **code**: The response code.\n- **new**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **error**: Flag if there was an error (true) or not (false). It is false in this response.\n**HTTP 400**\n*A json document with these Properties is returned:*\nReturned if the input document is invalid. This can for instance be the case if `_from` or `_to` is missing.\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false). It is true in this response.\n**HTTP 403**\n*A json document with these Properties is returned:*\nReturned if your user has insufficient rights.\nIn order to insert edges into the graph  you at least need to have the following privileges:\n  1. `Read Only` access on the Database.\n  2. `Write` access on the given collection.\n\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false). It is true in this response.\n**HTTP 404**\n*A json document with these Properties is returned:*\n\nReturned in any of the following cases:\n* no graph with this name could be found. * this edge collection is not part of the graph. * either `_from` or `_to` vertex does not exist.\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false). It is true in this response.\n\n",
        "operationId": "CreateAnEdge",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "edgeCollection",
            "in": "path",
            "description": "The name of the edge collection the edge belongs to.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "returnNew",
            "in": "query",
            "description": "Define if the response should contain the complete new version of the document.\n\n",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/graph_edge_create_http_examples"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the edge could be created and waitForSync is true.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_create_http_examples_rc_201"
                }
              }
            },
            "x-description-offset": 412
          },
          "202": {
            "description": "Returned if the request was successful but waitForSync is false.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_create_http_examples_rc_202"
                }
              }
            },
            "x-description-offset": 479
          },
          "400": {
            "description": "Returned if the input document is invalid. This can for instance be the case if `_from` or `_to` is missing.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_create_http_examples_rc_400"
                }
              }
            },
            "x-description-offset": 546
          },
          "403": {
            "description": "Returned if your user has insufficient rights.\nIn order to insert edges into the graph  you at least need to have the following privileges:\n\n  1. `Read Only` access on the Database.\n  2. `Write` access on the given collection.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_create_http_examples_rc_403"
                }
              }
            },
            "x-description-offset": 613
          },
          "404": {
            "description": "Returned in any of the following cases:\n* no graph with this name could be found.\n* this edge collection is not part of the graph.\n* either `_from` or `_to` vertex does not exist.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_create_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 680
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "Graphs"
        ],
        "summary": "Remove an edge definition from the graph",
        "description": "\nRemove one edge definition from the graph.  This will only remove the edge collection, the vertex collections remain untouched and can still be used in your queries.\n\n**HTTP 201**\n*A json document with these Properties is returned:*\nReturned if the edge definition could be removed from the graph and waitForSync is true.\n- **graph**:\n   - **orphanCollections** (string): An array of additional vertex collections.\n   Documents within these collections do not have edges within this graph.\n  - **name**: The name of the graph.\n  - **_rev**: The revision of this graph. Can be used to make sure to not override\n   concurrent modifications to this graph.\n  - **_id**: The internal id value of this graph. \n  - **edgedefinitions**: An array of definitions for the relations of the graph.\n   Each has the following type:\n    - **to** (string): List of vertex collection names. Edges in collection can only be inserted if their _to is in any of the collections here.\n    - **from** (string): List of vertex collection names. Edges in collection can only be inserted if their _from is in any of the collections here.\n    - **collection**: Name of the edge collection, where the edge are stored in.\n- **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n**HTTP 202**\n*A json document with these Properties is returned:*\nReturned if the edge definition could be removed from the graph and waitForSync is false.\n\n- **graph**:\n   - **orphanCollections** (string): An array of additional vertex collections.\n   Documents within these collections do not have edges within this graph.\n  - **name**: The name of the graph.\n  - **_rev**: The revision of this graph. Can be used to make sure to not override\n   concurrent modifications to this graph.\n  - **_id**: The internal id value of this graph. \n  - **edgedefinitions**: An array of definitions for the relations of the graph.\n   Each has the following type:\n    - **to** (string): List of vertex collection names. Edges in collection can only be inserted if their _to is in any of the collections here.\n    - **from** (string): List of vertex collection names. Edges in collection can only be inserted if their _from is in any of the collections here.\n    - **collection**: Name of the edge collection, where the edge are stored in.\n- **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n**HTTP 403**\n*A json document with these Properties is returned:*\nReturned if your user has insufficient rights.\nIn order to drop a vertex you at least need to have the following privileges:\n  1. `Administrate` access on the Database.\n\n- **errorMessage**: A message created for this error. \n- **errorNum**: database error number for the error that occurred. \n- **code**: The response code. \n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n**HTTP 404**\n*A json document with these Properties is returned:*\nReturned if no graph with this name could be found, or if no edge definition with this name is found in the graph.\n- **errorMessage**: A message created for this error. \n- **errorNum**: database error number for the error that occurred. \n- **code**: The response code. \n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n\n",
        "operationId": "RemoveAnEdgedefinitionFromTheGraph",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "edgeCollection",
            "in": "path",
            "description": "The name of the edge collection the edge belongs to.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dropCollections",
            "in": "query",
            "description": "Drop the collection as well. Collection will only be dropped if it is not used in other graphs.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Returned if the edge definition could be removed from the graph and waitForSync is true.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_definition_remove_http_examples_rc_201"
                }
              }
            },
            "x-description-offset": 236
          },
          "202": {
            "description": "Returned if the edge definition could be removed from the graph and waitForSync is false.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_definition_remove_http_examples_rc_202"
                }
              }
            },
            "x-description-offset": 303
          },
          "403": {
            "description": "Returned if your user has insufficient rights.\nIn order to drop a vertex you at least need to have the following privileges:\n  1. `Administrate` access on the Database.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_definition_remove_http_examples_rc_403"
                }
              }
            },
            "x-description-offset": 370
          },
          "404": {
            "description": "Returned if no graph with this name could be found, or if no edge definition with this name is found in the graph.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_definition_remove_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 437
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/graph/{graph}/edge/{collection}/{edge}": {
      "get": {
        "tags": [
          "Graphs"
        ],
        "summary": "Get an edge",
        "description": "\nGets an edge from the given collection.\n**HTTP 200**\n*A json document with these Properties is returned:*\nReturned if the edge could be found.\n- **edge**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **code**: The response code. - **error**: Flag if there was an error (true) or not (false). It is false in this response.\n**HTTP 304**\n*A json document with these Properties is returned:*\nReturned if the if-none-match header is given and the currently stored edge still has this revision value. So there was no update between the last time the edge was fetched by the caller.\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false). It is true in this response.\n\n**HTTP 403**\n*A json document with these Properties is returned:*\nReturned if your user has insufficient rights.\nIn order to update vertices in the graph  you at least need to have the following privileges:\n  1. `Read Only` access on the Database.\n  2. `Read Only` access on the given collection.\n\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false). It is true in this response.\n**HTTP 404**\n*A json document with these Properties is returned:*\nReturned in the following cases:\n* No graph with this name could be found. * This collection is not part of the graph. * The edge does not exist.\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false). It is true in this response.\n\n**HTTP 412**\n*A json document with these Properties is returned:*\nReturned if if-match header is given, but the stored documents revision is different.\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
        "operationId": "GetAnEdge",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the edge collection the edge belongs to.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "edge",
            "in": "path",
            "description": "The *_key* attribute of the edge.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "rev",
            "in": "query",
            "description": "Must contain a revision. If this is set a document is only returned if it has exactly this revision. Also see if-match header as an alternative to this.\n\n",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "if-match",
            "in": "header",
            "description": "If the \"If-Match\" header is given, then it must contain exactly one Etag. The document is returned, if it has the same revision as the given Etag. Otherwise a HTTP 412 is returned. As an alternative you can supply the Etag in an attribute rev in the URL.\n\n",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "if-none-match",
            "in": "header",
            "description": "If the \"If-None-Match\" header is given, then it must contain exactly one Etag. The document is returned, only if it has a different revision as the given Etag. Otherwise a HTTP 304 is returned. \n\n",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the edge could be found.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_get_http_examples_rc_200"
                }
              }
            },
            "x-description-offset": 110
          },
          "304": {
            "description": "Returned if the if-none-match header is given and the currently stored edge still has this revision value. So there was no update between the last time the edge was fetched by the caller.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_get_http_examples_rc_304"
                }
              }
            },
            "x-description-offset": 177
          },
          "403": {
            "description": "Returned if your user has insufficient rights.\nIn order to update vertices in the graph  you at least need to have the following privileges:\n\n  1. `Read Only` access on the Database.\n  2. `Read Only` access on the given collection.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_get_http_examples_rc_403"
                }
              }
            },
            "x-description-offset": 244
          },
          "404": {
            "description": "Returned in the following cases:\n* No graph with this name could be found.\n* This collection is not part of the graph.\n* The edge does not exist.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_get_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 311
          },
          "412": {
            "description": "Returned if if-match header is given, but the stored documents revision is different.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_get_http_examples_rc_412"
                }
              }
            },
            "x-description-offset": 378
          }
        }
      },
      "put": {
        "tags": [
          "Graphs"
        ],
        "summary": "Replace an edge",
        "description": "\nReplaces the data of an edge in the collection.\n\nA JSON object with these properties is required:\n\n  - **_from**: The source vertex of this edge. Has to be valid within the used edge definition.\n  - **_to**: The target vertex of this edge. Has to be valid within the used edge definition.\n\n**HTTP 201**\n*A json document with these Properties is returned:*\nReturned if the request was successful but waitForSync is true.\n- **edge**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **code**: The response code.\n- **old**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **new**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n**HTTP 202**\n*A json document with these Properties is returned:*\nReturned if the request was successful but waitForSync is false.\n- **edge**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **code**: The response code.\n- **old**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **new**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n**HTTP 403**\n*A json document with these Properties is returned:*\nReturned if your user has insufficient rights.\nIn order to replace edges in the graph  you at least need to have the following privileges:\n  1. `Read Only` access on the Database.\n  2. `Write` access on the given collection.\n\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n**HTTP 404**\n*A json document with these Properties is returned:*\n\nReturned in the following cases:\n* No graph with this name could be found. * This collection is not part of the graph. * The edge to replace does not exist. * either `_from` or `_to` vertex does not exist.\n\n- **errorMessage**: A message created for this error. \n- **errorNum**: database error number for the error that occurred. \n- **code**: The response code. \n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n**HTTP 412**\n*A json document with these Properties is returned:*\nReturned if if-match header is given, but the stored documents revision is different.\n- **errorMessage**: A message created for this error. \n- **errorNum**: database error number for the error that occurred. \n- **code**: The response code. \n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
        "operationId": "ReplaceAnEdge",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the edge collection the edge belongs to.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "edge",
            "in": "path",
            "description": "The *_key* attribute of the vertex.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "keepNull",
            "in": "query",
            "description": "Define if values set to null should be stored. By default the key is not removed from the document.\n\n",
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "returnOld",
            "in": "query",
            "description": "Define if a presentation of the deleted document should be returned within the response object.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "returnNew",
            "in": "query",
            "description": "Define if a presentation of the new document should be returned within the response object.\n\n",
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "if-match",
            "in": "header",
            "description": "If the \"If-Match\" header is given, then it must contain exactly one Etag. The document is updated, if it has the same revision as the given Etag. Otherwise a HTTP 412 is returned. As an alternative you can supply the Etag in an attribute rev in the URL.\n\n",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/graph_edge_replace_http_examples"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the request was successful but waitForSync is true.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_replace_http_examples_rc_201"
                }
              }
            },
            "x-description-offset": 172
          },
          "202": {
            "description": "Returned if the request was successful but waitForSync is false.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_replace_http_examples_rc_202"
                }
              }
            },
            "x-description-offset": 239
          },
          "403": {
            "description": "Returned if your user has insufficient rights.\nIn order to replace edges in the graph  you at least need to have the following privileges:\n\n  1. `Read Only` access on the Database.\n  2. `Write` access on the given collection.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_replace_http_examples_rc_403"
                }
              }
            },
            "x-description-offset": 306
          },
          "404": {
            "description": "Returned in the following cases:\n* No graph with this name could be found.\n* This collection is not part of the graph.\n* The edge to replace does not exist.\n* either `_from` or `_to` vertex does not exist.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_replace_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 373
          },
          "412": {
            "description": "Returned if if-match header is given, but the stored documents revision is different.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_replace_http_examples_rc_412"
                }
              }
            },
            "x-description-offset": 440
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "Graphs"
        ],
        "summary": "Remove an edge",
        "description": "\nRemoves an edge from the collection.\n**HTTP 200**\n*A json document with these Properties is returned:*\nReturned if the edge could be removed.\n- **removed**: Is set to true if the remove was successful. - **code**: The response code. - **old**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **error**: Flag if there was an error (true) or not (false). It is false in this response.\n**HTTP 202**\n*A json document with these Properties is returned:*\n\nReturned if the request was successful but waitForSync is false.\n- **removed**: Is set to true if the remove was successful. - **code**: The response code. - **old**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **error**: Flag if there was an error (true) or not (false). It is false in this response.\n\n\n**HTTP 403**\n*A json document with these Properties is returned:*\nReturned if your user has insufficient rights.\nIn order to delete vertices in the graph  you at least need to have the following privileges:\n  1. `Read Only` access on the Database.\n  2. `Write` access on the given collection.\n\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false). It is true in this response.\n**HTTP 404**\n*A json document with these Properties is returned:*\nReturned in the following cases:\n* No graph with this name could be found. * This collection is not part of the graph. * The edge to remove does not exist.\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false). It is true in this response.\n**HTTP 412**\n*A json document with these Properties is returned:*\nReturned if if-match header is given, but the stored documents revision is different.\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false). It is true in this response.\n\n\n",
        "operationId": "RemoveAnEdge",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the edge collection the edge belongs to.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "edge",
            "in": "path",
            "description": "The *_key* attribute of the edge.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "returnOld",
            "in": "query",
            "description": "Define if a presentation of the deleted document should be returned within the response object.\n\n",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "if-match",
            "in": "header",
            "description": "If the \"If-Match\" header is given, then it must contain exactly one Etag. The document is updated, if it has the same revision as the given Etag. Otherwise a HTTP 412 is returned. As an alternative you can supply the Etag in an attribute rev in the URL.\n\n",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the edge could be removed.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_delete_http_examples_rc_200"
                }
              }
            },
            "x-description-offset": 107
          },
          "202": {
            "description": "Returned if the request was successful but waitForSync is false.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_delete_http_examples_rc_202"
                }
              }
            },
            "x-description-offset": 174
          },
          "403": {
            "description": "Returned if your user has insufficient rights.\nIn order to delete vertices in the graph  you at least need to have the following privileges:\n\n  1. `Read Only` access on the Database.\n  2. `Write` access on the given collection.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_delete_http_examples_rc_403"
                }
              }
            },
            "x-description-offset": 241
          },
          "404": {
            "description": "Returned in the following cases:\n* No graph with this name could be found.\n* This collection is not part of the graph.\n* The edge to remove does not exist.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_delete_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 308
          },
          "412": {
            "description": "Returned if if-match header is given, but the stored documents revision is different.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_delete_http_examples_rc_412"
                }
              }
            },
            "x-description-offset": 375
          }
        }
      },
      "patch": {
        "tags": [
          "Graphs"
        ],
        "summary": "Modify an edge",
        "description": "\nUpdates the data of the specific edge in the collection.\n**HTTP 200**\n*A json document with these Properties is returned:*\nReturned if the edge could be updated, and waitForSync is false.\n- **edge**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **code**: The response code.\n- **old**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **new**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n**HTTP 202**\n*A json document with these Properties is returned:*\nReturned if the request was successful but waitForSync is false.\n- **edge**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **code**: The response code.\n- **old**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **new**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n  - **_from**: The _from value of the stored data.\n  - **_to**: The _to value of the stored data.\n- **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n**HTTP 403**\n*A json document with these Properties is returned:*\nReturned if your user has insufficient rights.\nIn order to update edges in the graph  you at least need to have the following privileges:\n  1. `Read Only` access on the Database.\n  2. `Write` access on the given collection.\n\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n**HTTP 404**\n*A json document with these Properties is returned:*\nReturned in the following cases:\n* No graph with this name could be found. * This collection is not part of the graph. * The edge to update does not exist. * either `_from` or `_to` vertex does not exist (if updated).\n- **errorMessage**: A message created for this error.\n- **errorNum**: database error number for the error that occurred.\n- **code**: The response code.\n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n**HTTP 412**\n*A json document with these Properties is returned:*\nReturned if if-match header is given, but the stored documents revision is different.\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
        "operationId": "ModifyAnEdge",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the edge collection the edge belongs to.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "edge",
            "in": "path",
            "description": "The *_key* attribute of the vertex.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "keepNull",
            "in": "query",
            "description": "Define if values set to null should be stored. By default (true) the given documents attribute(s) will be set to null. If this parameter is false the attribute(s) will instead be deleted from the document.\n\n",
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "returnOld",
            "in": "query",
            "description": "Define if a presentation of the deleted document should be returned within the response object.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "returnNew",
            "in": "query",
            "description": "Define if a presentation of the new document should be returned within the response object.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "if-match",
            "in": "header",
            "description": "If the \"If-Match\" header is given, then it must contain exactly one Etag. The document is updated, if it has the same revision as the given Etag. Otherwise a HTTP 412 is returned. As an alternative you can supply the Etag in an attribute rev in the URL.\n\n",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "The body has to contain a JSON object containing exactly the attributes that should be overwritten, all other attributes remain unchanged.\n\n",
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the edge could be updated, and waitForSync is false.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_modify_http_examples_rc_200"
                }
              }
            },
            "x-description-offset": 127
          },
          "202": {
            "description": "Returned if the request was successful but waitForSync is false.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_modify_http_examples_rc_202"
                }
              }
            },
            "x-description-offset": 194
          },
          "403": {
            "description": "Returned if your user has insufficient rights.\nIn order to update edges in the graph  you at least need to have the following privileges:\n\n  1. `Read Only` access on the Database.\n  2. `Write` access on the given collection.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_modify_http_examples_rc_403"
                }
              }
            },
            "x-description-offset": 261
          },
          "404": {
            "description": "Returned in the following cases:\n* No graph with this name could be found.\n* This collection is not part of the graph.\n* The edge to update does not exist.\n* either `_from` or `_to` vertex does not exist (if updated).\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_modify_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 328
          },
          "412": {
            "description": "Returned if if-match header is given, but the stored documents revision is different.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_edge_modify_http_examples_rc_412"
                }
              }
            },
            "x-description-offset": 395
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/graph/{graph}/vertex": {
      "get": {
        "tags": [
          "Graphs"
        ],
        "summary": "List vertex collections",
        "description": "\nLists all vertex collections within this graph.\n**HTTP 200**\n*A json document with these Properties is returned:*\nReturned if the collections could be listed.\n- **code**: The response code. - **collections** (string): The list of all vertex collections within this graph. Includes collections in edgedefinitions as well as orphans. - **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n**HTTP 404**\n*A json document with these Properties is returned:*\nReturned if no graph with this name could be found.\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
        "operationId": "ListVertexCollections",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the collections could be listed.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_list_vertex_http_examples_rc_200"
                }
              }
            },
            "x-description-offset": 118
          },
          "404": {
            "description": "Returned if no graph with this name could be found.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_list_vertex_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 185
          }
        }
      },
      "post": {
        "tags": [
          "Graphs"
        ],
        "summary": "Add vertex collection",
        "description": "Adds a vertex collection to the set of orphan collections of the graph. If the collection does not exist, it will be created.\n**HTTP 201**\n*A json document with these Properties is returned:*\nReturned if the collection could be created and waitForSync is enabled for the `_graphs` collection, or given in the request. The response body contains the graph configuration that has been stored.\n- **graph**:\n  - **orphanCollections** (string): An array of additional vertex collections.\n   Documents within these collections do not have edges within this graph.\n  - **name**: The name of the graph.\n  - **_rev**: The revision of this graph. Can be used to make sure to not override concurrent modifications to this graph.\n  - **_id**: The internal id value of this graph. \n  - **edgedefinitions**: An array of definitions for the relations of the graph.\n   Each has the following type:\n    - **to** (string): List of vertex collection names. Edges in collection can only be inserted if their _to is in any of the collections here.\n    - **from** (string): List of vertex collection names. Edges in collection can only be inserted if their _from is in any of the collections here.\n    - **collection**: Name of the edge collection, where the edge are stored in.\n- **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\n\nIt is false in this response.\n\n**HTTP 202**\n*A json document with these Properties is returned:*\n\nReturned if the collection could be created and waitForSync is disabled for the `_graphs` collection, or given in the request. The response body contains the graph configuration that has been stored.\n\n\n  - **graph**:\n    - **orphanCollections** (string): An array of additional vertex collections.\n    Documents within these collections do not have edges within this graph.\n  - **name**: The name of the graph.\n  - **_rev**: The revision of this graph. Can be used to make sure to not override concurrent modifications to this graph.\n  - **_id**: The internal id value of this graph. \n  - **edgedefinitions**: An array of definitions for the relations of the graph.\n   Each has the following type:\n    - **to** (string): List of vertex collection names. Edges in collection can only be inserted if their _to is in any of the collections here.\n    - **from** (string): List of vertex collection names. Edges in collection can only be inserted if their _from is in any of the collections here.\n    - **collection**: Name of the edge collection, where the edge are stored in.\n- **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n**HTTP 400**\n*A json document with these Properties is returned:*\nReturned if the request is in an invalid format.\n- **errorMessage**: A message created for this error. \n- **errorNum**: database error number for the error that occurred. \n- **code**: The response code. \n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n**HTTP 403**\n*A json document with these Properties is returned:*\nReturned if your user has insufficient rights.\nIn order to modify a graph you at least need to have the following privileges:\n  1. `Administrate` access on the Database.\n  2. `Read Only` access on every collection used within this graph.\n\n- **errorMessage**: A message created for this error. \n- **errorNum**: database error number for the error that occurred. \n- **code**: The response code. \n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n**HTTP 404**\n*A json document with these Properties is returned:*\nReturned if no graph with this name could be found.\n- **errorMessage**: A message created for this error. \n- **errorNum**: database error number for the error that occurred. \n- **code**: The response code. \n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
        "operationId": "AddVertexCollection",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Returned if the collection could be created and waitForSync is enabled for the `_graphs` collection, or given in the request. The response body contains the graph configuration that has been stored.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_collection_add_http_examples_rc_201"
                }
              }
            },
            "x-description-offset": 196
          },
          "202": {
            "description": "Returned if the collection could be created and waitForSync is disabled for the `_graphs` collection, or given in the request. The response body contains the graph configuration that has been stored.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_collection_add_http_examples_rc_202"
                }
              }
            },
            "x-description-offset": 263
          },
          "400": {
            "description": "Returned if the request is in an invalid format.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_collection_add_http_examples_rc_400"
                }
              }
            },
            "x-description-offset": 330
          },
          "403": {
            "description": "Returned if your user has insufficient rights.\nIn order to modify a graph you at least need to have the following privileges:\n\n  1. `Administrate` access on the Database.\n  2. `Read Only` access on every collection used within this graph.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_collection_add_http_examples_rc_403"
                }
              }
            },
            "x-description-offset": 397
          },
          "404": {
            "description": "Returned if no graph with this name could be found.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_collection_add_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 464
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/graph/{graph}/vertex/{collection}": {
      "post": {
        "tags": [
          "Graphs"
        ],
        "summary": "Create a vertex",
        "description": "\n\nAdds a vertex to the given collection.\n**HTTP 201**\n*A json document with these Properties is returned:*\nReturned if the vertex could be added and waitForSync is true.\n- **new**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **code**: The response code.\n- **vertex**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n\n**HTTP 202**\n*A json document with these Properties is returned:*\nReturned if the request was successful but waitForSync is false.\n- **new**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **code**: The response code.\n- **vertex**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n**HTTP 403**\n*A json document with these Properties is returned:*\nReturned if your user has insufficient rights.\nIn order to insert vertices into the graph  you at least need to have the following privileges:\n  1. `Read Only` access on the Database.\n  2. `Write` access on the given collection.\n\n- **errorMessage**: A message created for this error.\n- **errorNum**: database error number for the error that occurred.\n- **code**: The response code.\n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n**HTTP 404**\n*A json document with these Properties is returned:*\n\nReturned if no graph with this name could be found. Or if a graph is found but this collection is not part of the graph.\n- **errorMessage**: A message created for this error.\n- **errorNum**: database error number for the error that occurred.\n- **code**: The response code.\n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n\n",
        "operationId": "CreateAVertex",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the vertex collection the vertex should be inserted into.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "returnNew",
            "in": "query",
            "description": "Define if the response should contain the complete new version of the document.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "requestBody": {
          "description": "The body has to be the JSON object to be stored.\n\n",
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the vertex could be added and waitForSync is true.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_create_http_examples_rc_201"
                }
              }
            },
            "x-description-offset": 109
          },
          "202": {
            "description": "Returned if the request was successful but waitForSync is false.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_create_http_examples_rc_202"
                }
              }
            },
            "x-description-offset": 176
          },
          "403": {
            "description": "Returned if your user has insufficient rights.\nIn order to insert vertices into the graph  you at least need to have the following privileges:\n\n  1. `Read Only` access on the Database.\n  2. `Write` access on the given collection.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_create_http_examples_rc_403"
                }
              }
            },
            "x-description-offset": 243
          },
          "404": {
            "description": "Returned if no graph with this name could be found. Or if a graph is found but this collection is not part of the graph.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_create_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 310
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "Graphs"
        ],
        "summary": "Remove vertex collection",
        "description": "\nRemoves a vertex collection from the graph and optionally deletes the collection, if it is not used in any other graph. It can only remove vertex collections that are no longer part of edge definitions, if they are used in edge definitions you are required to modify those first.\n\n**HTTP 200**\n*A json document with these Properties is returned:*\nReturned if the vertex collection was removed from the graph successfully and waitForSync is true.\n- **graph**:\n  - **orphanCollections** (string): An array of additional vertex collections. Documents within these collections do not have edges within this graph.\n  - **name**: The name of the graph.\n  - **_rev**: The revision of this graph. Can be used to make sure to not override concurrent modifications to this graph.\n  - **_id**: The internal id value of this graph. \n  - **edgedefinitions**: An array of definitions for the relations of the graph.\n   Each has the following type:\n    - **to** (string): List of vertex collection names. Edges in collection can only be inserted if their _to is in any of the collections here.\n    - **from** (string): List of vertex collection names. Edges in collection can only be inserted if their _from is in any of the collections here.\n    - **collection**: Name of the edge collection, where the edge are stored in.\n- **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n**HTTP 202**\n*A json document with these Properties is returned:*\nReturned if the request was successful but waitForSync is false.\n- **graph**:\n  - **orphanCollections** (string): An array of additional vertex collections. Documents within these collections do not have edges within this graph.\n  - **name**: The name of the graph.\n  - **_rev**: The revision of this graph. Can be used to make sure to not override concurrent modifications to this graph.\n  - **_id**: The internal id value of this graph. \n  - **edgedefinitions**: An array of definitions for the relations of the graph.\n   Each has the following type:\n    - **to** (string): List of vertex collection names. Edges in collection can only be inserted if their _to is in any of the collections here.\n    - **from** (string): List of vertex collection names. Edges in collection can only be inserted if their _from is in any of the collections here.\n    - **collection**: Name of the edge collection, where the edge are stored in.\n- **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n**HTTP 400**\n*A json document with these Properties is returned:*\n\nReturned if the vertex collection is still used in an edge definition. In this case it cannot be removed from the graph yet, it has to be removed from the edge definition first.\n\n- **errorMessage**: A message created for this error. \n- **errorNum**: database error number for the error that occurred. \n- **code**: The response code. \n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n**HTTP 403**\n*A json document with these Properties is returned:*\nReturned if your user has insufficient rights.\nIn order to drop a vertex you at least need to have the following privileges:\n  1. `Administrate` access on the Database.\n\n- **errorMessage**: A message created for this error. \n- **errorNum**: database error number for the error that occurred. \n- **code**: The response code. \n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n\n**HTTP 404**\n*A json document with these Properties is returned:*\n\nReturned if no graph with this name could be found.\n\n- **errorMessage**: A message created for this error. \n- **errorNum**: database error number for the error that occurred. \n- **code**: The response code. \n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n\n",
        "operationId": "RemoveVertexCollection",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the vertex collection.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dropCollection",
            "in": "query",
            "description": "Drop the collection as well.\nCollection will only be dropped if it is not used in other graphs.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the vertex collection was removed from the graph successfully and waitForSync is true.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_collection_remove_http_examples_rc_200"
                }
              }
            },
            "x-description-offset": 350
          },
          "202": {
            "description": "Returned if the request was successful but waitForSync is false.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_collection_remove_http_examples_rc_202"
                }
              }
            },
            "x-description-offset": 417
          },
          "400": {
            "description": "Returned if the vertex collection is still used in an edge definition. In this case it cannot be removed from the graph yet, it has to be removed from the edge definition first.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_collection_remove_http_examples_rc_400"
                }
              }
            },
            "x-description-offset": 484
          },
          "403": {
            "description": "Returned if your user has insufficient rights.\nIn order to drop a vertex you at least need to have the following privileges:\n  1. `Administrate` access on the Database.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_collection_remove_http_examples_rc_403"
                }
              }
            },
            "x-description-offset": 551
          },
          "404": {
            "description": "Returned if no graph with this name could be found.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_collection_remove_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 618
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/graph/{graph}/vertex/{collection}/{vertex}": {
      "get": {
        "tags": [
          "Graphs"
        ],
        "summary": "Get a vertex",
        "description": "\nGets a vertex from the given collection.\n\n**HTTP 200**\n*A json document with these Properties is returned:*\nReturned if the vertex could be found.\n- **code**: The response code.\n- **vertex**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n**HTTP 304**\n*A json document with these Properties is returned:*\nReturned if the if-none-match header is given and the currently stored vertex still has this revision value. So there was no update between the last time the vertex was fetched by the caller.\n- **errorMessage**: A message created for this error. \n- **errorNum**: database error number for the error that occurred. \n- **code**: The response code. \n- **error**: Flag if there was an error (true) or not (false).\n\nIt is true in this response.\n\n**HTTP 403**\n*A json document with these Properties is returned:*\nReturned if your user has insufficient rights.\nIn order to update vertices in the graph  you at least need to have the following privileges:\n  1. `Read Only` access on the Database.\n  2. `Read Only` access on the given collection.\n\n- **errorMessage**: A message created for this error. \n- **errorNum**: database error number for the error that occurred.\n- **code**: The response code. \n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n**HTTP 404**\n*A json document with these Properties is returned:*\nReturned in the following cases:\n* No graph with this name could be found. * This collection is not part of the graph. * The vertex does not exist.\n- **errorMessage**: A message created for this error. \n- **errorNum**: database error number for the error that occurred. \n- **code**: The response code. \n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n**HTTP 412**\n*A json document with these Properties is returned:*\nReturned if if-match header is given, but the stored documents revision is different.\n- **errorMessage**: A message created for this error.\n- **errorNum**: database error number for the error that occurred.\n- **code**: The response code.\n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
        "operationId": "GetAVertex",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the vertex collection the vertex belongs to.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "vertex",
            "in": "path",
            "description": "The *_key* attribute of the vertex.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "rev",
            "in": "query",
            "description": "Must contain a revision. If this is set a document is only returned if it has exactly this revision. Also see if-match header as an alternative to this.\n\n",
            "schema": {
              "type": "string",
              "default": "false"
            }
          },
          {
            "name": "if-match",
            "in": "header",
            "description": "If the \"If-Match\" header is given, then it must contain exactly one Etag. The document is returned, if it has the same revision as the given Etag. Otherwise a HTTP 412 is returned. As an alternative you can supply the Etag in an query parameter *rev*.\n\n",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "if-none-match",
            "in": "header",
            "description": "If the \"If-None-Match\" header is given, then it must contain exactly one Etag. The document is returned, only if it has a different revision as the given Etag. Otherwise a HTTP 304 is returned. \n\n",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the vertex could be found.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_get_http_examples_rc_200"
                }
              }
            },
            "x-description-offset": 111
          },
          "304": {
            "description": "Returned if the if-none-match header is given and the currently stored vertex still has this revision value. So there was no update between the last time the vertex was fetched by the caller.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_get_http_examples_rc_304"
                }
              }
            },
            "x-description-offset": 178
          },
          "403": {
            "description": "Returned if your user has insufficient rights.\nIn order to update vertices in the graph  you at least need to have the following privileges:\n\n  1. `Read Only` access on the Database.\n  2. `Read Only` access on the given collection.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_get_http_examples_rc_403"
                }
              }
            },
            "x-description-offset": 245
          },
          "404": {
            "description": "Returned in the following cases:\n* No graph with this name could be found.\n* This collection is not part of the graph.\n* The vertex does not exist.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_get_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 312
          },
          "412": {
            "description": "Returned if if-match header is given, but the stored documents revision is different.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_get_http_examples_rc_412"
                }
              }
            },
            "x-description-offset": 379
          }
        }
      },
      "put": {
        "tags": [
          "Graphs"
        ],
        "summary": "Replace a vertex",
        "description": "\n\nReplaces the data of a vertex in the collection.\n\n\n**HTTP 200**\n*A json document with these Properties is returned:*\n\nReturned if the vertex could be replaced, and waitForSync is true.\n\n- **new**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **old**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **code**: The response code.\n- **vertex**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n\n**HTTP 202**\n*A json document with these Properties is returned:*\n\nReturned if the vertex could be replaced, and waitForSync is false.\n\n- **new**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **old**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **code**: The response code.\n- **vertex**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n\n**HTTP 403**\n*A json document with these Properties is returned:*\n\nReturned if your user has insufficient rights.\nIn order to replace vertices in the graph  you at least need to have the following privileges:\n  1. `Read Only` access on the Database.\n  2. `Write` access on the given collection.\n\n- **errorMessage**: A message created for this error.\n- **errorNum**: database error number for the error that occurred.\n- **code**: The response code.\n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n\n**HTTP 404**\n*A json document with these Properties is returned:*\n\nReturned in the following cases:\n* No graph with this name could be found.\n* This collection is not part of the graph.\n* The vertex to replace does not exist.\n\n- **errorMessage**: A message created for this error.\n- **errorNum**: database error number for the error that occurred.\n- **code**: The response code.\n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n\n**HTTP 412**\n*A json document with these Properties is returned:*\n\nReturned if if-match header is given, but the stored documents revision is different.\n\n- **errorMessage**: A message created for this error.\n- **errorNum**: database error number for the error that occurred.\n- **code**: The response code.\n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n\n",
        "operationId": "ReplaceAVertex",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the vertex collection the vertex belongs to.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "vertex",
            "in": "path",
            "description": "The *_key* attribute of the vertex.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "keepNull",
            "in": "query",
            "description": "Define if values set to null should be stored. By default the key is not removed from the document.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "returnOld",
            "in": "query",
            "description": "Define if a presentation of the deleted document should\nbe returned within the response object.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "returnNew",
            "in": "query",
            "description": "Define if a presentation of the new document should\nbe returned within the response object.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "if-match",
            "in": "header",
            "description": "If the \"If-Match\" header is given, then it must contain exactly one Etag. The document is updated,\nif it has the same revision as the given Etag. Otherwise a HTTP 412 is returned. As an alternative\nyou can supply the Etag in an attribute rev in the URL.\n\n",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "The body has to be the JSON object to be stored.\n\n",
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the vertex could be replaced, and waitForSync is true.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_replace_http_examples_rc_200"
                }
              }
            },
            "x-description-offset": 119
          },
          "202": {
            "description": "Returned if the vertex could be replaced, and waitForSync is false.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_replace_http_examples_rc_202"
                }
              }
            },
            "x-description-offset": 186
          },
          "403": {
            "description": "Returned if your user has insufficient rights.\nIn order to replace vertices in the graph  you at least need to have the following privileges:\n\n  1. `Read Only` access on the Database.\n  2. `Write` access on the given collection.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_replace_http_examples_rc_403"
                }
              }
            },
            "x-description-offset": 253
          },
          "404": {
            "description": "Returned in the following cases:\n* No graph with this name could be found.\n* This collection is not part of the graph.\n* The vertex to replace does not exist.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_replace_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 320
          },
          "412": {
            "description": "Returned if if-match header is given, but the stored documents revision is different.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_replace_http_examples_rc_412"
                }
              }
            },
            "x-description-offset": 387
          }
        },
        "x-hints": "",
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "Graphs"
        ],
        "summary": "Remove a vertex",
        "description": "\nRemoves a vertex from the collection.\n\n**HTTP 200**\n*A json document with these Properties is returned:*\n\nReturned if the vertex could be removed.\n- **removed**: Is set to true if the remove was successful. \n- **code**: The response code. - **old**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n**HTTP 202**\n*A json document with these Properties is returned:*\nReturned if the request was successful but waitForSync is false.\n- **removed**: Is set to true if the remove was successful. \n- **code**: The response code. - **old**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n**HTTP 403**\n*A json document with these Properties is returned:*\nReturned if your user has insufficient rights.\nIn order to delete vertices in the graph  you at least need to have the following privileges:\n  1. `Read Only` access on the Database.\n  2. `Write` access on the given collection.\n\n- **errorMessage**: A message created for this error. \n- **errorNum**: database error number for the error that occurred. \n- **code**: The response code. \n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n**HTTP 404**\n*A json document with these Properties is returned:*\n\nReturned in the following cases:\n* No graph with this name could be found. * This collection is not part of the graph. * The vertex to remove does not exist.\n\n- **errorMessage**: A message created for this error. \n- **errorNum**: database error number for the error that occurred. \n- **code**: The response code. \n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n**HTTP 412**\n*A json document with these Properties is returned:*\nReturned if if-match header is given, but the stored documents revision is different.\n- **errorMessage**: A message created for this error. - **errorNum**: database error number for the error that occurred. - **code**: The response code. - **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n\n",
        "operationId": "RemoveAVertex",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the vertex collection the vertex belongs to.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "vertex",
            "in": "path",
            "description": "The *_key* attribute of the vertex.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "returnOld",
            "in": "query",
            "description": "Define if a presentation of the deleted document should be returned within the response object.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "if-match",
            "in": "header",
            "description": "If the \"If-Match\" header is given, then it must contain exactly one Etag. The document is updated, if it has the same revision as the given Etag. Otherwise a HTTP 412 is returned. As an alternative you can supply the Etag in an attribute rev in the URL.\n\n",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the vertex could be removed.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_delete_http_examples_rc_200"
                }
              }
            },
            "x-description-offset": 108
          },
          "202": {
            "description": "Returned if the request was successful but waitForSync is false.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_delete_http_examples_rc_202"
                }
              }
            },
            "x-description-offset": 175
          },
          "403": {
            "description": "Returned if your user has insufficient rights.\nIn order to delete vertices in the graph  you at least need to have the following privileges:\n\n  1. `Read Only` access on the Database.\n  2. `Write` access on the given collection.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_delete_http_examples_rc_403"
                }
              }
            },
            "x-description-offset": 242
          },
          "404": {
            "description": "Returned in the following cases:\n* No graph with this name could be found.\n* This collection is not part of the graph.\n* The vertex to remove does not exist.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_delete_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 309
          },
          "412": {
            "description": "Returned if if-match header is given, but the stored documents revision is different.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_delete_http_examples_rc_412"
                }
              }
            },
            "x-description-offset": 376
          }
        }
      },
      "patch": {
        "tags": [
          "Graphs"
        ],
        "summary": "Update a vertex",
        "description": "\nUpdates the data of the specific vertex in the collection.\n\n**HTTP 200**\n*A json document with these Properties is returned:*\nReturned if the vertex could be updated, and waitForSync is true.\n- **new**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **old**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **code**: The response code.\n- **vertex**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n**HTTP 202**\n*A json document with these Properties is returned:*\nReturned if the request was successful, and waitForSync is false.\n- **new**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **old**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **code**: The response code.\n- **vertex**:\n  - **_key**: The _key value of the stored data.\n  - **_rev**: The _rev value of the stored data.\n  - **_id**: The _id value of the stored data.\n- **error**: Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n**HTTP 403**\n*A json document with these Properties is returned:*\n\nReturned if your user has insufficient rights.\nIn order to update vertices in the graph  you at least need to have the following privileges:\n  1. `Read Only` access on the Database.\n  2. `Write` access on the given collection.\n\n- **errorMessage**: A message created for this error.\n- **errorNum**: database error number for the error that occurred.\n- **code**: The response code.\n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n\n**HTTP 404**\n*A json document with these Properties is returned:*\n\nReturned in the following cases:\n* No graph with this name could be found.\n* This collection is not part of the graph.\n* The vertex to update does not exist.\n\n- **errorMessage**: A message created for this error.\n- **errorNum**: database error number for the error that occurred.\n- **code**: The response code.\n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n\n**HTTP 412**\n*A json document with these Properties is returned:*\n\nReturned if if-match header is given, but the stored documents revision is different.\n\n- **errorMessage**: A message created for this error.\n- **errorNum**: database error number for the error that occurred.\n- **code**: The response code.\n- **error**: Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
        "operationId": "UpdateAVertex",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "graph",
            "in": "path",
            "description": "The name of the graph.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the vertex collection the vertex belongs to.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "vertex",
            "in": "path",
            "description": "The *_key* attribute of the vertex.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "keepNull",
            "in": "query",
            "description": "Define if values set to null should be stored.\nBy default (true) the given documents attribute(s) will be set to null.\nIf this parameter is false the attribute(s) will instead be delete from the document.\n\n",
            "schema": {
              "type": "boolean",
              "default": true
            }
          },
          {
            "name": "returnOld",
            "in": "query",
            "description": "Define if a presentation of the deleted document should\nbe returned within the response object.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "returnNew",
            "in": "query",
            "description": "Define if a presentation of the new document should\nbe returned within the response object.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "if-match",
            "in": "header",
            "description": "If the \"If-Match\" header is given, then it must contain exactly one Etag. The document is updated,\nif it has the same revision as the given Etag. Otherwise a HTTP 412 is returned. As an alternative\nyou can supply the Etag in an attribute rev in the URL.\n\n",
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "The body has to contain a JSON object containing exactly the attributes that should be overwritten, all other attributes remain unchanged.\n\n",
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the vertex could be updated, and waitForSync is true.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_modify_http_examples_rc_200"
                }
              }
            },
            "x-description-offset": 129
          },
          "202": {
            "description": "Returned if the request was successful, and waitForSync is false.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_modify_http_examples_rc_202"
                }
              }
            },
            "x-description-offset": 196
          },
          "403": {
            "description": "Returned if your user has insufficient rights.\nIn order to update vertices in the graph  you at least need to have the following privileges:\n\n  1. `Read Only` access on the Database.\n  2. `Write` access on the given collection.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_modify_http_examples_rc_403"
                }
              }
            },
            "x-description-offset": 263
          },
          "404": {
            "description": "Returned in the following cases:\n* No graph with this name could be found.\n* This collection is not part of the graph.\n* The vertex to update does not exist.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_modify_http_examples_rc_404"
                }
              }
            },
            "x-description-offset": 330
          },
          "412": {
            "description": "Returned if if-match header is given, but the stored documents revision is different.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/graph_vertex_modify_http_examples_rc_412"
                }
              }
            },
            "x-description-offset": 397
          }
        },
        "x-hints": "",
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/edges/{collection-id}": {
      "get": {
        "tags": [
          "Graphs"
        ],
        "summary": "Read in- or outbound edges",
        "description": "Returns an array of edges starting or ending in the vertex identified by *vertex-handle*.\n\n",
        "operationId": "ReadIn-OrOutboundEdges",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection-id",
            "in": "path",
            "description": "The id of the collection.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "vertex",
            "in": "query",
            "description": "The id of the start vertex.\n\n",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "direction",
            "in": "query",
            "description": "Selects *in* or *out* direction for edges. If not set, any edges are returned.\n\n",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the edge collection was found and edges were retrieved.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request contains invalid parameters.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the edge collection was not found.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/graphs/traversal": {
      "post": {
        "tags": [
          "Graphs"
        ],
        "summary": "executes a traversal",
        "description": "\nStarts a traversal starting from a given vertex and following. edges contained in a given edgeCollection. The request must contain the following attributes.\n\nA JSON object with these properties is required:\n\n  - **sort**: body (JavaScript) code of a custom comparison function for the edges. The signature of this function is *(l, r) -> integer* (where l and r are edges) and must return -1 if l is smaller than, +1 if l is greater than, and 0 if l and r are equal. The reason for this is the following: The order of edges returned for a certain vertex is undefined. This is because there is no natural order of edges for a vertex with multiple connected edges. To explicitly define the order in which edges on the vertex are followed, you can specify an edge comparator function with this attribute. Note that the value here has to be a string to conform to the JSON standard, which in turn is parsed as function body on the server side. Furthermore note that this attribute is only used for the standard expanders. If you use your custom expander you have to do the sorting yourself within the expander code.\n  - **direction**: direction for traversal\n   - *if set*, must be either *\"outbound\"*, *\"inbound\"*, or *\"any\"*\n   - *if not set*, the *expander* attribute must be specified\n  - **minDepth**: ANDed with any existing filters): visits only nodes in at least the given depth\n  - **startVertex**: id of the startVertex, e.g. *\"users/foo\"*.\n  - **visitor**: body (JavaScript) code of custom visitor function function signature: *(config, result, vertex, path, connected) -> void* The visitor function can do anything, but its return value is ignored. To populate a result, use the *result* variable by reference. Note that the *connected* argument is only populated when the *order* attribute is set to *\"preorder-expander\"*.\n  - **itemOrder**: item iteration order can be *\"forward\"* or *\"backward\"*\n  - **strategy**: traversal strategy can be *\"depthfirst\"* or *\"breadthfirst\"*\n  - **filter**: default is to include all nodes: body (JavaScript code) of custom filter function function signature: *(config, vertex, path) -> mixed* can return four different string values:\n   - *\"exclude\"* -> this vertex will not be visited.\n   - *\"prune\"* -> the edges of this vertex will not be followed.\n   - *\"\"* or *undefined* -> visit the vertex and follow its edges.\n   - *Array* -> containing any combination of the above. If there is at least one *\"exclude\"* or *\"prune\"* respectively is contained, it's effect will occur.\n  - **init**: body (JavaScript) code of custom result initialization function function signature: *(config, result) -> void* initialize any values in result with what is required\n  - **maxIterations**: Maximum number of iterations in each traversal. This number can be set to prevent endless loops in traversal of cyclic graphs. When a traversal performs as many iterations as the *maxIterations* value, the traversal will abort with an error. If *maxIterations* is not set, a server-defined value may be used.\n  - **maxDepth**: ANDed with any existing filters visits only nodes in at most the given depth\n  - **uniqueness**: specifies uniqueness for vertices and edges visited.\n   If set, must be an object like this:\n   `\"uniqueness\": {\"vertices\": \"none\"|\"global\"|\"path\", \"edges\": \"none\"|\"global\"|\"path\"}`\n  - **order**: traversal order can be *\"preorder\"*, *\"postorder\"* or *\"preorder-expander\"*\n  - **graphName**: name of the graph that contains the edges. Either *edgeCollection* or *graphName* has to be given. In case both values are set the *graphName* is preferred.\n  - **expander**: body (JavaScript) code of custom expander function *must* be set if *direction* attribute is **not** set function signature: *(config, vertex, path) -> array* expander must return an array of the connections for *vertex* each connection is an object with the attributes *edge* and *vertex*\n  - **edgeCollection**: name of the collection that contains the edges.\n\nIf the Traversal is successfully executed *HTTP 200* will be returned.\n\nAdditionally the *result* object will be returned by the traversal.\n\nFor successful traversals, the returned JSON object has the following properties:\n- *error*: boolean flag to indicate if an error occurred (*false* in this case)\n- *code*: the HTTP status code\n- *result*: the return value of the traversal\nIf the traversal specification is either missing or malformed, the server will respond with *HTTP 400*.\n\nThe body of the response will then contain a JSON object with additional error details. The object has the following attributes:\n\n- *error*: boolean flag to indicate that an error occurred (*true* in this case)\n- *code*: the HTTP status code\n- *errorNum*: the server error number\n- *errorMessage*: a descriptive error message\n\n",
        "operationId": "executesATraversal",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/graph_traversal"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the traversal is fully executed\n*HTTP 200* will be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the traversal specification is either missing or malformed, the server will respond with *HTTP 400*.\n\n",
            "content": {}
          },
          "404": {
            "description": "The server will responded with *HTTP 404* if the specified edge collection does not exist, or the specified start vertex cannot be found.\n\n",
            "content": {}
          },
          "500": {
            "description": "The server will responded with *HTTP 500* when an error occurs inside the traversal or if a traversal performs more than *maxIterations* iterations.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/streams": {
      "get": {
        "tags": [
          "Streams"
        ],
        "summary": "Get list of streams",
        "description": "Get list of all streams.\n\n",
        "operationId": "ListOfStreams",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name of the streams.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "global",
            "in": "query",
            "description": "Is geo replicated stream?\n",
            "schema": {
              "type": "boolean",
              "format": "string",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n",
            "content": {}
          },
          "502": {
            "description": "Returned if an error related to Streams communication was encountered.\n\n",
            "content": {}
          }
        },
        "x-filename": "database/Documentation/DocuBlocks/Rest/Streams/README.md",
        "x-hints": ""
      }
    },
    "/_fabric/{fabric}/_api/streams/{stream}": {
      "post": {
        "tags": [
          "Streams"
        ],
        "summary": "Create stream",
        "description": "Create stream.\n\n",
        "operationId": "CreateStream",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name of the streams.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "stream",
            "in": "path",
            "description": "Name of the stream.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "global",
            "in": "query",
            "description": "Is geo replicated stream?\n",
            "schema": {
              "type": "boolean",
              "format": "string",
              "default": false
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Accepted.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n",
            "content": {}
          },
          "502": {
            "description": "Returned if an error related to C8Streams communication was encountered.\n\n",
            "content": {}
          }
        }
      },
      "delete": {
        "tags": [
          "Streams"
        ],
        "summary": "Delete stream",
        "description": " Delete stream.\n",
        "operationId": "DeleteStream",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name of the stream.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "stream",
            "in": "path",
            "description": "Name of the stream.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "global",
            "in": "query",
            "description": "Is geo replicated stream?\n",
            "schema": {
              "type": "boolean",
              "format": "string",
              "default": false
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Stop all producer/consumer and delete stream forcefully.\n",
            "schema": {
              "type": "boolean",
              "format": "string",
              "default": false
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Accepted.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n",
            "content": {}
          },
          "502": {
            "description": "Returned if an error related to Streams communication was encountered.\n\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/streams/{stream}/publish": {
      "post": {
        "tags": [
          "Streams"
        ],
        "summary": "Publish message",
        "description": "Publish message in stream.\n\n",
        "operationId": "PublishStreamMessage",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name of the streams.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "stream",
            "in": "path",
            "description": "Name of the stream.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "global",
            "in": "query",
            "description": "Is geo replicated stream?\n",
            "schema": {
              "type": "boolean",
              "format": "string",
              "default": false
            }
          }
        ],
        "requestBody": {
          "description": "Name of the message.\n",
          "content": {
            "application/json": {
              "schema": {
                "type": "string"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Accepted.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n",
            "content": {}
          },
          "502": {
            "description": "Returned if an error related to C8Streams communication was encountered.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Message"
      }
    },
    "/_fabric/{fabric}/_api/streams/{stream}/backlog": {
      "get": {
        "tags": [
          "Streams"
        ],
        "summary": "Get backlog for the stream",
        "description": "\nGet estimated backlog for the stream.\n\n",
        "operationId": "Backlog",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name of the streams.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "stream",
            "in": "path",
            "description": "Name of the stream.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "global",
            "in": "query",
            "description": "Is geo replicated stream?\n",
            "schema": {
              "type": "boolean",
              "format": "string",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n",
            "content": {}
          },
          "502": {
            "description": "Returned if an error related to Streams communication was encountered.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/streams/{stream}/stats": {
      "get": {
        "tags": [
          "Streams"
        ],
        "summary": "Get stats for the stream",
        "description": "Get stats for the stream.\n\n",
        "operationId": "Stats",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name of the streams.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "stream",
            "in": "path",
            "description": "Name of the stream.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "global",
            "in": "query",
            "description": "Is geo replicated stream?\n",
            "schema": {
              "type": "boolean",
              "format": "string",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n",
            "content": {}
          },
          "502": {
            "description": "Returned if an error related to streams communication was encountered.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/streams/{stream}/subscriptions": {
      "get": {
        "tags": [
          "Streams"
        ],
        "summary": "Get subscriptions list",
        "description": "Get the list of subscriptions for given stream.\n\n",
        "operationId": "GetSubscriptionsList",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "stream",
            "in": "path",
            "description": "Name of the stream.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "global",
            "in": "query",
            "description": "Is geo replicated stream?\n",
            "schema": {
              "type": "boolean",
              "format": "string",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n",
            "content": {}
          },
          "502": {
            "description": "Returned if an error related to Streams communication was encountered.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/streams/ttl": {
      "get": {
        "tags": [
          "Streams"
        ],
        "summary": "Get message TTL in seconds for streams",
        "description": "Get message TTL in seconds for the streams.\n\n",
        "operationId": "GetStreamsTTL",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name of the streams.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n",
            "content": {}
          },
          "502": {
            "description": "Returned if an error related to Streams communication was encountered.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/streams/ttl/{ttl}": {
      "post": {
        "tags": [
          "Streams"
        ],
        "summary": "Set message TTL in seconds for all streams.",
        "description": " Set message TTL in seconds for all streams.\n\n",
        "operationId": "SetStreamsTTL",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name of the streams.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "ttl",
            "in": "path",
            "description": "TTL in seconds.\n",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "string",
              "default": 3600
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n",
            "content": {}
          },
          "502": {
            "description": "Returned if an error related to streams communication was encountered.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/streams/clearbacklog": {
      "post": {
        "tags": [
          "Streams"
        ],
        "summary": "Clear backlog",
        "description": "Clear backlog for all streams.\n\n",
        "operationId": "ClearBacklog",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name of the streams.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n",
            "content": {}
          },
          "502": {
            "description": "Returned if an error related to streams communication was encountered.\n\n",
            "content": {}
          }
        },
        "x-filename": "database/Documentation/DocuBlocks/Rest/Streams/README.md",
        "x-hints": ""
      }
    },
    "/_fabric/{fabric}/_api/streams/clearbacklog/{subscription}": {
      "post": {
        "tags": [
          "Streams"
        ],
        "summary": "Clear subscription's backlog",
        "description": "Clear backlog for all streams for given subscription.\n\n",
        "operationId": "ClearSubscription'sBacklog",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name of the streams.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "subscription",
            "in": "path",
            "description": "Identifying name of the subscription.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n",
            "content": {}
          },
          "502": {
            "description": "Returned if an error related to C8Streams communication was encountered.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/streams/{stream}/expiry/{seconds}": {
      "post": {
        "tags": [
          "Streams"
        ],
        "summary": "Expire messages on the stream",
        "description": " Expire messages on the stream for all subscriptions.\n\n",
        "operationId": "ExpireMessages",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "stream",
            "in": "path",
            "description": "Name of the stream.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "global",
            "in": "query",
            "description": "Is geo replicated stream?\n",
            "schema": {
              "type": "boolean",
              "format": "string",
              "default": false
            }
          },
          {
            "name": "seconds",
            "in": "path",
            "description": "Expiry time in seconds.\n",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int",
              "default": 3600
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n",
            "content": {}
          },
          "502": {
            "description": "Returned if an error related to Streams communication was encountered.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/streams/subscription/{subscription}": {
      "delete": {
        "tags": [
          "Streams"
        ],
        "summary": "Unsubscribe",
        "description": "Delete the given subscription on all streams on a stream db.\n\n",
        "operationId": "DeleteAllSubscriptions",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name of the streams.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "subscription",
            "in": "path",
            "description": "Identifying name of the subscription.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n",
            "content": {}
          },
          "502": {
            "description": "Returned if an error related to C8Streams communication was encountered.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/streams/{stream}/subscriptions/{subscription}": {
      "delete": {
        "tags": [
          "Streams"
        ],
        "summary": "Delete subscription.",
        "description": " Delete the given subscription. There should not be any active consumers.\n\n",
        "operationId": "DeleteSubscription",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "Fabric name of the streams.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "stream",
            "in": "path",
            "description": "Name of the stream.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "global",
            "in": "query",
            "description": "Is geo replicated stream?\n",
            "schema": {
              "type": "boolean",
              "format": "string",
              "default": false
            }
          },
          {
            "name": "subscription",
            "in": "path",
            "description": "Identifying name of the subscription.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.\n\n",
            "content": {}
          },
          "502": {
            "description": "Returned if an error related to C8Streams communication was encountered.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/streamapps/validate": {
      "post": {
        "tags": [
          "Stream Apps"
        ],
        "summary": "Validate stream application definition.",
        "description": "Validate stream application definition.",
        "operationId": "validate",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "default": "_system"
            }
          }
        ],
        "requestBody": {
          "description": "Stream application.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/stream_app_validate_request"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Stream application definition is valid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "422": {
            "description": "Error in stream application definition.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/_fabric/{fabric}/_api/streamapps": {
      "get": {
        "tags": [
          "Stream Apps"
        ],
        "summary": "Retrieve all Stream applications.",
        "description": "Retrieve all Stream applications.",
        "operationId": "getAll",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Stream applications.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/stream_app_response_container"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Stream Apps"
        ],
        "summary": "Create and deploy Stream application.",
        "description": "Create and deploy Stream application.",
        "operationId": "create",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "default": "_system"
            }
          }
        ],
        "requestBody": {
          "description": "Stream application.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/stream_app_request"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Stream application created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/stream_app_response_container"
                }
              }
            }
          },
          "400": {
            "description": "Invalid Request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "409": {
            "description": "Stream application already exists.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "422": {
            "description": "Error in stream application definition.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/_fabric/{fabric}/_api/streamapps/samples": {
      "get": {
        "tags": [
          "Stream Apps"
        ],
        "summary": "Retrieve sample applications.",
        "description": "Retrieve sample applications.",
        "operationId": "getSamples",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Sample stream applications.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/get_all_sample_stream_apps_response"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/streamapps/{appname}": {
      "get": {
        "tags": [
          "Stream Apps"
        ],
        "summary": "Retrieve single stream application.",
        "description": "Retrieve single stream application.",
        "operationId": "getApplication",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "default": "_system"
            }
          },
          {
            "name": "appname",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Stream application.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/get_all_stream_apps_response"
                }
              }
            }
          },
          "404": {
            "description": "Stream application does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Stream Apps"
        ],
        "summary": "Update and re-deploy stream application.",
        "description": "Update and re-deploy stream application.",
        "operationId": "update",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "default": "_system"
            }
          },
          {
            "name": "appname",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "Stream application.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/stream_app_request"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Stream application created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/stream_app_response_container"
                }
              }
            }
          },
          "400": {
            "description": "Invalid Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "404": {
            "description": "Stream application does not exists.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "422": {
            "description": "Error in stream application definition.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      },
      "delete": {
        "tags": [
          "Stream Apps"
        ],
        "summary": "Stop and  delete stream application.",
        "description": "Stop and  delete stream application.",
        "operationId": "delete",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "default": "_system"
            }
          },
          {
            "name": "appname",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Stream application deleted.",
            "content": {}
          },
          "404": {
            "description": "Stream application does not exists.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/streamapps/query/{appName}": {
      "post": {
        "tags": [
          "Stream Apps"
        ],
        "summary": "Submit an ad hoc Stream query and get the result records from a store.",
        "description": "Submit an ad hoc Stream query and get the result records from a store.",
        "operationId": "queryStreamApp",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "default": "_system"
            }
          },
          {
            "name": "appName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "Query object which contains the query which returns the store records.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/stream_app_query_request"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Result of query execution.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/stream_app_query_response"
                }
              }
            }
          },
          "400": {
            "description": "Invalid Request Body.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "422": {
            "description": "Error in stream application definition",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/_fabric/{fabric}/_api/streamapps/{appname}/active": {
      "patch": {
        "tags": [
          "Stream Apps"
        ],
        "summary": "Enable or Disable stream application.",
        "description": "Enable or Disable stream application.",
        "operationId": "enableApplication",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "default": "_system"
            }
          },
          {
            "name": "appname",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "active",
            "in": "query",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Stream application.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/get_all_stream_apps_response"
                }
              }
            }
          },
          "404": {
            "description": "Stream application does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/error_response"
                }
              }
            }
          }
        }
      }
    },
    "/_api/search": {
      "post": {
        "tags": [
          "Search"
        ],
        "summary": "String Search",
        "description": "\n\nSearch a collection for string matches.\n\nThe specified search query will be executed for the collection. The results of the search will be in the response. If there are too many results, an \"id\" will be specified for the cursor that can be used to obtain the remaining results.\n\n",
        "operationId": "SearchView",
        "requestBody": {
          "description": "Collection in which to search.\n\n",
          "content": {
            "application/json": {
              "schema": {
                "required": [
                  "collection",
                  "search"
                ],
                "type": "object",
                "properties": {
                  "collection": {
                    "type": "string",
                    "description": "Collection in which to search.\n\n",
                    "example": ""
                  },
                  "search": {
                    "type": "string",
                    "description": "C8QL search query, specifying search criteria for the documents in the collection.\n\n",
                    "example": ""
                  },
                  "bindVars": {
                    "type": "object",
                    "properties": {},
                    "description": "Bind variables for the search query.\n\n",
                    "example": {}
                  },
                  "ttl": {
                    "type": "integer",
                    "description": "How long search results should be preserved by the server (in seconds).\n\n",
                    "example": 60
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Search completed.\n\n",
            "content": {}
          },
          "400": {
            "description": "Invalid arguments supplied.\n\n",
            "content": {}
          },
          "403": {
            "description": "Permission denied for the specified collection.\n\n",
            "content": {}
          },
          "404": {
            "description": "Collection does not exist or search is disabled for this collection.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_api/search/collection/{collection-name}": {
      "post": {
        "tags": [
          "Search"
        ],
        "summary": "Set Search Capability",
        "description": "\n\nSet search capability of a collection (enabling or disabling it). If the collection does not exist, it will be created.\n\n",
        "operationId": "SearchViewUpdate",
        "parameters": [
          {
            "name": "collection-name",
            "in": "path",
            "description": "Collection for which to set search capability.\n",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "enable",
            "in": "query",
            "description": "Whether to enable or disable search capability.\n\n",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "field",
            "in": "query",
            "description": "For which field to enable search capability.\n\n",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.\n\n",
            "content": {}
          },
          "400": {
            "description": "Invalid arguments supplied.\n\n",
            "content": {}
          },
          "403": {
            "description": "Permission denied for the specified collection.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_api/search/view/{view-name}": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Return information about a view",
        "description": "\n\nThe result is an object describing the view with the following attributes:\n- *id*: The identifier of the view\n- *name*: The name of the view\n- *type*: The type of the view as string\n\n\n\n\n**Example:**\n Using an identifier:\n\n<pre><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl --header <span class=\"hljs-string\">'accept: application/json'</span> --dump - http://localhost:8529/_api/search/view/107726</span>\n</code><code>\n</code><code>HTTP/<span class=\"hljs-number\">1.1</span> OK\n</code><code>content-type: application/json; charset=utf<span class=\"hljs-number\">-8</span>\n</code><code>x-content-type-options: nosniff\n</code><code>\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"error\"</span> : <span class=\"hljs-literal\">false</span>, \n</code><code>  <span class=\"hljs-string\">\"code\"</span> : <span class=\"hljs-number\">200</span>, \n</code><code>  <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"c8search\"</span>, \n</code><code>  <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"testView\"</span>, \n</code><code>  <span class=\"hljs-string\">\"globallyUniqueId\"</span> : <span class=\"hljs-string\">\"h82E80CF18F1A/107726\"</span>, \n</code><code>  <span class=\"hljs-string\">\"id\"</span> : <span class=\"hljs-string\">\"107726\"</span> \n</code><code>}\n</code></pre>\n\n\n\n\n**Example:**\n Using a name:\n\n<pre><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl --header <span class=\"hljs-string\">'accept: application/json'</span> --dump - http://localhost:8529/_api/search/view/testView</span>\n</code><code>\n</code><code>HTTP/<span class=\"hljs-number\">1.1</span> OK\n</code><code>content-type: application/json; charset=utf<span class=\"hljs-number\">-8</span>\n</code><code>x-content-type-options: nosniff\n</code><code>\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"error\"</span> : <span class=\"hljs-literal\">false</span>, \n</code><code>  <span class=\"hljs-string\">\"code\"</span> : <span class=\"hljs-number\">200</span>, \n</code><code>  <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"c8search\"</span>, \n</code><code>  <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"testView\"</span>, \n</code><code>  <span class=\"hljs-string\">\"globallyUniqueId\"</span> : <span class=\"hljs-string\">\"h82E80CF18F1A/107732\"</span>, \n</code><code>  <span class=\"hljs-string\">\"id\"</span> : <span class=\"hljs-string\">\"107732\"</span> \n</code><code>}\n</code></pre>\n\n\n\n",
        "operationId": "getViews:Properties",
        "parameters": [
          {
            "name": "view-name",
            "in": "path",
            "description": "The name of the view.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "404": {
            "description": "Returned if the *view-name* is unknown, then a *HTTP 404* is returned.\n\n",
            "content": {}
          }
        }
      },
      "delete": {
        "tags": [
          "Search"
        ],
        "summary": "Drops a view",
        "description": "\n\nDrops the view identified by *view-name*.\n\nIf the view was successfully dropped, an object is returned with\nthe following attributes:\n- *error*: *false*\n- *id*: The identifier of the dropped view\n\n\n\n\n**Example:**\n Using an identifier:\n\n<pre><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl -X DELETE --header <span class=\"hljs-string\">'accept: application/json'</span> --dump - http://localhost:8529/_api/search/view/107714</span>\n</code><code>\n</code><code>HTTP/<span class=\"hljs-number\">1.1</span> OK\n</code><code>content-type: application/json; charset=utf<span class=\"hljs-number\">-8</span>\n</code><code>x-content-type-options: nosniff\n</code><code>\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"error\"</span> : <span class=\"hljs-literal\">false</span>, \n</code><code>  <span class=\"hljs-string\">\"code\"</span> : <span class=\"hljs-number\">200</span>, \n</code><code>  <span class=\"hljs-string\">\"result\"</span> : <span class=\"hljs-literal\">true</span> \n</code><code>}\n</code></pre>\n\n\n\n\n**Example:**\n Using a name:\n\n<pre><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl -X DELETE --header <span class=\"hljs-string\">'accept: application/json'</span> --dump - http://localhost:8529/_api/search/view/testView</span>\n</code><code>\n</code><code>HTTP/<span class=\"hljs-number\">1.1</span> OK\n</code><code>content-type: application/json; charset=utf<span class=\"hljs-number\">-8</span>\n</code><code>x-content-type-options: nosniff\n</code><code>\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"error\"</span> : <span class=\"hljs-literal\">false</span>, \n</code><code>  <span class=\"hljs-string\">\"code\"</span> : <span class=\"hljs-number\">200</span>, \n</code><code>  <span class=\"hljs-string\">\"result\"</span> : <span class=\"hljs-literal\">true</span> \n</code><code>}\n</code></pre>\n\n\n\n",
        "operationId": "deleteView",
        "parameters": [
          {
            "name": "view-name",
            "in": "path",
            "description": "The name of the view to drop.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "400": {
            "description": "Returned if the *view-name* is missing, then a *HTTP 400* is returned.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the *view-name* is unknown, then a *HTTP 404* is returned.\n\n",
            "content": {}
          }
        },
        "x-hints": ""
      }
    },
    "/_api/search/view/{view-name}/properties": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Read properties of a view",
        "description": "\n\nReturns an object containing the definition of the view identified by *view-name*.\n\n\n\nThe result is an object describing the view with the following attributes:\n- *id*: The identifier of the view\n- *name*: The name of the view\n- *type*: The type of the view as string\n- any additional view implementation specific properties\n\n\n\n\n**Example:**\n Using an identifier:\n\n<pre><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl --header <span class=\"hljs-string\">'accept: application/json'</span> --dump - http://localhost:8529/_api/search/view/107738/properties</span>\n</code><code>\n</code><code>HTTP/<span class=\"hljs-number\">1.1</span> OK\n</code><code>content-type: application/json; charset=utf<span class=\"hljs-number\">-8</span>\n</code><code>x-content-type-options: nosniff\n</code><code>\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"error\"</span> : <span class=\"hljs-literal\">false</span>, \n</code><code>  <span class=\"hljs-string\">\"code\"</span> : <span class=\"hljs-number\">200</span>, \n</code><code>  <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"c8search\"</span>, \n</code><code>  <span class=\"hljs-string\">\"primarySort\"</span> : [ ], \n</code><code>  <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"products\"</span>, \n</code><code>  <span class=\"hljs-string\">\"id\"</span> : <span class=\"hljs-string\">\"107738\"</span>, \n</code><code>  <span class=\"hljs-string\">\"links\"</span> : { \n</code><code>  }\n</code><code>}\n</code></pre>\n\n\n\n\n**Example:**\n Using a name:\n\n<pre><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl --header <span class=\"hljs-string\">'accept: application/json'</span> --dump - http://localhost:8529/_api/search/view/products/properties</span>\n</code><code>\n</code><code>HTTP/<span class=\"hljs-number\">1.1</span> OK\n</code><code>content-type: application/json; charset=utf<span class=\"hljs-number\">-8</span>\n</code><code>x-content-type-options: nosniff\n</code><code>\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"error\"</span> : <span class=\"hljs-literal\">false</span>, \n</code><code>  <span class=\"hljs-string\">\"code\"</span> : <span class=\"hljs-number\">200</span>, \n</code><code>  <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"c8search\"</span>, \n</code><code>  <span class=\"hljs-string\">\"primarySort\"</span> : [ ], \n</code><code>  <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"products\"</span>, \n</code><code>  <span class=\"hljs-string\">\"id\"</span> : <span class=\"hljs-string\">\"107745\"</span>, \n</code><code>  <span class=\"hljs-string\">\"links\"</span> : { \n</code><code>  }\n</code><code>}\n</code></pre>\n\n\n\n",
        "operationId": "getView",
        "parameters": [
          {
            "name": "view-name",
            "in": "path",
            "description": "The name of the view.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "400": {
            "description": "If the *view-name* is missing, then a *HTTP 400* is returned.\n\n",
            "content": {}
          },
          "404": {
            "description": "If the *view-name* is unknown, then a *HTTP 404* is returned.\n\n",
            "content": {}
          }
        },
        "x-hints": ""
      },
      "put": {
        "tags": [
          "Search"
        ],
        "summary": "Change properties of an C8Search view",
        "description": "\n**A JSON object with these properties is required:**\n\n  - **properties**:\n    - **links**:\n      - **[collection-name]**:\n        - **analyzers** (string): The list of analyzers to be used for indexing of string values\n      (default: [\"identity\"]).\n        - **fields**:\n          - **field-name** (object): This is a recursive structure for the specific attribute path, potentially\n       containing any of the following attributes:\n       *analyzers*, *includeAllFields*, *trackListPositions*, *storeValues*\n       Any attributes not specified are inherited from the parent.\n        - **includeAllFields**: The flag determines whether or not to index all fields on a particular level of\n      depth (default: false).\n        - **trackListPositions**: The flag determines whether or not values in a lists should be treated separate\n      (default: false).\n        - **storeValues**: How should the view track the attribute values, this setting allows for\n      additional value retrieval optimizations, one of:\n      - *none*: Do not store values by the view\n      - *id*: Store only information about value presence, to allow use of the EXISTS() function\n      (default \"none\").\n\n\n\nChanges the properties of a view.\n\nOn success an object with the following attributes is returned:\n- *id*: The identifier of the view\n- *name*: The name of the view\n- *type*: The view type\n- all additional c8search view implementation specific properties\n\n\n\n\n**Example:**\n \n\n<pre><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl -X PUT --header <span class=\"hljs-string\">'accept: application/json'</span> --data-binary @- --dump - http://localhost:8529/_api/search/view/products/properties</span> &lt;&lt;EOF\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"locale\"</span> : <span class=\"hljs-string\">\"en\"</span> \n</code><code>}\n</code><code>EOF\n</code><code>\n</code><code>HTTP/<span class=\"hljs-number\">1.1</span> OK\n</code><code>content-type: application/json; charset=utf<span class=\"hljs-number\">-8</span>\n</code><code>x-content-type-options: nosniff\n</code><code>\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"globallyUniqueId\"</span> : <span class=\"hljs-string\">\"h82E80CF18F1A/104873\"</span>, \n</code><code>  <span class=\"hljs-string\">\"id\"</span> : <span class=\"hljs-string\">\"104873\"</span>, \n</code><code>  <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"products\"</span>, \n</code><code>  <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"c8search\"</span>, \n</code><code>  <span class=\"hljs-string\">\"primarySort\"</span> : [ ], \n</code><code>  <span class=\"hljs-string\">\"links\"</span> : { \n</code><code>  } \n</code><code>}\n</code></pre>\n\n\n",
        "operationId": "modifyViewPut",
        "parameters": [
          {
            "name": "view-name",
            "in": "path",
            "description": "The name of the view.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/post_api_view_props"
              }
            }
          },
          "required": true
        },
        "responses": {
          "400": {
            "description": "Returned if the *view-name* is missing, then a *HTTP 400* is returned.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the *view-name* is unknown, then a *HTTP 404* is returned.\n\n",
            "content": {}
          }
        },
        "x-hints": "",
        "x-codegen-request-body-name": "Json Request Body"
      },
      "patch": {
        "tags": [
          "Search"
        ],
        "summary": "Partially changes properties of an C8Search view",
        "description": "\n**A JSON object with these properties is required:**\n\n  - **properties**:\n    - **links**:\n      - **[collection-name]**:\n        - **analyzers** (string): The list of analyzers to be used for indexing of string values\n      (default: [\"identity\"]).\n        - **fields**:\n          - **field-name** (object): This is a recursive structure for the specific attribute path, potentially\n       containing any of the following attributes:\n       *analyzers*, *includeAllFields*, *trackListPositions*, *storeValues*\n       Any attributes not specified are inherited from the parent.\n        - **includeAllFields**: The flag determines whether or not to index all fields on a particular level of\n      depth (default: false).\n        - **trackListPositions**: The flag determines whether or not values in a list should be treated separately\n      (default: false).\n        - **storeValues**: How should the view track the attribute values, this setting allows for\n      additional value retrieval optimizations, one of:\n      - *none*: Do not store values by the view\n      - *id*: Store only information about value presence, to allow use of the EXISTS() function\n      (default \"none\").\n\n\n\n\nChanges the properties of a view.\n\nOn success an object with the following attributes is returned:\n- *id*: The identifier of the view\n- *name*: The name of the view\n- *type*: The view type\n- all additional c8search view implementation specific properties\n\n\n\n\n**Example:**\n \n\n<pre><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl -X PATCH --header <span class=\"hljs-string\">'accept: application/json'</span> --data-binary @- --dump - http://localhost:8529/_api/search/view/products/properties</span> &lt;&lt;EOF\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"locale\"</span> : <span class=\"hljs-string\">\"en\"</span> \n</code><code>}\n</code><code>EOF\n</code><code>\n</code><code>HTTP/<span class=\"hljs-number\">1.1</span> OK\n</code><code>content-type: application/json; charset=utf<span class=\"hljs-number\">-8</span>\n</code><code>x-content-type-options: nosniff\n</code><code>\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"globallyUniqueId\"</span> : <span class=\"hljs-string\">\"h82E80CF18F1A/104859\"</span>, \n</code><code>  <span class=\"hljs-string\">\"id\"</span> : <span class=\"hljs-string\">\"104859\"</span>, \n</code><code>  <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"products\"</span>, \n</code><code>  <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"c8search\"</span>, \n</code><code>  <span class=\"hljs-string\">\"primarySort\"</span> : [ ], \n</code><code>  <span class=\"hljs-string\">\"links\"</span> : { \n</code><code>  } \n</code><code>}\n</code></pre>\n\n\n\n",
        "operationId": "modifyViewPatch",
        "parameters": [
          {
            "name": "view-name",
            "in": "path",
            "description": "The name of the view.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/post_api_view_props"
              }
            }
          },
          "required": true
        },
        "responses": {
          "400": {
            "description": "If the *view-name* is missing, then a *HTTP 400* is returned.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the *view-name* is unknown, then a *HTTP 404* is returned.\n\n",
            "content": {}
          }
        },
        "x-hints": "",
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_api/search/view/{view-name}/rename": {
      "put": {
        "tags": [
          "Search"
        ],
        "summary": "Rename a view",
        "description": "\n\nRenames a view. Expects an object with the attribute(s)\n- *name*: The new name\n\nIt returns an object with the attributes\n- *id*: The identifier of the view.\n- *name*: The new name of the view.\n- *type*: The view type.\n\n**Note**: this method is not available in a cluster.\n\n\n\n\n**Example:**\n \n\n<pre><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl -X PUT --header <span class=\"hljs-string\">'accept: application/json'</span> --data-binary @- --dump - http://localhost:8529/_api/search/view/products1/rename</span> &lt;&lt;EOF\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"viewNewName\"</span> \n</code><code>}\n</code><code>EOF\n</code><code>\n</code><code>HTTP/<span class=\"hljs-number\">1.1</span> OK\n</code><code>content-type: application/json; charset=utf<span class=\"hljs-number\">-8</span>\n</code><code>x-content-type-options: nosniff\n</code><code>\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"error\"</span> : <span class=\"hljs-literal\">false</span>, \n</code><code>  <span class=\"hljs-string\">\"code\"</span> : <span class=\"hljs-number\">200</span>, \n</code><code>  <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"c8search\"</span>, \n</code><code>  <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"viewNewName\"</span>, \n</code><code>  <span class=\"hljs-string\">\"globallyUniqueId\"</span> : <span class=\"hljs-string\">\"h82E80CF18F1A/107774\"</span>, \n</code><code>  <span class=\"hljs-string\">\"id\"</span> : <span class=\"hljs-string\">\"107774\"</span> \n</code><code>}\n</code></pre>\n\n\n\n",
        "operationId": "modifyView:rename",
        "parameters": [
          {
            "name": "view-name",
            "in": "path",
            "description": "The name of the view to rename.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/rename_view"
              }
            }
          },
          "required": true
        },
        "responses": {
          "400": {
            "description": "Returned if the *view-name* is missing, then a *HTTP 400* is returned.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the *view-name* is unknown, then a *HTTP 404* is returned.\n\n",
            "content": {}
          }
        },
        "x-hints": "",
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_api/search/view": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "List all views.",
        "description": "\n\nReturns an object containing an array of all view descriptions.\n\n\n\n\n**Example:**\n Return information about all views:\n\n<pre><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl --header <span class=\"hljs-string\">'accept: application/json'</span> --dump - http://localhost:8529/_api/search/view</span>\n</code><code>\n</code><code>HTTP/<span class=\"hljs-number\">1.1</span> OK\n</code><code>content-type: application/json; charset=utf<span class=\"hljs-number\">-8</span>\n</code><code>x-content-type-options: nosniff\n</code><code>\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"error\"</span> : <span class=\"hljs-literal\">false</span>, \n</code><code>  <span class=\"hljs-string\">\"code\"</span> : <span class=\"hljs-number\">200</span>, \n</code><code>  <span class=\"hljs-string\">\"result\"</span> : [ \n</code><code>    { \n</code><code>      <span class=\"hljs-string\">\"globallyUniqueId\"</span> : <span class=\"hljs-string\">\"h82E80CF18F1A/108\"</span>, \n</code><code>      <span class=\"hljs-string\">\"id\"</span> : <span class=\"hljs-string\">\"108\"</span>, \n</code><code>      <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"demoView\"</span>, \n</code><code>      <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"c8search\"</span> \n</code><code>    } \n</code><code>  ] \n</code><code>}\n</code></pre>\n\n\n\n",
        "operationId": "getViews:AllViews",
        "responses": {
          "200": {
            "description": "The list of views.\n\n",
            "content": {}
          }
        },
        "x-hints": ""
      },
      "post": {
        "tags": [
          "Search"
        ],
        "summary": "Create an C8Search view",
        "description": "\n**A JSON object with these properties is required:**\n\n  - **type**: The type of the view. must be equal to *\"c8search\"*\n  - **name**: The name of the view.\n  - **properties**:\n    - **links**:\n      - **[collection-name]**:\n        - **analyzers** (string): The list of analyzers to be used for indexing of string values\n      (default: [\"identity\"]).\n        - **fields**:\n          - **field-name** (object): This is a recursive structure for the specific attribute path, potentially\n       containing any of the following attributes:\n       *analyzers*, *includeAllFields*, *trackListPositions*, *storeValues*\n       Any attributes not specified are inherited from the parent.\n        - **includeAllFields**: The flag determines whether or not to index all fields on a particular level of\n      depth (default: false).\n        - **trackListPositions**: The flag determines whether or not values in a lists should be treated separate\n      (default: false).\n        - **storeValues**: How should the view track the attribute values, this setting allows for\n      additional value retrieval optimizations, one of:\n      - *none*: Do not store values by the view\n      - *id*: Store only information about value presence, to allow use of the EXISTS() function\n      (default \"none\").\n\n\nCreates a new view with a given name and properties if it does not\nalready exist.\n\n**Note**: view can't be created with the links. Please use PUT/PATCH for links\nmanagement.\n\n\n\n\n**Example:**\n \n\n<pre><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl -X POST --header <span class=\"hljs-string\">'accept: application/json'</span> --data-binary @- --dump - http://localhost:8529/_api/search/view</span> &lt;&lt;EOF\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"testViewBasics\"</span>, \n</code><code>  <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"c8search\"</span> \n</code><code>}\n</code><code>EOF\n</code><code>\n</code><code>HTTP/<span class=\"hljs-number\">1.1</span> Created\n</code><code>content-type: application/json; charset=utf<span class=\"hljs-number\">-8</span>\n</code><code>x-content-type-options: nosniff\n</code><code>\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"globallyUniqueId\"</span> : <span class=\"hljs-string\">\"h82E80CF18F1A/107760\"</span>, \n</code><code>  <span class=\"hljs-string\">\"id\"</span> : <span class=\"hljs-string\">\"107760\"</span>, \n</code><code>  <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"testViewBasics\"</span>, \n</code><code>  <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"c8search\"</span>, \n</code><code>  <span class=\"hljs-string\">\"primarySort\"</span> : [ ], \n</code><code>  <span class=\"hljs-string\">\"links\"</span> : { \n</code><code>  } \n</code><code>}\n</code></pre>\n\n\n\n",
        "operationId": "createView",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/post_api_view_iresearch"
              }
            }
          },
          "required": true
        },
        "responses": {
          "400": {
            "description": "Returned if the *view-name* is missing, then a *HTTP 400* is returned.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the *view-name* is unknown, then a *HTTP 404* is returned.\n\n",
            "content": {}
          }
        },
        "x-hints": "",
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_api/search/analyzer": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "List all analyzers",
        "description": "\n\nRetrieves a an array of all analyzer definitions.\nThe resulting array contains objects with the following attributes:\n- *name*: the analyzer name\n- *type*: the analyzer type\n- *properties*: the properties used to configure the specified type\n- *features*: the set of features to set on the analyzer generated fields\n\n\n\n\n**Example:**\n Retrieve all analyzer definitions:\n\n<pre><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl --header <span class=\"hljs-string\">'accept: application/json'</span> --dump - http://localhost:8529/_api/search/analyzer</span>\n</code><code>\n</code><code>HTTP/<span class=\"hljs-number\">1.1</span> OK\n</code><code>content-type: application/json; charset=utf<span class=\"hljs-number\">-8</span>\n</code><code>x-content-type-options: nosniff\n</code><code>\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"error\"</span> : <span class=\"hljs-literal\">false</span>, \n</code><code>  <span class=\"hljs-string\">\"code\"</span> : <span class=\"hljs-number\">200</span>, \n</code><code>  <span class=\"hljs-string\">\"result\"</span> : [ \n</code><code>    { \n</code><code>      <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"text_zh\"</span>, \n</code><code>      <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"text\"</span>, \n</code><code>      <span class=\"hljs-string\">\"properties\"</span> : { \n</code><code>        <span class=\"hljs-string\">\"locale\"</span> : <span class=\"hljs-string\">\"zh.UTF-8\"</span>, \n</code><code>        <span class=\"hljs-string\">\"stopwords\"</span> : [ ] \n</code><code>      }, \n</code><code>      <span class=\"hljs-string\">\"features\"</span> : [ \n</code><code>        <span class=\"hljs-string\">\"position\"</span>, \n</code><code>        <span class=\"hljs-string\">\"norm\"</span>, \n</code><code>        <span class=\"hljs-string\">\"frequency\"</span> \n</code><code>      ] \n</code><code>    }, \n</code><code>    { \n</code><code>      <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"text_sv\"</span>, \n</code><code>      <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"text\"</span>, \n</code><code>      <span class=\"hljs-string\">\"properties\"</span> : { \n</code><code>        <span class=\"hljs-string\">\"locale\"</span> : <span class=\"hljs-string\">\"sv.UTF-8\"</span>, \n</code><code>        <span class=\"hljs-string\">\"stopwords\"</span> : [ ] \n</code><code>      }, \n</code><code>      <span class=\"hljs-string\">\"features\"</span> : [ \n</code><code>        <span class=\"hljs-string\">\"position\"</span>, \n</code><code>        <span class=\"hljs-string\">\"norm\"</span>, \n</code><code>        <span class=\"hljs-string\">\"frequency\"</span> \n</code><code>      ] \n</code><code>    }, \n</code><code>    { \n</code><code>      <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"text_pt\"</span>, \n</code><code>      <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"text\"</span>, \n</code><code>      <span class=\"hljs-string\">\"properties\"</span> : { \n</code><code>        <span class=\"hljs-string\">\"locale\"</span> : <span class=\"hljs-string\">\"pt.UTF-8\"</span>, \n</code><code>        <span class=\"hljs-string\">\"stopwords\"</span> : [ ] \n</code><code>      }, \n</code><code>      <span class=\"hljs-string\">\"features\"</span> : [ \n</code><code>        <span class=\"hljs-string\">\"position\"</span>, \n</code><code>        <span class=\"hljs-string\">\"norm\"</span>, \n</code><code>        <span class=\"hljs-string\">\"frequency\"</span> \n</code><code>      ] \n</code><code>    }, \n</code><code>    { \n</code><code>      <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"text_no\"</span>, \n</code><code>      <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"text\"</span>, \n</code><code>      <span class=\"hljs-string\">\"properties\"</span> : { \n</code><code>        <span class=\"hljs-string\">\"locale\"</span> : <span class=\"hljs-string\">\"no.UTF-8\"</span>, \n</code><code>        <span class=\"hljs-string\">\"stopwords\"</span> : [ ] \n</code><code>      }, \n</code><code>      <span class=\"hljs-string\">\"features\"</span> : [ \n</code><code>        <span class=\"hljs-string\">\"position\"</span>, \n</code><code>        <span class=\"hljs-string\">\"norm\"</span>, \n</code><code>        <span class=\"hljs-string\">\"frequency\"</span> \n</code><code>      ] \n</code><code>    }, \n</code><code>    { \n</code><code>      <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"text_ru\"</span>, \n</code><code>      <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"text\"</span>, \n</code><code>      <span class=\"hljs-string\">\"properties\"</span> : { \n</code><code>        <span class=\"hljs-string\">\"locale\"</span> : <span class=\"hljs-string\">\"ru.UTF-8\"</span>, \n</code><code>        <span class=\"hljs-string\">\"stopwords\"</span> : [ ] \n</code><code>      }, \n</code><code>      <span class=\"hljs-string\">\"features\"</span> : [ \n</code><code>        <span class=\"hljs-string\">\"position\"</span>, \n</code><code>        <span class=\"hljs-string\">\"norm\"</span>, \n</code><code>        <span class=\"hljs-string\">\"frequency\"</span> \n</code><code>      ] \n</code><code>    }, \n</code><code>    { \n</code><code>      <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"identity\"</span>, \n</code><code>      <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"identity\"</span>, \n</code><code>      <span class=\"hljs-string\">\"properties\"</span> : <span class=\"hljs-literal\">null</span>, \n</code><code>      <span class=\"hljs-string\">\"features\"</span> : [ \n</code><code>        <span class=\"hljs-string\">\"norm\"</span>, \n</code><code>        <span class=\"hljs-string\">\"frequency\"</span> \n</code><code>      ] \n</code><code>    }, \n</code><code>    { \n</code><code>      <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"text_fi\"</span>, \n</code><code>      <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"text\"</span>, \n</code><code>      <span class=\"hljs-string\">\"properties\"</span> : { \n</code><code>        <span class=\"hljs-string\">\"locale\"</span> : <span class=\"hljs-string\">\"fi.UTF-8\"</span>, \n</code><code>        <span class=\"hljs-string\">\"stopwords\"</span> : [ ] \n</code><code>      }, \n</code><code>      <span class=\"hljs-string\">\"features\"</span> : [ \n</code><code>        <span class=\"hljs-string\">\"position\"</span>, \n</code><code>        <span class=\"hljs-string\">\"norm\"</span>, \n</code><code>        <span class=\"hljs-string\">\"frequency\"</span> \n</code><code>      ] \n</code><code>    }, \n</code><code>    { \n</code><code>      <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"text_en\"</span>, \n</code><code>      <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"text\"</span>, \n</code><code>      <span class=\"hljs-string\">\"properties\"</span> : { \n</code><code>        <span class=\"hljs-string\">\"locale\"</span> : <span class=\"hljs-string\">\"en.UTF-8\"</span>, \n</code><code>        <span class=\"hljs-string\">\"stopwords\"</span> : [ ] \n</code><code>      }, \n</code><code>      <span class=\"hljs-string\">\"features\"</span> : [ \n</code><code>        <span class=\"hljs-string\">\"position\"</span>, \n</code><code>        <span class=\"hljs-string\">\"norm\"</span>, \n</code><code>        <span class=\"hljs-string\">\"frequency\"</span> \n</code><code>      ] \n</code><code>    }, \n</code><code>    { \n</code><code>      <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"text_nl\"</span>, \n</code><code>      <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"text\"</span>, \n</code><code>      <span class=\"hljs-string\">\"properties\"</span> : { \n</code><code>        <span class=\"hljs-string\">\"locale\"</span> : <span class=\"hljs-string\">\"nl.UTF-8\"</span>, \n</code><code>        <span class=\"hljs-string\">\"stopwords\"</span> : [ ] \n</code><code>      }, \n</code><code>      <span class=\"hljs-string\">\"features\"</span> : [ \n</code><code>        <span class=\"hljs-string\">\"position\"</span>, \n</code><code>        <span class=\"hljs-string\">\"norm\"</span>, \n</code><code>        <span class=\"hljs-string\">\"frequency\"</span> \n</code><code>      ] \n</code><code>    }, \n</code><code>    { \n</code><code>      <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"text_it\"</span>, \n</code><code>      <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"text\"</span>, \n</code><code>      <span class=\"hljs-string\">\"properties\"</span> : { \n</code><code>        <span class=\"hljs-string\">\"locale\"</span> : <span class=\"hljs-string\">\"it.UTF-8\"</span>, \n</code><code>        <span class=\"hljs-string\">\"stopwords\"</span> : [ ] \n</code><code>      }, \n</code><code>      <span class=\"hljs-string\">\"features\"</span> : [ \n</code><code>        <span class=\"hljs-string\">\"position\"</span>, \n</code><code>        <span class=\"hljs-string\">\"norm\"</span>, \n</code><code>        <span class=\"hljs-string\">\"frequency\"</span> \n</code><code>      ] \n</code><code>    }, \n</code><code>    { \n</code><code>      <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"text_fr\"</span>, \n</code><code>      <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"text\"</span>, \n</code><code>      <span class=\"hljs-string\">\"properties\"</span> : { \n</code><code>        <span class=\"hljs-string\">\"locale\"</span> : <span class=\"hljs-string\">\"fr.UTF-8\"</span>, \n</code><code>        <span class=\"hljs-string\">\"stopwords\"</span> : [ ] \n</code><code>      }, \n</code><code>      <span class=\"hljs-string\">\"features\"</span> : [ \n</code><code>        <span class=\"hljs-string\">\"position\"</span>, \n</code><code>        <span class=\"hljs-string\">\"norm\"</span>, \n</code><code>        <span class=\"hljs-string\">\"frequency\"</span> \n</code><code>      ] \n</code><code>    }, \n</code><code>    { \n</code><code>      <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"text_de\"</span>, \n</code><code>      <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"text\"</span>, \n</code><code>      <span class=\"hljs-string\">\"properties\"</span> : { \n</code><code>        <span class=\"hljs-string\">\"locale\"</span> : <span class=\"hljs-string\">\"de.UTF-8\"</span>, \n</code><code>        <span class=\"hljs-string\">\"stopwords\"</span> : [ ] \n</code><code>      }, \n</code><code>      <span class=\"hljs-string\">\"features\"</span> : [ \n</code><code>        <span class=\"hljs-string\">\"position\"</span>, \n</code><code>        <span class=\"hljs-string\">\"norm\"</span>, \n</code><code>        <span class=\"hljs-string\">\"frequency\"</span> \n</code><code>      ] \n</code><code>    }, \n</code><code>    { \n</code><code>      <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"text_es\"</span>, \n</code><code>      <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"text\"</span>, \n</code><code>      <span class=\"hljs-string\">\"properties\"</span> : { \n</code><code>        <span class=\"hljs-string\">\"locale\"</span> : <span class=\"hljs-string\">\"es.UTF-8\"</span>, \n</code><code>        <span class=\"hljs-string\">\"stopwords\"</span> : [ ] \n</code><code>      }, \n</code><code>      <span class=\"hljs-string\">\"features\"</span> : [ \n</code><code>        <span class=\"hljs-string\">\"position\"</span>, \n</code><code>        <span class=\"hljs-string\">\"norm\"</span>, \n</code><code>        <span class=\"hljs-string\">\"frequency\"</span> \n</code><code>      ] \n</code><code>    } \n</code><code>  ] \n</code><code>}\n</code></pre>\n\n\n\n\n",
        "operationId": "RestAnalyzerHandler:List",
        "responses": {
          "200": {
            "description": "The analyzer definitions was retrieved successfully.\n\n",
            "content": {}
          }
        },
        "x-hints": ""
      },
      "post": {
        "tags": [
          "Search"
        ],
        "summary": "Create an analyzer with the suppiled definition",
        "description": "\n**A JSON object with these properties is required:**\n\n  - **features** (string): The set of features to set on the analyzer generated fields.\n   The default value is an empty array.\n  - **type**: The analyzer type.\n  - **name**: The analyzer name.\n  - **properties**: The properties used to configure the specified type.\n   Value may be a string, an object or null.\n   The default value is *null*.\n\n\n\n\nCreates a new analyzer based on the provided configuration.\n\n\n\n\n**Example:**\n \n\n<pre><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl -X POST --header <span class=\"hljs-string\">'accept: application/json'</span> --data-binary @- --dump - http://localhost:8529/_api/search/analyzer</span> &lt;&lt;EOF\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"testAnalyzer\"</span>, \n</code><code>  <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"identity\"</span> \n</code><code>}\n</code><code>EOF\n</code><code>\n</code><code>HTTP/<span class=\"hljs-number\">1.1</span> Created\n</code><code>content-type: application/json; charset=utf<span class=\"hljs-number\">-8</span>\n</code><code>x-content-type-options: nosniff\n</code><code>\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"_system::testAnalyzer\"</span>, \n</code><code>  <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"identity\"</span>, \n</code><code>  <span class=\"hljs-string\">\"properties\"</span> : <span class=\"hljs-literal\">null</span>, \n</code><code>  <span class=\"hljs-string\">\"features\"</span> : [ ] \n</code><code>}\n</code></pre>\n\n\n\n\n",
        "operationId": "RestAnalyzerHandler:Create",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/post_api_analyzer"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "An analyzer with a matching name and definition already exists.\n\n",
            "content": {}
          },
          "201": {
            "description": "A new analyzer definition was successfully created.\n\n",
            "content": {}
          },
          "400": {
            "description": "One or more of the required parameters is missing or one or more of the parameters\nis not valid.\n\n",
            "content": {}
          },
          "403": {
            "description": "The user does not have permission to create and analyzer with this configuration.\n\n",
            "content": {}
          }
        },
        "x-hints": "",
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_api/search/analyzer/{analyzer-name}": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Return the analyzer definition",
        "description": "\n\nRetrieves the full definition for the specified analyzer name.\nThe resulting object contains the following attributes:\n- *name*: the analyzer name\n- *type*: the analyzer type\n- *properties*: the properties used to configure the specified type\n- *features*: the set of features to set on the analyzer generated fields\n\n\n\n\n**Example:**\n Retrieve an analyzer definition:\n\n<pre><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl --header <span class=\"hljs-string\">'accept: application/json'</span> --dump - http://localhost:8529/_api/search/analyzer/testAnalyzer</span>\n</code><code>\n</code><code>HTTP/<span class=\"hljs-number\">1.1</span> OK\n</code><code>content-type: application/json; charset=utf<span class=\"hljs-number\">-8</span>\n</code><code>x-content-type-options: nosniff\n</code><code>\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"error\"</span> : <span class=\"hljs-literal\">false</span>, \n</code><code>  <span class=\"hljs-string\">\"code\"</span> : <span class=\"hljs-number\">200</span>, \n</code><code>  <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"identity\"</span>, \n</code><code>  <span class=\"hljs-string\">\"properties\"</span> : <span class=\"hljs-string\">\"test properties\"</span>, \n</code><code>  <span class=\"hljs-string\">\"features\"</span> : [ ], \n</code><code>  <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"_system::testAnalyzer\"</span> \n</code><code>}\n</code></pre>\n\n\n\n\n\n",
        "operationId": "RestAnalyzerHandler:GetDefinition",
        "parameters": [
          {
            "name": "analyzer-name",
            "in": "path",
            "description": "The name of the analyzer to retrieve.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The analyzer definition was retrieved successfully.\n\n",
            "content": {}
          },
          "404": {
            "description": "Such an analyzer configuration does not exist.\n\n",
            "content": {}
          }
        }
      },
      "delete": {
        "tags": [
          "Search"
        ],
        "summary": "Remove an analyzer",
        "description": "\n\nRemoves an analyzer configuration identified by *analyzer-name*.\n\nIf the analyzer definition was successfully dropped, an object is returned with\nthe following attributes:\n- *error*: *false*\n- *name*: The name of the removed analyzer\n\n\n\n\n**Example:**\n Removing without *force*:\n\n<pre><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl -X DELETE --header <span class=\"hljs-string\">'accept: application/json'</span> --dump - http://localhost:8529/_api/search/analyzer/testAnalyzer</span>\n</code><code>\n</code><code>HTTP/<span class=\"hljs-number\">1.1</span> OK\n</code><code>content-type: application/json; charset=utf<span class=\"hljs-number\">-8</span>\n</code><code>x-content-type-options: nosniff\n</code><code>\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"error\"</span> : <span class=\"hljs-literal\">false</span>, \n</code><code>  <span class=\"hljs-string\">\"code\"</span> : <span class=\"hljs-number\">200</span>, \n</code><code>  <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"_system::testAnalyzer\"</span> \n</code><code>}\n</code></pre>\n\n\n\n\n**Example:**\n Removing with *force*:\n\n<pre><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl -X POST --header <span class=\"hljs-string\">'accept: application/json'</span> --data-binary @- --dump - http://localhost:8529/_api/collection</span> &lt;&lt;EOF\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"testCollection\"</span> \n</code><code>}\n</code><code>EOF\n</code><code>\n</code><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl -X POST --header <span class=\"hljs-string\">'accept: application/json'</span> --data-binary @- --dump - http://localhost:8529/_api/search/view</span> &lt;&lt;EOF\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"testView\"</span>, \n</code><code>  <span class=\"hljs-string\">\"type\"</span> : <span class=\"hljs-string\">\"c8search\"</span>, \n</code><code>  <span class=\"hljs-string\">\"links\"</span> : { \n</code><code>    <span class=\"hljs-string\">\"testCollection\"</span> : { \n</code><code>      <span class=\"hljs-string\">\"analyzers\"</span> : [ \n</code><code>        <span class=\"hljs-string\">\"testAnalyzer\"</span> \n</code><code>      ] \n</code><code>    } \n</code><code>  } \n</code><code>}\n</code><code>EOF\n</code><code>\n</code><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl -X DELETE --header <span class=\"hljs-string\">'accept: application/json'</span> --dump - http://localhost:8529/_api/search/analyzer/testAnalyzer?force=<span class=\"hljs-literal\">false</span></span>\n</code><code>\n</code><code><span class=\"hljs-meta\">shell&gt;</span><span class=\"bash\"> curl -X DELETE --header <span class=\"hljs-string\">'accept: application/json'</span> --dump - http://localhost:8529/_api/search/analyzer/testAnalyzer?force=<span class=\"hljs-literal\">true</span></span>\n</code><code>\n</code><code>HTTP/<span class=\"hljs-number\">1.1</span> OK\n</code><code>content-type: application/json; charset=utf<span class=\"hljs-number\">-8</span>\n</code><code>x-content-type-options: nosniff\n</code><code>\n</code><code>{ \n</code><code>  <span class=\"hljs-string\">\"error\"</span> : <span class=\"hljs-literal\">false</span>, \n</code><code>  <span class=\"hljs-string\">\"code\"</span> : <span class=\"hljs-number\">200</span>, \n</code><code>  <span class=\"hljs-string\">\"name\"</span> : <span class=\"hljs-string\">\"_system::testAnalyzer\"</span> \n</code><code>}\n</code></pre>\n\n\n\n\n",
        "operationId": "RestAnalyzerHandler:Delete",
        "parameters": [
          {
            "name": "analyzer-name",
            "in": "path",
            "description": "The name of the analyzer to remove.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "The analyzer configuration should be removed even if it is in-use.\nThe default value is *false*.\n\n",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The analyzer configuration was removed successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "The *analyzer-name* was not supplied or another request parameter was not\nvalid.\n\n",
            "content": {}
          },
          "403": {
            "description": "The user does not have permission to remove this analyzer configuration.\n\n",
            "content": {}
          },
          "404": {
            "description": "Such an analyzer configuration does not exist.\n\n",
            "content": {}
          },
          "409": {
            "description": "The specified analyzer configuration is still in use and *force* was omitted or\n*false* specified.\n\n",
            "content": {}
          }
        },
        "x-hints": ""
      }
    },
    "/_fabric/_system/_api/database": {
      "get": {
        "tags": [
          "Geo Fabrics"
        ],
        "summary": "List of GeoFabrics",
        "description": "\nRetrieves the list of all existing GeoFabrics\n**Note**: retrieving the list of GeoFabrics is only possible from within the *_system* fabric.\n**Note**: You should use the *GET user API* to fetch the list of the available GeoFabrics now.\n\n",
        "operationId": "ListOfGeo-fabrics",
        "responses": {
          "200": {
            "description": "Returned if the list of GeoFabrics was compiled successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request is invalid.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if the request was not executed in the *_system* fabric.\n\n",
            "content": {}
          }
        }
      },
      "post": {
        "tags": [
          "Geo Fabrics"
        ],
        "summary": "Create GeoFabric",
        "description": "\nA JSON object with these properties is required:\n\n  - **users**: Has to be an array of user objects to initially create for the new GeoFabric. User information will not be changed for users that already exist. If *users* is not specified or does not contain any users, a default user *root* will be created with an empty string password. This ensures that the new GeoFabric will be accessible after it is created.\n  \n   Each user object can contain the following attributes:\n    - **username**: Loginname of the user to be created\n    - **passwd**: The user password as a string. If not specified, it will default to an empty string.\n    - **active**: A flag indicating whether the user account should be activated or not. The default value is *true*. If set to *false*, the user won't be able to log into the GeoFabric.\n    - **extra**: A JSON object with extra user information. The data contained in *extra* will be stored for the user but not be interpreted further by database.\n    \n  - **name**: Has to contain a valid GeoFabric name.\n  - **options**:\n    - **spotDc**: The Edge Location (Datacenter) where on-spot operations for the given GeoFabric will be performed. By default a random datacenter is chosen from those which are capable.\n    - **dcList**: The list of Edge Locations (datacenters) as a comma-separated string. The individual elements for this parameter are your Edge Location URL prefixes up to the first *.* character. \n    \n      For instance if one of your Edge Location URLs is *http://myfederation-us-east-1.dev.aws.macrometa.io*, then the corresponding value of one the items for this parameter would be *myfederation-us-east-1*. You can use the */datacenter/all* REST API call to get a list of all available Edge Locations and then pick and choose from this list. \n      \n      It is a mandatory field, but if not specified (due to user error), it defaults to the local Edge Location.\n\nCreates a new GeoFabric\nThe response is a JSON object with the attribute *result* set to *true*.\n\n**Note**: creating a new GeoFabric is only possible from within the *_system* fabric.\n\n",
        "operationId": "CreateGeo-fabric",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/create_database"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the GeoFabric was created successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request parameters are invalid or if a GeoFabric with the\nspecified name already exists.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if the request was not executed in the *_system* fabric.\n\n",
            "content": {}
          },
          "409": {
            "description": "Returned if a GeoFabric with the specified name already exists.\n\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/_system/_api/database/user": {
      "get": {
        "tags": [
          "Geo Fabrics"
        ],
        "summary": "List of accessible GeoFabrics",
        "description": "\n\nRetrieves the list of all GeoFabrics and their information the current user can access without specifying a different username or password.\n\n",
        "operationId": "ListOfAccessibleGeoFabrics",
        "responses": {
          "200": {
            "description": "Returned if the list of GeoFabric was compiled successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request is invalid.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/_system/_api/database/{fabric}": {
      "delete": {
        "tags": [
          "Geo Fabrics"
        ],
        "summary": "Drop GeoFabric",
        "description": "\nDrops the GeoFabric along with all data stored in it.\n\n**Note**: dropping a GeoFabric is only possible from within the *_system* fabric. The *_system* fabric itself cannot be dropped.\n\n",
        "operationId": "DropGeo-fabric",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the GeoFabric.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the GeoFabric was dropped successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request is malformed.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if the request was not executed in the *_system* fabric.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the GeoFabric could not be found.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/database/metadata": {
      "get": {
        "tags": [
          "Geo Fabrics"
        ],
        "summary": "Information of the GeoFabric",
        "description": "\n\nRetrieves information about the current GeoFabric\n\nThe response is a JSON object with the following attributes:\n\n- *name*: the name of the current GeoFabric\n\n- *options*:\n    - *clusters*: list of datacenters added to the GeoFabric\n    - *dcList*: comma-separated list of datacenters added to the GeoFabric\n    - *global*: is global\n    - *isSystem*: whether or not the current GeoFabric is the *_system* fabric\n    - *name*: name of the GeoFabric\n    - *origin*: originating location\n    - *realTime*: whether the changes are published in a real time streams\n    - *spotDc*: The Edge Location (Datacenter) where on-spot operations for the given GeoFabric will be performed\n    - *status*: available or not\n    - *tenant*: tanant's name\n\n- *isSystem*: whether or not the current GeoFabric is the *_system* fabric\n\n",
        "operationId": "InformationOfTheGeo-fabric",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The Database name for which we want the information.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the information was retrieved successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request is invalid.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the GeoFabric could not be found.\n\n\n\n",
            "content": {}
          }
        }
      }
    },
    "/_api/version": {
      "get": {
        "tags": [
          "Users"
        ],
        "summary": "Return server version",
        "description": "\nReturns the server name and version number. The response is a JSON object with the following attributes:\n\n**HTTP 200**\n*A json document with these Properties is returned:* is returned in all cases.\n- **version**: the server version string. \n\nThe string has the format \"*major*.*minor*.*sub*\". *major* and *minor* will be numeric, and *sub* may contain a number or a textual version.\n",
        "operationId": "RestVersionHandler",
        "responses": {
          "200": {
            "description": "Returned in all cases.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/get_api_return_rc_200"
                }
              }
            },
            "x-description-offset": 175
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/user": {
      "post": {
        "tags": [
          "Users"
        ],
        "summary": "Create User",
        "description": "\nA JSON object with these properties is required:\n\n  - **passwd**: The user password as a string.\n  - **active**: An optional flag that specifies whether the user is active.  If not specified, this will default to true\n  - **extra**: An optional JSON object with arbitrary extra data about the user.\n  - **user**: The name of the user as a string.\n  - **email**: The email of the user as a string.\n\nCreate a new user. You need server access level *Administrate* in order to execute this REST call.\n\n",
        "operationId": "CreateUser",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_create"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the user can be added by the server.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing from the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "409": {
            "description": "Returned if a user with the same name already exists.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/user/": {
      "get": {
        "tags": [
          "Users"
        ],
        "summary": "List available Users",
        "description": "\n\nFetches data about all users.  You need the *Administrate* server access level in order to execute this REST call.  Otherwise, you will only get information about yourself.\n\nThe call will return a JSON object with at least the following attributes on success:\n\n- *user*: The name of the user as a string.\n- *active*: An optional flag that specifies whether the user is active.\n- *extra*: An optional JSON object with arbitrary extra data about the user.\n\n\n",
        "operationId": "ListAvailableUsers",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The users that were found.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/user/{user}": {
      "get": {
        "tags": [
          "Users"
        ],
        "summary": "Fetch User",
        "description": "Fetches data about the specified user. You can fetch information about yourself or you need the *Administrate* server access level in order to execute this REST call.\n",
        "operationId": "FetchUser",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The user was found.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "The user with the specified name does not exist.\n\n",
            "content": {}
          }
        }
      },
      "put": {
        "tags": [
          "Users"
        ],
        "summary": "Replace User",
        "description": "\nA JSON object with these properties is required:\n\n  - **passwd**: The user password as a string. Specifying a password is mandatory.\n  - **active**: An optional flag that specifies whether the user is active.  If not specified, this will default to true\n  - **extra**: An optional JSON object with arbitrary extra data about the user.\n\nReplaces the data of an existing user. The name of an existing user must be specified in *user*. You need server access level *Administrate* in order to execute this REST call. Additionally, a user can change his/her own data.\n\n",
        "operationId": "ReplaceUser",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_replace"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the user data can be replaced by the server.\n\n",
            "content": {}
          },
          "400": {
            "description": "The JSON representation is malformed or mandatory data is missing from the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "The specified user does not exist.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "Users"
        ],
        "summary": "Remove User",
        "description": "\nRemoves an existing user, identified by *user*.  You need *Administrate* for the server access level in order to execute this REST call.\n\n",
        "operationId": "RemoveUser",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Returned if the user was removed by the server.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "The specified user does not exist.\n\n",
            "content": {}
          }
        }
      },
      "patch": {
        "tags": [
          "Users"
        ],
        "summary": "Modify User.",
        "description": "\nA JSON object with these properties is required:\n\n  - **passwd**: The user password as a string. Specifying a password is mandatory, but the empty string is allowed for passwords\n  - **active**: An optional flag that specifies whether the user is active.  If not specified, this will default to true\n  - **extra**: An optional JSON object with arbitrary extra data about the user.\n\nPartially updates the data of an existing user. The name of an existing user must be specified in *user*. You need server access level *Administrate* in order to execute this REST call. Additionally, a user can change his/her own data.\n\n",
        "operationId": "ModifyUser",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_modify"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the user data can be replaced by the server.\n\n",
            "content": {}
          },
          "400": {
            "description": "The JSON representation is malformed or mandatory data is missing from the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "The specified user does not exist.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/user/{user}/database": {
      "get": {
        "tags": [
          "Users"
        ],
        "summary": "List the accessible databases for a user.",
        "description": "\nFetch the list of databases available to the specified *user*. You need *Administrate* for the server access level in order to execute this REST call.\n\nThe call will return a JSON object with the per-database access privileges for the specified user. The *result* object will contain the databases names as object keys, and the associated privileges for the database as values.\n\nIn case you specified *full*, the result will contain the permissionsfor the databases as well as the permissions for the collections and streams.\n\n\n",
        "operationId": "ListTheAccessibleDatabasesForAUser",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user for which you want to query the databases.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "full",
            "in": "query",
            "description": "Return the full set of access levels for all databases and all collections.\n\n",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the list of available databases can be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the access privileges are not right etc.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/user/{user}/database/{dbname}": {
      "get": {
        "tags": [
          "Users"
        ],
        "summary": "Get the database access level.",
        "description": "\nFetch the database access level for a specific database.\n\n\n",
        "operationId": "GetTheDatabaseAccessLevel",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user for which you want to query the databases.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database to query.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the access level can be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the access privileges are not right etc.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        }
      },
      "put": {
        "tags": [
          "Users"
        ],
        "summary": "Set the database access level",
        "description": "\nA JSON object with these properties is required:\n\n  - **grant**: Use \"rw\" to set the database access level to *Administrate* .\n   Use \"ro\" to set the database access level to *Access*.\n   Use \"none\" to set the database access level to *No access*.\n\nSets the database access levels for the database *dbname* of user *user*. You need the *Administrate* server access level in order to execute this REST call.\n\n\n",
        "operationId": "SetTheDatabaseAccessLevel",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_grant_database"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the access level was changed successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing\nfrom the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "Users"
        ],
        "summary": "Clear the database access level",
        "description": "\nClears the database access level for the database *dbname* of user *user*. As consequence the default database access level is used. If there is no defined default database access level, it defaults to *No access*. You need permission to the *_system* database in order to execute this REST call.\n\n",
        "operationId": "ClearTheDatabaseAccessLevel",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Returned if the access permissions were changed successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing\nfrom the request.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/user/{user}/database/{dbname}/collection": {
      "get": {
        "tags": [
          "Users"
        ],
        "summary": "Get the specific collection access level",
        "description": "\nFetch the list of collections access level for a specific *user*\n\n If access level for collection is not set then default(\"&#42;\") access level will be use. If default(\"&#42;\") access level is also not set then database access level will be use. \n\n\n",
        "operationId": "GetTheAllCollectionAccessLevel",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user for which you want to query the databases.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database to query.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "full",
            "in": "query",
            "description": "Return the full set of access levels for all collections.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the access level can be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the access privileges are not right etc.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/user/{user}/database/{dbname}/collection/{collection}": {
      "get": {
        "tags": [
          "Users"
        ],
        "summary": "Get the specific collection access level",
        "description": "\nReturns the collection access level for a specific collection\n\n If access level for collection is not set then default(\"&#42;\") access level will be use. If default(\"&#42;\") access level is also not set then database access level will be use.\n\n",
        "operationId": "GetTheSpecificCollectionAccessLevel",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user for which you want to query the databases.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database to query.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the access level can be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the access privileges are not right etc.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        }
      },
      "put": {
        "tags": [
          "Users"
        ],
        "summary": "Set the collection access level",
        "description": "\nA JSON object with these properties is required:\n\n  - **grant**: Use \"rw\" to set the collection level access to *Read/Write*. Use \"ro\" to set the collection level access to  *Read Only*. Use \"none\" to set the collection level access to *No access*.\n\n - **collection**: Use \"&#42;\" to set default access level for all collections.\n\n If access level for collection is not set then default(\"&#42;\") access level will be use. If default(\"&#42;\") access level is also not set then database access level will be use.\n\nSets the collection access level for the *collection* in the database *dbname* for user *user*. You need the *Administrate* server access level in order to execute this REST call.\n\n",
        "operationId": "SetTheCollectionAccessLevel",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "*"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_grant_collection"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the access permissions were changed successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing\nfrom the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "Users"
        ],
        "summary": "Clear the collection access level.",
        "description": "\n\nClears the collection access level for the collection *collection* in the database *dbname* of user *user*.  As consequence the default collection access level is used. If there is no defined default collection access level, it defaults to *No access*.  You need permissions to the *_system* database in order to execute this REST call.\n\n",
        "operationId": "ClearTheCollectionAccessLevel",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Returned if the access permissions were changed successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if there is an error.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/user/{user}/database/{dbname}/stream": {
      "get": {
        "tags": [
          "Users"
        ],
        "summary": "List the accessible streams",
        "description": "\nFetch the list of streams available to the specified *user*. You need *Administrate* for the server access level in order to execute this REST call.\n\nThe call will return a JSON object with the per-stream access privileges for the specified user. The *result* object will contain the stream names as object keys, and the associated privileges for the stream as values.\n\nIf access level for stream is not set then default(\"&#42;\") access level will be use. If default(\"&#42;\") access level is also not set then database access level will be use.\n\n\n",
        "operationId": "ListTheAccessibleStreamsForAUser",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user for which you want to query the streams.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "full",
            "in": "query",
            "description": "Return the full set of access levels for all streams.\n\n",
            "schema": {
              "type": "boolean",
              "default": false
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the list of available streams can be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the access privileges are not right etc.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/user/{user}/database/{dbname}/stream/{stream}": {
      "get": {
        "tags": [
          "Users"
        ],
        "summary": "Get the stream access level",
        "description": "\nFetch the stream access level for a specific stream.\n\n\n",
        "operationId": "GetTheStreamAccessLevel",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user for which you want to query the streams.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "stream",
            "in": "path",
            "description": "The name of the stream to query.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the access level can be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the access privileges are not right etc.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        }
      },
      "put": {
        "tags": [
          "Users"
        ],
        "summary": "Set the stream access level",
        "description": "\nA JSON object with these properties is required:\n\n  - **grant**: Use \"ro\" to set the stream access level to Subscribe.\n   Use \"wo\" to set the stream access level to Publish.\n   Use \"rw\" to set the stream access level to Publish and Subscribe.\n   Use \"none\" to set the stream access level to *No access*.\n\n - **stream**: Use \"&#42;\" to set default access level for all streams.\n\nIf access level for stream is not set then default(\"&#42;\") access level will be use. If default(\"&#42;\") access level is also not set then database access level will be use.\n\nUse Sets the stream access levels for the *stream* of api key with *keyid*. You need the *Administrate* server access level in order to execute this REST call.\n\n\n",
        "operationId": "SetTheStreamAccessLevel",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "stream",
            "in": "path",
            "description": "The name of the stream.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "*"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_grant_database"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the access level was changed successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing\nfrom the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "Users"
        ],
        "summary": "Clear the stream access level.",
        "description": "\nClears the stream access level for the *stream* of user *user*. As consequence the default stream access level is used. If there is no defined default stream access level, it defaults to *No access*.\n\n",
        "operationId": "ClearTheStreamAccessLevel",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "dbname",
            "in": "path",
            "description": "The name of the database.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "stream",
            "in": "path",
            "description": "The name of the stream.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Returned if the access permissions were changed successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing\nfrom the request.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/user/{user}/billing": {
      "get": {
        "tags": [
          "Users"
        ],
        "summary": "Get the billing access level",
        "description": "\nFetch the billing access level.\n\n\n",
        "operationId": "GetTheBillingAccessLevel",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user for which you want to query the billing.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the access level can be returned.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the access privileges are not right etc.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        }
      },
      "put": {
        "tags": [
          "Users"
        ],
        "summary": "Set the billing access level.",
        "description": "\nA JSON object with these properties is required:\n\n  - **grant**: Use \"rw\" to set the billing access level to *Administrate*.\n   Use \"ro\" to set the billing access level to *Access*.\n   Use \"none\" to set the billing access level to *No access*.\n\nSets the billing access levels for user *user*. You need the *Administrate* server access level in order to execute this REST call.\n\n\n",
        "operationId": "SetTheBillingAccessLevel",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/user_grant_database"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the access level was changed successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing\nfrom the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "Users"
        ],
        "summary": "Clear the billing access level",
        "description": "\nClears the billing access level of user *user*.\n\n",
        "operationId": "ClearTheBillingAccessLevel",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "user",
            "in": "path",
            "description": "The name of the user.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Returned if the access permissions were changed successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing\nfrom the request.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_api/plan": {
      "get": {
        "tags": [
          "Billing"
        ],
        "summary": "Return list of plans",
        "description": "Return a list of plans in the system. You need to be the tenant admin in order to execute this REST call.\n\n",
        "operationId": "ReturnListOfPlans",
        "responses": {
          "200": {
            "description": "Returned if the call succeeded.\n",
            "content": {}
          }
        },
        "x-hints": ""
      },
      "post": {
        "tags": [
          "Billing"
        ],
        "summary": "Create Plan (requires superuser privileges)",
        "description": "\n**A JSON object with these properties is required:**\n\n - **name**: The plan name as a string. This is mandatory.\n - **planId**: The plan Id as a string. This is mandatory.\n - **description**: The description of the plan as a string.\n - **featureGates**: A list of string containing the enabled feature gates for this plan. This is mandatory.\n - **attribution**: The plan attribution.\n - **label**: The display label as a string.\n - **isBundle**: The bundle true/false. Default is false.\n - **metadata**: Metadata of the plan, having set of key-value pairs.\n - **metrics** : List of metrices applicable for this plan.\n - **active**: A mandatoy flag that specifies whether the plan is active.\n - **demo**: An optional flag that specifies whether the plan is a demo plan or not. \n\nCreate a new Plan. You need server access level *Administrate* in order to execute this REST call.\n\n",
        "operationId": "CreatePlan(requiresSuperuserPrivileges)",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/plan_create"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the plan can be added by the server.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/plan_create"
                }
              }
            }
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing from the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "409": {
            "description": "Returned if a plan with the same name already exists.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_api/plan/{name}": {
      "get": {
        "tags": [
          "Billing"
        ],
        "summary": "List details of the plan",
        "description": "\nFetches data about the given plan. The call will return a JSON object with the plan details.\n\n",
        "operationId": "ListDetailsOfPlan",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "The plan name for whom we want to fetch info.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The details for the given plan. \n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/plan_create"
                }
              }
            }
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        }
      },
      "delete": {
        "tags": [
          "Billing"
        ],
        "summary": "Remove Plan (requires superuser privileges)",
        "description": "Removes an existing plan, identified by *name*.  You need *Administrate* for the server access level in order to execute this REST call.\n\n",
        "operationId": "RemovePlan(requiresSuperuserPrivileges)",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "The plan name to delete, as a string.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Returned if the plan was removed by the server\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "The specified plan does not exist.\n\n",
            "content": {}
          }
        }
      },
      "patch": {
        "tags": [
          "Billing"
        ],
        "summary": "Modify Plan",
        "description": "\n**A JSON object with these properties is required:**\n\n  - **name**: The plan name as a string.\n - **planId**: The plan Id as a string.\n - **description**: The description of the plan as a string.\n - **featureGates**: A list of string containing the enabled feature gates for this plan.\n - **attribution**: The plan attribution.\n - **label**: The display label as a string.\n - **isBundle**: The bundle true/false.\n - **metadata**: The plan metadata.\n - **active**: An flag that specifies whether the plan is active. \n\nModify a Plan. You need server access level *Administrate* in order to execute this REST call.\n\n",
        "operationId": "ModifyPlan(requiresSuperuserPrivileges)",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "description": "The name of the plan to modify.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/plan_create"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the plan data can be replaced by the server.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/plan_create"
                }
              }
            }
          },
          "400": {
            "description": "The JSON representation is malformed or mandatory data is missing from the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "The specified plan does not exist.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_api/plan/upgrade": {
      "post": {
        "tags": [
          "Billing"
        ],
        "summary": "Upgrade tenant plan",
        "description": "Upgrade the plan for specified tenant. If tenant name is not specified, then tenant who is invoking API will be used to upgrade plan.\n\n **A JSON object with these properties is required:**\n\n - **attribution**: Attribution of the plan. e.g. 'macrometa'.\n - **plan**: Name of the plan e.g. 'DOCS'.\n - **tenant**: Name of the tenant. This is an optional field.",
        "operationId": "UpgradeTenantPlan",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/update_tenant_plan"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the plan is upgraded successfully.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/tenant_upgrade_plan_example_rc_200"
                }
              }
            }
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing from the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if user is not authorized to perform an operation.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_api/plan/downgrade": {
      "post": {
        "tags": [
          "Billing"
        ],
        "summary": "Downgrade tenant plan",
        "description": "Downgrade the plan for specified tenant. If tenant name is not specified\nthe tenant who is invoking API will be used to upgrade plan.\n\n **A JSON object with these properties is required:**\n\n - **attribution**: Attribution of the plan. e.g. 'macrometa'.\n - **plan**: Name of the plan e.g. 'Docs'.\n - **tenant**: Name of the tenant. This is an optional field.\n\nYou need to be the main system tenant admin *`_mm`* to execute this REST call. ",
        "operationId": "DowngradeTenantPlan",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/update_tenant_plan"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if the plan is downgraded successfully.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/tenant_upgrade_plan_example_rc_200"
                }
              }
            }
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing from the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if user is not authorized to perform an operation.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_api/billing/customer": {
      "get": {
        "tags": [
          "Billing"
        ],
        "summary": "Get customer details",
        "description": "Get customer details (contact + plan + paymentsettings) for given tenant\n\n- **tenant**: Tenant ID.",
        "operationId": "GetCustomer",
        "parameters": [
          {
            "name": "tenant",
            "in": "header",
            "description": "Tenant ID\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "502": {
            "description": "Returned if an error related to retreiving customer was encountered.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          }
        }
      }
    },
    "/_api/billing/contact": {
      "put": {
        "tags": [
          "Billing"
        ],
        "summary": "Update contact details.",
        "description": "Update contact details for given tenant\n - **firstname**: firstname\n - **lastname**: lastname\n - **company**: company name\n - **job**: job or profession of user\n - **email**: email id\n - **phone**: phone number\n - **line1**: address line1 \n - **line2**: address line 2\n - **city**: city\n - **state**: state \n - **country**: Two-letter country code (ISO 3166-1 alpha-2).\n - **zipcode**: zip code\n \n\n",
        "operationId": "UpdateContactDetails",
        "parameters": [
          {
            "name": "tenant",
            "in": "header",
            "description": "Tenant ID\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Contact_Update"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format or validation errors.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "500": {
            "description": "Returned if the request failed due to internal server error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_api/billing/paymentsettings": {
      "get": {
        "tags": [
          "Billing"
        ],
        "summary": "Get payment settings.",
        "description": "Get payment settings for given tenant\n\n- **tenant**: Tenant ID.",
        "operationId": "GetPaymentSettings",
        "parameters": [
          {
            "name": "tenant",
            "in": "header",
            "description": "Tenant ID.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "500": {
            "description": "Returned if any internal server error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "502": {
            "description": "Returned if an error related to retreiving customer was encountered.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Billing"
        ],
        "summary": "Update payment settings",
        "description": "Update payment settings for given tenant\n - **name**: name on card\n - **number**: card number\n - **month**: month of expiry\n - **year**: year of expiry\n - **cvv**: cvv number on card.\n\n",
        "operationId": "UpdatePaymentSettings",
        "parameters": [
          {
            "name": "tenant",
            "in": "header",
            "description": "Tenant ID\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Payment_Update"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format or validation errors.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "500": {
            "description": "Returned if the request failed due to internal server error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_api/billing/payments": {
      "get": {
        "tags": [
          "Billing"
        ],
        "summary": "Get all payments for given tenant.",
        "description": "Get all payments for given tenant.\n",
        "operationId": "GetPayments",
        "parameters": [
          {
            "name": "tenant",
            "in": "header",
            "description": "Tenant name.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "month",
            "in": "query",
            "description": "Month.\n",
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "502": {
            "description": "Returned if an error related to retreiving invoice was encountered.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          }
        }
      }
    },
    "/_api/billing/invoices": {
      "get": {
        "tags": [
          "Billing"
        ],
        "summary": "Get all invoices for given tenant",
        "description": "Get all invoices for given tenant.\n",
        "operationId": "GetAccountUsage",
        "parameters": [
          {
            "name": "tenant",
            "in": "header",
            "description": "Tenant name.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "month",
            "in": "query",
            "description": "Month\n",
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "502": {
            "description": "Returned if an error related to retreiving invoice was encountered. ",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          }
        }
      }
    },
    "/_api/billing/invoice/current": {
      "get": {
        "tags": [
          "Billing"
        ],
        "summary": "Get current monthly invoice for given tenant.",
        "description": "Get invoice for current month fo given tenant.\n",
        "operationId": "GetCurrentMonthInvoice",
        "parameters": [
          {
            "name": "tenant",
            "in": "header",
            "description": "Tenant name.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "502": {
            "description": "Returned if an error related to retreiving invoice was encountered.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          }
        }
      }
    },
    "/_api/billing/invoices/{year}/{month}": {
      "get": {
        "tags": [
          "Billing"
        ],
        "summary": "Get Invoice for given tenant, year and month.",
        "description": "Get invoices for given tenant, year and month.\n",
        "operationId": "GetInvoiceForMonthYear",
        "parameters": [
          {
            "name": "tenant",
            "in": "header",
            "description": "Tenant name.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "year",
            "in": "path",
            "description": "Year\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "month",
            "in": "path",
            "description": "Month\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "502": {
            "description": "Returned if an error related to retreiving invoice was encountered.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          }
        }
      }
    },
    "/_api/billing/usage": {
      "get": {
        "tags": [
          "Billing"
        ],
        "summary": "Get current monthly usage",
        "description": "Get current usage for given tenant.\n",
        "operationId": "GetAccountCurrentUsage",
        "parameters": [
          {
            "name": "tenant",
            "in": "header",
            "description": "Tenant name.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "400": {
            "description": "Returned if the request doesn't have the expected format.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          },
          "502": {
            "description": "Returned if an error related to retreiving invoice was encountered.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Response"
                }
              }
            }
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/export/{collection}": {
      "post": {
        "tags": [
          "Import Export"
        ],
        "summary": "Export collection data",
        "description": "Return a list of documents in the specified collection.\nA JSON object with these properties is required:\n\n - **query** - C8DB query. Optional field. By deffault all documets are returned. \n\n",
        "operationId": "ExportCollectionData",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/api_export"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "is returned if the result list can be created by the server.\n\n",
            "content": {}
          },
          "400": {
            "description": "is returned if the JSON representation is malformed.\n\n",
            "content": {}
          },
          "401": {
            "description": "If user is not authorized to perform an operation\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/import/{collection}": {
      "post": {
        "tags": [
          "Import Export"
        ],
        "summary": "Import collection data",
        "description": "Create documents in the collection identified by collection parameter.\n - **data** should be an array of json documents. Each document is interpreted separately.\n - **details** if *true* extra information for errors and unprocessed documents will be returned in the result. \n\n",
        "operationId": "ImportCollectionData",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          },
          {
            "name": "collection",
            "in": "path",
            "description": "The name of the collection.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/api_import"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "is returned if the result list can be created by the server.\n\n",
            "content": {}
          },
          "400": {
            "description": "is returned if the JSON representation is malformed.\n\n",
            "content": {}
          },
          "401": {
            "description": "If user is not authorized to perform an operation\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/datacenter/all": {
      "get": {
        "tags": [
          "Data Centers"
        ],
        "summary": "Return list of all Edge Locations",
        "description": "\nReturn a list of all Edge Locations (AKA Datacenters) deployed in the Macrometa Fabric.\n\nThe call will return a JSON object with the list of available Edge Locations, with details of each of them.\n\n",
        "operationId": "ReturnListOfAllEdgeLocations",
        "responses": {
          "200": {
            "description": "Returned if the call succeeded.\n\n",
            "content": {}
          }
        }
      }
    },
    "/datacenter/local": {
      "get": {
        "tags": [
          "Data Centers"
        ],
        "summary": "List details of Local Edge Location",
        "description": "\nFetches data about the local Edge Location specific to this Datacenter/Location.\n\nThe call will return a JSON object with the Edge Location details.\n\n",
        "operationId": "ListDetailsOfLocalEdgeLocation",
        "responses": {
          "200": {
            "description": "Returned if the call succeeded.\n",
            "content": {}
          }
        }
      }
    },
    "/datacenter/{dc-name}": {
      "get": {
        "tags": [
          "Data Centers"
        ],
        "summary": "List details of specified Edge Location",
        "description": "\nFetches data about the specified Edge Location.\n\nThe call will return a JSON object with the Edge Location details.\n\n",
        "operationId": "ListDetailsOfSpecifiedEdgeLocation",
        "parameters": [
          {
            "name": "dc-name",
            "in": "path",
            "description": "The Datacenter name for which you want details.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the call succeeded.\n\n",
            "content": {}
          }
        }
      }
    },
    "/datacenter/{location}/{status}": {
      "put": {
        "tags": [
          "Data Centers"
        ],
        "summary": "Change spot capability of an Edge Location.",
        "description": "Change whether an edge location (Datacenter) is capable of being on-spot.\n\n",
        "operationId": "ChangeSpotCapabilityOfAnEdgeLocation",
        "parameters": [
          {
            "name": "location",
            "in": "path",
            "description": "The target edge location.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "status",
            "in": "path",
            "description": "Whether the edge location is capable of being on-spot.\n\n",
            "required": true,
            "schema": {
              "type": "boolean",
              "format": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The details for the local Edge Location.\n\n",
            "content": {}
          }
        }
      }
    },
    "/datacenter/_tenant/{tenant-name}": {
      "get": {
        "tags": [
          "Data Centers"
        ],
        "summary": "List datacenter details for specified tenant.",
        "description": "\nFetches data about the Edge Locations specific to this tenant.\n\nThe call will return a JSON object with the Edge Location details.\n\n",
        "operationId": "ListEdgeLocation(akaDatacenter)DetailsForSpecifiedTenant",
        "parameters": [
          {
            "name": "tenant-name",
            "in": "path",
            "description": "The Tenant for which you want details. You must have permissions to view the tenant information.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the call succeeded.\n\n",
            "content": {}
          },
          "400": {
            "description": "There was an error fetching the tenant information. Check your parameter inputs.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the tenant's system\ndatabase.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        }
      }
    },
    "/tenants": {
      "get": {
        "tags": [
          "Administration"
        ],
        "summary": "Return list of tenants.",
        "description": "\nReturn a list of tenants in the system. You need to be the main system tenant admin *_mm.root* in order to execute this REST call.\n\n",
        "operationId": "ReturnListOfTenants",
        "responses": {
          "200": {
            "description": "Returned if the call succeeded.\n\n",
            "content": {}
          }
        }
      }
    },
    "/tenant": {
      "post": {
        "tags": [
          "Administration"
        ],
        "summary": "Create Tenant (requires superuser privileges)",
        "description": "\n**A JSON object with these properties is required:**\n\n  - **name**: The name of the tenant as a string. This is mandatory.\n   - **email**: The email address of the tenant as a string. This is non mandatory.\n   - **passwd**: The user password as a string. If no password is specified, the empty string will be used.\n  - **plan**: The name of the tenant plan as a string. This is mandatory.\n  - **attribution**: The attribution of the tenant as a string. This is mandatory.\n   - **dcList**: A comma-separated string containing the datacenter names on which this tenant\n   is to be created. If an empty string is passed in, the tenant is assumed to\n   be global to the federation and will be created on all current datacenters in\n   the federation.\n    - **metadata**: The metadata of the tenant as a JSON object. This is non mandotory\n - **contact**: Contact details of the user account. An optional JSON object with detailed contact information of the user.\nThis is field is non mandotory for **FREE**, **ENTERPRISE** and other **Demo** plans\n\nCreate a new tenant. You need server access level *Administrate* in order to execute this REST call.\n\n",
        "operationId": "CreateTenant(requiresSuperuserPrivileges)",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/tenant_create"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if the tenant can be added by the server.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing from the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "409": {
            "description": "Returned if a tenant with the same name already exists.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/tenant/{tenant}": {
      "get": {
        "tags": [
          "Administration"
        ],
        "summary": "List details of the tenant",
        "description": "\nFetches data about the given tenant.  Only super admin can execute this REST call. The call will return a JSON object with the tenant details.\n\n",
        "operationId": "ListDetailsOfTenant",
        "parameters": [
          {
            "name": "tenant",
            "in": "path",
            "description": "The tenant name for whom we want to fetch info.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The details for the given tenant. \n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/get_tenant_example_rc_200"
                }
              }
            },
            "x-description-offset": 110
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          }
        }
      },
      "delete": {
        "tags": [
          "Administration"
        ],
        "summary": "Remove Tenant (requires superuser privileges)",
        "description": "\nRemoves an existing tenant, identified by *tenant-name*.  You need *Administrate* for the server access level in order to execute this REST call.\n\n",
        "operationId": "RemoveTenant(requiresSuperuserPrivileges)",
        "parameters": [
          {
            "name": "tenant",
            "in": "path",
            "description": "The tenant name to delete, as string. The main default system tenant *_mm* cannot be deleted.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Returned if the tenant was removed by the server\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "The specified tenant does not exist\n\n",
            "content": {}
          }
        }
      },
      "patch": {
        "tags": [
          "Administration"
        ],
        "summary": "Modify Tenant",
        "description": "\n**A JSON object with these properties is required:**\n\n  - **active**: Boolean flag for active status of objcet. This is non mandotory\n  - **status**: Status of tenant. This value ias added for future reference. This is non mandotory. **Valid values**: *`active, expired, delinquent, inactive`* \n  - **metadata**: The metadata of the tenant as a JSON object. This is non\nmandotory\n\n\n You need server access level *Administrate* in order to execute this REST call.\n\n",
        "operationId": "ModifyTenant",
        "parameters": [
          {
            "name": "tenant",
            "in": "path",
            "description": "The name of the tenant to modify.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/tenant_modify"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned, if the tenant data is successfully updated by the server.\n\n",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/tenant_modify_example_rc_200"
                }
              }
            }
          },
          "400": {
            "description": "The JSON representation is malformed or mandatory data is missing from the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "The specified tenant does not exist.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_api/limits/defaults": {
      "get": {
        "tags": [
          "Administration"
        ],
        "summary": "Returns the default limits for tenants",
        "description": "Returns the default limits for tenants.",
        "operationId": "GetDefaultTenantLimits",
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "401": {
            "description": "Access denied",
            "content": {}
          }
        }
      },
      "put": {
        "tags": [
          "Administration"
        ],
        "summary": "Sets the default tenant limits",
        "description": "Sets the default tenant limits.\nIf data fields are omitted, they will be set to c8db defined default values.",
        "operationId": "SetDefaultTenantLimits",
        "requestBody": {
          "description": "The new default values.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/set_default_limits_value"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "Invalid parameters",
            "content": {}
          },
          "401": {
            "description": "Access denied",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "Administration"
        ],
        "summary": "Resets default tenant limits",
        "description": "Resets default tenant limits.",
        "operationId": "ResetDefaultTenantLimits",
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "401": {
            "description": "Access denied",
            "content": {}
          }
        }
      },
      "patch": {
        "tags": [
          "Administration"
        ],
        "summary": "Updates default tenant limits",
        "description": "Updates default tenant limits. Omitted data fields will keep their current value.",
        "operationId": "UpdateDefaultTenantLimits",
        "requestBody": {
          "description": "The new default values.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/set_default_limits_value"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "Invalid parameters",
            "content": {}
          },
          "401": {
            "description": "Access denied",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_api/limits/enable": {
      "get": {
        "tags": [
          "Administration"
        ],
        "summary": "Get the value of enable limits flag",
        "description": "The flag indication whether limits are enabled for all tenants. The default value is *true*. If set to *false*, the configured limits will not be applicable.",
        "operationId": "GetEnableLimits",
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "401": {
            "description": "Access denied",
            "content": {}
          }
        }
      },
      "post": {
        "tags": [
          "Administration"
        ],
        "summary": "Sets the value of  enable limits flag.",
        "description": "Sets the value of enable limits flag. Default value of this flag is *true*",
        "operationId": "SetEnableLimits",
        "parameters": [
          {
            "name": "value",
            "in": "query",
            "description": "The flag indication whether limits are enabled for all tenants. The default value is *true*. If set to *false*, the configured limits will not be applicable.",
            "required": true,
            "schema": {
              "type": "boolean",
              "default": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "Invalid parameters",
            "content": {}
          },
          "401": {
            "description": "Access denied",
            "content": {}
          }
        }
      }
    },
    "/_tenant/{tenant}/_api/limits": {
      "get": {
        "tags": [
          "Administration"
        ],
        "summary": "Returns the limits for a tenant.",
        "description": "Returns the limits for a tenant.",
        "operationId": "GetTenantLimits",
        "parameters": [
          {
            "name": "tenant",
            "in": "path",
            "description": "The name of the relevant tenant.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "401": {
            "description": "Access denied",
            "content": {}
          }
        }
      },
      "put": {
        "tags": [
          "Administration"
        ],
        "summary": "Sets the tenant limits",
        "description": "Sets the tenant limits.\nIf data fields are omitted, they will be set to 'null', and c8db global limits applies.",
        "operationId": "SetTenantLimits",
        "parameters": [
          {
            "name": "tenant",
            "in": "path",
            "description": "The name of the relevant tenant.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "description": "The new default values.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/tenant_limits_value"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "Invalid parameters",
            "content": {}
          },
          "401": {
            "description": "Access denied",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "Administration"
        ],
        "summary": "Resets tenant limits",
        "description": "Resets tenant limits.",
        "operationId": "ResetTenantLimits",
        "parameters": [
          {
            "name": "tenant",
            "in": "path",
            "description": "The name of the relevant tenant.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "401": {
            "description": "Access denied",
            "content": {}
          }
        }
      },
      "patch": {
        "tags": [
          "Administration"
        ],
        "summary": "Updates tenant limit",
        "description": "Updates tenant limits. Omitted data fields will keep their current value.",
        "operationId": "UpdateTenantLimits",
        "parameters": [
          {
            "name": "tenant",
            "in": "path",
            "description": "The name of the relevant tenant.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "description": "The new default values.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/tenant_limits_value"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "Invalid parameters",
            "content": {}
          },
          "401": {
            "description": "Access denied",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_tenant/{tenant}/_fabric/_system/features": {
      "get": {
        "tags": [
          "Administration"
        ],
        "summary": "Lookup features for a tenant.",
        "description": "\n\nLooks up features for a given tenant.\n\n",
        "operationId": "LookupFeaturesForATenant",
        "parameters": [
          {
            "name": "tenant",
            "in": "path",
            "description": "The name of the tenant for which to lookup the features.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of features with avaialbility flag.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/features_list_with_availability_flag_example"
                }
              }
            }
          },
          "400": {
            "description": "Invalid parameters\n\n\n\n",
            "content": {}
          }
        },
        "x-hints": ""
      },
      "put": {
        "tags": [
          "Administration"
        ],
        "summary": "Update features for a tenant.",
        "description": "Updates the features for the specified tenant.\n\n",
        "operationId": "UpdateFeaturesForSpecifiedTenant",
        "parameters": [
          {
            "name": "tenant",
            "in": "path",
            "description": "The name of the tenant for which to update the features.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "description": "The features to update (each value must be either true or false).\n\n",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/features_list_with_availability_flag_example"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if features are updated successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if invalid parameters are provided.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "post": {
        "tags": [
          "Administration"
        ],
        "summary": "Update features for a tenant.",
        "description": "\n\nUpdates the features for the specified tenant.\n\n",
        "operationId": "UpdateFeaturesForATenant",
        "parameters": [
          {
            "name": "tenant",
            "in": "path",
            "description": "The name of the tenant for which to update the features.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "requestBody": {
          "description": "The features to update (each value must be either true or false).\n\n",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/features_list_with_availability_flag_example"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returns if features updated successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returns if invalid parameters are provided.\n\n\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "Administration"
        ],
        "summary": "Reset features for a tenant",
        "description": "\n\nReset features for a given tenant to default values.\n\n",
        "operationId": "ResetFeaturesForATenant",
        "parameters": [
          {
            "name": "tenant",
            "in": "path",
            "description": "The name of the tenant for which to reset the features.\n\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success\n\n",
            "content": {}
          },
          "400": {
            "description": "Invalid parameters\n\n\n",
            "content": {}
          }
        }
      }
    },
    "/tenant/{tenant}/datacenter/{datacenter}": {
      "put": {
        "tags": [
          "Administration"
        ],
        "summary": "Reconcile tenant from given datacenter. (Requires superadmin access).",
        "description": "Reconcie datacenter of a given tenant. Only super admin can execute this REST call.",
        "operationId": "ReconcileTenantDatacenter(superuser)",
        "parameters": [
          {
            "name": "tenant",
            "in": "path",
            "description": "The tenant to be reconciled. You cannot modify the system tenants `_mm`, `guest`, `demo`.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "datacenter",
            "in": "path",
            "description": "The datacenter on which to perform reconciling.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force syncing fabric data.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "remoteDc",
            "in": "query",
            "description": "Name of remote datacenter to sync fabric data from (leave empty to use default).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "excludeCollections",
            "in": "query",
            "description": "Collections to be excluded from syncing (comma-separated).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fabric",
            "in": "query",
            "description": "Fabric that needs to be reconciled.",
            "schema": {
              "type": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the tenant was reconciled by the server.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system*  database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "The specified tenant does not exist.\n\n",
            "content": {}
          },
          "500": {
            "description": "Internal server error\n\n",
            "content": {}
          }
        }
      },
      "post": {
        "tags": [
          "Administration"
        ],
        "summary": "Add datacenter to the tenant. (Requires superadmin access)",
        "description": "\nAdd new Datacenter to specified tenant. Only super admin can execute this REST call. \n\nThe tenant's internal system metadata will be updated with the new location. Only super admin execute this REST call.\n\nThe new datacenter will be added to `_system` fabric of the tenant. The new datacenter will not be added to the GeoFabrics of the tenant. \n\nWhile the new datacenter is being added to the tenant, it will `not` be available for normal operations in the new location until the tenant data sync in the new datacenter has been completed. \n\nAfter all the tenant data has been synced from the originating datacenter, the tenant will be available in that datacenter.\n\n",
        "operationId": "AddDatacentersToTenant(superuser)",
        "parameters": [
          {
            "name": "tenant",
            "in": "path",
            "description": "The tenant to which the datacenter will be added. You cannot modify the system tenants `_mm`, `guest`, `demo`.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "datacenter",
            "in": "path",
            "description": "Datacenter that needs to be added to the tenant.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "Force syncing fabric data.",
            "schema": {
              "type": "boolean",
              "default": false
            }
          },
          {
            "name": "remoteDc",
            "in": "query",
            "description": "Name of remote datacenter to sync fabric data from (leave empty to use default).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "excludeCollections",
            "in": "query",
            "description": "Collections to be excluded from syncing (comma-separated).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "fabric",
            "in": "query",
            "description": "Fabric to which the datacenter needs to be added.",
            "schema": {
              "type": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the tenant datacenters can be updated by the server.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the JSON representation is malformed or mandatory data is missing from the request.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system* database.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "The specified tenant does not exist.\n\n",
            "content": {}
          }
        }
      },
      "delete": {
        "tags": [
          "Administration"
        ],
        "summary": "Remove datacenter from the tenant. (Requires superadmin access).",
        "description": "Remove datacenter from a tenant. Only super admin can execute this REST call.",
        "operationId": "RemoveTenantDatacenter(superuser)",
        "parameters": [
          {
            "name": "tenant",
            "in": "path",
            "description": "The tenant to be modified. You cannot modify the system tenants `_mm`, `guest`, `demo`.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "datacenter",
            "in": "path",
            "description": "The datacenter to be removed.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "fabric",
            "in": "query",
            "description": "Fabric from which the datacenter needs to be removed.",
            "schema": {
              "type": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the tenant was removed by the server.\n\n",
            "content": {}
          },
          "401": {
            "description": "Returned if you have *No access* database access level to the *_system*\ndatabase.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if you have *No access* server access level.\n\n",
            "content": {}
          },
          "404": {
            "description": "Returned if the specified tenant does not exist.\n\n",
            "content": {}
          },
          "500": {
            "description": "Internal server error.\n\n",
            "content": {}
          }
        }
      }
    },
    "/tenant/{tenant}/spot/{datacenter}": {
      "put": {
        "tags": [
          "Administration"
        ],
        "summary": "Change Spot region for the tenant. (Requires superadmin access).",
        "description": "Updates the spot region for an existing GeoFabric to a specified spot region. The response is a JSON object with the attribute *result* set to *true*.",
        "operationId": "ChangeSpotRegion(requiresSuperuserPrivileges)",
        "parameters": [
          {
            "name": "tenant",
            "in": "path",
            "description": "The tenant to be modified.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "datacenter",
            "in": "path",
            "description": "The datacenter which will be the new spot region.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          },
          {
            "name": "fabric",
            "in": "query",
            "description": "Fabric that need to be updated.",
            "schema": {
              "type": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if the spot region was updated successfully.\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if the request parameters are invalid or if a GeoFabric with the specified name already exists.\n\n",
            "content": {}
          },
          "403": {
            "description": "Returned if the request was not executed in the *_system* fabric.\n\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/events": {
      "get": {
        "tags": [
          "Administration"
        ],
        "summary": "Lookup events for a tenant and fabric",
        "description": "Looks up events for a given tenant and fabric.\n",
        "operationId": "LookupEventsForATenantAndFabric",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The fabric name to use in the URL path for this API call. The main default system database is _system\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned if features lookup successful\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if invalid parameters are provided\n\n",
            "content": {}
          }
        }
      },
      "post": {
        "tags": [
          "Administration"
        ],
        "summary": "Create event",
        "description": "\nA JSON object with these properties is required:\n\n  - **status**: The activity status (OK/WARN/ERROR).\n  - **description**: Event description.\n  - **entityName**: The entity name of the event. Ex: name of collection; name of user etc\n  - **entityType**: The entity type of the event (COLLECTION/GRAPH/PIPELINE/AUTH/STREAM/GEOFABRIC).\n  - **details**: Additional activity info. Ex: error message.\n  - **action**: The activity of the event (CREATE/UPDATE/DELETE/EXECUTE/LOGIN).\n  - **attributes**:\n\nCreates a new event with a given params. The request must contain an object with the following attributes.\n\n",
        "operationId": "CreateEvent",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/event_create"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Returned if event created successfully\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned  if the body does not contain a valid JSON representation of an event.\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      },
      "delete": {
        "tags": [
          "Administration"
        ],
        "summary": "Delete event.",
        "description": "Deletes one or more events by _id.\n\n",
        "operationId": "DeleteEvent",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "requestBody": {
          "description": "A JSON array of strings (event _ids).\n\n",
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Returned if event deletion successful\n\n",
            "content": {}
          },
          "400": {
            "description": "Returned if invalid parameters are provided\n\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    },
    "/_fabric/{fabric}/_api/metrics/names": {
      "get": {
        "tags": [
          "Administration"
        ],
        "summary": "Get metrics names",
        "description": "Returns an array of all metrics names.\n\n",
        "operationId": "names",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returned  when operation is successful\n",
            "content": {}
          }
        }
      }
    },
    "/_fabric/{fabric}/_api/metrics/query": {
      "post": {
        "tags": [
          "Administration"
        ],
        "summary": "Query user metrics",
        "description": "\nA JSON object with these properties is required:\n\n  - **metrics** (string): Array of strings containing the metric names we want to receive\n  - **since**: unix timestamp in milliseconds of oldest entry we want to receive\n  - **limit**: number of results we want to receive\n  - **querytype**: \"list\" returns a list of all available metrics, \"get\" returns all the requested metrics, \"sum\" returns sum of all records for each of the requested metrics \n  - **GeoFabric**: GeoFabric name\n\n",
        "operationId": "query",
        "parameters": [
          {
            "name": "fabric",
            "in": "path",
            "description": "The name of the fabric.\n",
            "required": true,
            "schema": {
              "type": "string",
              "format": "string",
              "default": "_system"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/post_metrics_query"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "\n",
            "content": {}
          }
        },
        "x-codegen-request-body-name": "Json Request Body"
      }
    }
  },
  "components": {
    "schemas": {
      "Account_Create": {
        "required": [
          "tenant"
        ],
        "type": "object",
        "properties": {
          "tenant": {
            "type": "string",
            "description": "Tenant ID",
            "format": "string"
          },
          "plan": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "description": "Plan name",
                "format": "string"
              }
            },
            "description": "Plan types"
          }
        }
      },
      "set_default_limits_value": {
        "type": "object",
        "properties": {
          "maxDocumentSize": {
            "type": "integer",
            "description": "The maximum document size in bytes.\n\n",
            "format": "int64",
            "example": 409600
          },
          "maxDocumentsReturnedByQuery": {
            "type": "integer",
            "description": "The maximum documents returned by a query, or 0 to disable this limit.\nThe page size for the query will be equal to this value (if set), preventing c8db from creating a persistent cursor for queries.\n",
            "format": "int64",
            "example": 1000
          },
          "maxQueryExceutionTimeInMs": {
            "type": "integer",
            "description": "The maximum time allowed for a query to complete processing.\n\n",
            "format": "int64",
            "example": 10000
          },
          "maxQueryMemoryBytes": {
            "type": "integer",
            "description": "The maximum bytes of memory allowed to be used by a query during processing.\n\n",
            "format": "int64",
            "example": 268435456
          },
          "maxCollectionsPerFabric": {
            "type": "integer",
            "description": "The maximum number of collections per fabric a tenant can create. Use 0 to disable.\n\n",
            "format": "int64",
            "example": 10
          },
          "maxRequestsPerDay": {
            "type": "integer",
            "description": "The maximum number of API requests per day for a tenant, including UI requests to the APIs. Use 0 to disable. This only applies for tenants with the 'tenant.trial' property in _tenants set to 'true'. \n\n",
            "format": "int64",
            "example": 5000
          },
          "maxRequestPerMinute": {
            "type": "integer",
            "description": "Rate Limiting at the gateway proxy. The maximum number of requests per per minute for a tenant. This includes all http/https requests, for any component, coming from a regions LoadBalancer. If the value is 0, the rate limiting is disabled.\n\n",
            "format": "int64",
            "example": 60
          },
          "maxStoragePerRegion": {
            "type": "integer",
            "description": "The maximum storage (in bytes) allowed to be used by a tenant in a region. Use 0 to disable. Note that RocksDB may have a significant overhead, causing the disk usage to be much larger than the size of the documents owned by the tenant.\nThis only applies for tenants with the 'tenant.trial' property in _tenants set to 'true'.\n\n",
            "format": "int64",
            "example": 104857600
          }
        }
      },
      "tenant_limits_value": {
        "type": "object",
        "properties": {
          "maxDocumentSize": {
            "type": "integer",
            "description": "The maximum document size in bytes\nIf unset (null) the federation global limits applies.",
            "format": "int64"
          },
          "maxDocumentsReturnedByQuery": {
            "type": "integer",
            "description": "The maximum documents returned by a query, or 0 to disable this limit.\nThe page size for the query will be equal to this value (if set), preventing c8db from creating a persistent cursor for queries.\nIf unset (null) the federation global limits applies.",
            "format": "int64"
          },
          "maxQueryExceutionTimeInMs": {
            "type": "integer",
            "description": "The maximum time allowed for a query to complete processing.\nIf unset (null) the federation global limits applies.",
            "format": "int64"
          },
          "maxQueryMemoryBytes": {
            "type": "integer",
            "description": "The maximum bytes of memory allowed to be used by a query during processing.\nIf unset (null) the federation global limits applies.",
            "format": "int64"
          },
          "maxCollectionsPerFabric": {
            "type": "integer",
            "description": "The maximum number of collections per fabric a tenant can create.\nIf unset (null) the federation global limits applies.",
            "format": "int64"
          },
          "maxRequestsPerDay": {
            "type": "integer",
            "description": "The maximum number of API requests per day for a tenant, including UI requests to the APIs. Use 0 to disable. This only applies for tenants with the 'tenant.trial' property in _tenants set to 'true'.\nIf unset (null) the federation global limits applies.",
            "format": "int64"
          },
          "maxRequestPerMinute": {
            "type": "integer",
            "description": "Rate Limiting at the gateway proxy. The maximum number of requests per per minute for a tenant. This includes all http/https requests, for any component, coming from a regions LoadBalancer. If the value is 0, the rate limiting is disabled.\nIf unset (null) the federation global limits applies.\n\n",
            "format": "int64"
          },
          "maxStoragePerRegion": {
            "type": "integer",
            "description": "The maximum storage (in bytes) allowed to be used by a tenant in a region. Use 0 to disable. Note that RocksDB may have a significant overhead, causing the disk usage to be much larger than the size of the documents owned by the tenant.\nThis only applies for tenants with the 'tenant.trial' property in _tenants set to 'true'.\nIf unset (null) the federation global limits applies.",
            "format": "int64"
          }
        }
      },
      "set_enable_limits_flag": {
        "type": "object",
        "properties": {
          "value": {
            "type": "boolean",
            "description": "The flag value for enable limits. This value will be applicable for all tenants. This is a boolean field. Set this value to true, if limits need to be enabled, else set it to false to disable limits.",
            "format": "",
            "example": true
          }
        }
      },
      "rename_view": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The new name of the view.\n\n"
          }
        }
      },
      "post_api_view": {
        "required": [
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the view.\n\n"
          },
          "properties": {
            "$ref": "#/components/schemas/post_api_view_props"
          },
          "type": {
            "type": "string",
            "description": "The type of the view. must be equal to one of the supported C8DB view\ntypes.\n\n"
          }
        }
      },
      "post_api_view_fields": {
        "type": "object",
        "properties": {
          "field-name": {
            "type": "array",
            "description": "This is a recursive structure for the specific attribute path, potentially\ncontaining any of the following attributes:\n*analyzers*, *includeAllFields*, *trackListPositions*, *storeValues*\nAny attributes not specified are inherited from the parent.\n\n\n",
            "items": {
              "type": "object",
              "properties": {}
            }
          }
        },
        "description": "The field properties. If specified, then *properties* should be a JSON object\ncontaining the following attributes:\n\nThe field properties. If specified, then *properties* should be a JSON object\ncontaining the following attributes:\n\nThe field properties. If specified, then *properties* should be a JSON object\ncontaining the following attributes:\n\n"
      },
      "post_api_view_iresearch": {
        "required": [
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the view.\n\n"
          },
          "properties": {
            "$ref": "#/components/schemas/post_api_view_props"
          },
          "type": {
            "type": "string",
            "description": "The type of the view. must be equal to *\"search\"*.\n\n",
            "default": "search"
          }
        }
      },
      "post_api_view_link_props": {
        "type": "object",
        "properties": {
          "analyzers": {
            "type": "array",
            "description": "The list of analyzers to be used for indexing of string values\n(default: [\"identity\"]).\n\n\n",
            "items": {
              "type": "string"
            }
          },
          "fields": {
            "$ref": "#/components/schemas/post_api_view_fields"
          },
          "includeAllFields": {
            "type": "boolean",
            "description": "The flag determines whether or not to index all fields on a particular level of\ndepth (default: false).\n\n"
          },
          "storeValues": {
            "type": "string",
            "description": "How should the view track the attribute values, this setting allows for\nadditional value retrieval optimizations, one of:\n- *none*: Do not store values by the view\n- *id*: Store only information about value presence, to allow use of the EXISTS() function\n(default \"none\").\n\n\n"
          },
          "trackListPositions": {
            "type": "boolean",
            "description": "The flag determines whether or not values in a lists should be treated separate\n(default: false).\n\n"
          }
        },
        "description": "The link properties. If specified, then *properties* should be a JSON object\ncontaining the following attributes:\n\nThe link properties. If specified, then *properties* should be a JSON object\ncontaining the following attributes:\n\nThe link properties. If specified, then *properties* should be a JSON object\ncontaining the following attributes:\n\n"
      },
      "post_api_view_links": {
        "type": "object",
        "properties": {
          "[collection-name]": {
            "$ref": "#/components/schemas/post_api_view_link_props"
          }
        },
        "description": "The set of collection names associated with the properties.\n\n\nThe set of collection names associated with the properties.\n\n\nThe set of collection names associated with the properties.\n\n"
      },
      "post_api_view_props": {
        "type": "object",
        "properties": {
          "links": {
            "$ref": "#/components/schemas/post_api_view_links"
          }
        },
        "description": "The view properties. If specified, then *properties* should be a JSON object\ncontaining the attributes supported by the specific view type.\n\nThe view properties. If specified, then *properties* should be a JSON object\ncontaining the following attributes:\n\nThe view properties. If specified, then *properties* should be a JSON object\ncontaining the following attributes:\n\nThe view properties. If specified, then *properties* should be a JSON object\ncontaining the following attributes:\n\n"
      },
      "post_api_analyzer": {
        "required": [
          "name"
        ],
        "type": "object",
        "properties": {
          "features": {
            "type": "array",
            "description": "The set of features to set on the analyzer generated fields.\nThe default value is an empty array.\n\n",
            "items": {
              "type": "string"
            }
          },
          "name": {
            "type": "string",
            "description": "The analyzer name.\n\n"
          },
          "properties": {
            "type": "string",
            "description": "The properties used to configure the specified type.\nValue may be a string, an object or null.\nThe default value is *null*.\n\n"
          },
          "type": {
            "type": "string",
            "description": "The analyzer type.\n\n"
          }
        }
      },
      "Contact_Update": {
        "type": "object",
        "properties": {
          "firstname": {
            "type": "string",
            "description": "First Name",
            "format": "string"
          },
          "lastname": {
            "type": "string",
            "description": "Last Name",
            "format": "string"
          },
          "email": {
            "type": "string",
            "description": "Email id",
            "format": "string"
          },
          "phone": {
            "type": "string",
            "description": "Phone number",
            "format": "string"
          },
          "line1": {
            "type": "string",
            "description": "Address line 1",
            "format": "string"
          },
          "line2": {
            "type": "string",
            "description": "Address line 2",
            "format": "string"
          },
          "city": {
            "type": "string",
            "description": "City",
            "format": "string"
          },
          "state": {
            "type": "string",
            "description": "State",
            "format": "string"
          },
          "country": {
            "type": "string",
            "description": "Two-letter country code (ISO 3166-1 alpha-2).",
            "format": "string"
          },
          "zipcode": {
            "type": "string",
            "description": "Zip code",
            "format": "string"
          }
        }
      },
      "Plan_Update": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Plan name",
            "format": "string"
          },
          "subscription": {
            "type": "object",
            "properties": {
              "reads": {
                "type": "string",
                "description": "Reads item id from stripe.",
                "format": "string"
              },
              "write": {
                "type": "string",
                "description": "Write item id from stripe.",
                "format": "string"
              },
              "indexStorage": {
                "type": "string",
                "description": "Index storage item id from stripe.",
                "format": "string"
              },
              "dataStorage": {
                "type": "string",
                "description": "Data storage item id from stripe.",
                "format": "string"
              }
            },
            "description": "Subscription item details."
          }
        }
      },
      "Payment_Update": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name on card",
            "format": "string"
          },
          "number": {
            "type": "string",
            "description": "Card number",
            "format": "string"
          },
          "month": {
            "type": "string",
            "description": "Month of expiry",
            "format": "string"
          },
          "year": {
            "type": "string",
            "description": "Year of expiry",
            "format": "string"
          },
          "cvv": {
            "type": "string",
            "description": "CVV on card",
            "format": "string"
          },
          "email": {
            "type": "string",
            "description": "Email id",
            "format": "string"
          },
          "phone": {
            "type": "string",
            "description": "Phone number",
            "format": "string"
          },
          "billing": {
            "type": "object",
            "properties": {
              "line1": {
                "type": "string",
                "description": "Address line 1",
                "format": "string"
              },
              "line2": {
                "type": "string",
                "description": "Address line 2",
                "format": "string"
              },
              "city": {
                "type": "string",
                "description": "City",
                "format": "string"
              },
              "state": {
                "type": "string",
                "description": "State",
                "format": "string"
              },
              "country": {
                "type": "string",
                "description": "Two-letter country code (ISO 3166-1 alpha-2).",
                "format": "string"
              },
              "zipcode": {
                "type": "string",
                "description": "Zip code",
                "format": "string"
              }
            },
            "description": "Billing address for card"
          }
        }
      },
      "Response": {
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "Request status"
          },
          "error": {
            "type": "boolean",
            "description": "If there is any error, this will be true."
          },
          "message": {
            "type": "string",
            "description": "Message from server."
          },
          "data": {
            "type": "object",
            "properties": {},
            "description": "Data coming back from server in case of successful request."
          }
        }
      },
      "auth_token": {
        "required": [
          "password"
        ],
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "description": "The email of the user for whom we want the auth token.\n\n"
          },
          "password": {
            "type": "string",
            "description": "The user password as a string.\n\n"
          },
          "tenant": {
            "type": "string",
            "description": "The name of the tenant for whose user we want the auth token.\n\n"
          },
          "username": {
            "type": "string",
            "description": "The name of the user for whom we want the auth token.\n\n"
          }
        }
      },
      "key_value": {
        "required": [
          "_key",
          "value"
        ],
        "type": "object",
        "properties": {
          "_key": {
            "type": "string",
            "description": "Key"
          },
          "value": {
            "type": "string",
            "description": "Value"
          },
          "expireAt": {
            "type": "integer",
            "description": "Expiry time in UTC timestamp format."
          }
        }
      },
      "key_value_response": {
        "required": [
          "error",
          "code"
        ],
        "type": "object",
        "properties": {
          "error": {
            "type": "boolean",
            "description": "Flag if there is an error in response. Returns true in case of success. False in case of failure.",
            "default": false
          },
          "code": {
            "type": "integer",
            "description": "The response code for the error."
          },
          "name": {
            "type": "string",
            "description": "It shows name of the collection."
          }
        }
      },
      "key_value_response_error": {
        "required": [
          "error",
          "code"
        ],
        "type": "object",
        "properties": {
          "error": {
            "type": "boolean",
            "description": "Flag if there is an error in response. Returns true in case of success. False in case of failure."
          },
          "code": {
            "type": "integer",
            "description": "The response code for the error."
          },
          "name": {
            "type": "string",
            "description": "It shows name of the collection."
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error."
          },
          "errorNum": {
            "type": "integer",
            "description": "Error number returned from the database."
          }
        }
      },
      "key_value_array": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/key_value"
        }
      },
      "keys_array": {
        "type": "array",
        "items": {
          "type": "string",
          "format": "string"
        }
      },
      "GeoFabric_add_locations": {
        "required": [
          "dc"
        ],
        "type": "object",
        "properties": {
          "dc": {
            "type": "string",
            "description": "The datacenter to be added to the GeoFabric, as a string.\n\n"
          }
        }
      },
      "graph_traversal": {
        "required": [
          "startVertex"
        ],
        "type": "object",
        "properties": {
          "direction": {
            "type": "string",
            "description": "Direction for traversal\n- *if set*, must be either *\"outbound\"*, *\"inbound\"*, or *\"any\"*\n- *if not set*, the *expander* attribute must be specified.\n\n"
          },
          "edgeCollection": {
            "type": "string",
            "description": "Name of the collection that contains the edges.\n\n"
          },
          "expander": {
            "type": "string",
            "description": "Body (JavaScript) code of custom expander function *must* be set if *direction* attribute is **not** set function signature: *(config, vertex, path) -> array* expander must return an array of the connections for *vertex* each connection is an object with the attributes *edge* and *vertex*.\n\n"
          },
          "filter": {
            "type": "string",
            "description": "Default is to include all nodes: body (JavaScript code) of custom filter function function signature: *(config, vertex, path) -> mixed* can return four different string values:\n- *\"exclude\"* -> this vertex will not be visited.\n- *\"prune\"* -> the edges of this vertex will not be followed.\n- *\"\"* or *undefined* -> visit the vertex and follow its edges.\n- *Array* -> containing any combination of the above.\n  If there is at least one *\"exclude\"* or *\"prune\"* respectively is contained, it's effect will occur.\n\n"
          },
          "graphName": {
            "type": "string",
            "description": "Name of the graph that contains the edges. Either *edgeCollection* or *graphName* has to be given. In case both values are set the *graphName* is preferred.\n\n"
          },
          "init": {
            "type": "string",
            "description": "Body (JavaScript) code of custom result initialization function function signature: *(config, result) -> void* initialize any values in result with what is required.\n\n"
          },
          "itemOrder": {
            "type": "string",
            "description": "Item iteration order can be *\"forward\"* or *\"backward\"*.\n\n"
          },
          "maxDepth": {
            "type": "string",
            "description": "ANDed with any existing filters visits only nodes in at most the given depth.\n\n"
          },
          "maxIterations": {
            "type": "string",
            "description": "Maximum number of iterations in each traversal. This number can be set to prevent endless loops in traversal of cyclic graphs. When a traversal performs as many iterations as the *maxIterations* value, the traversal will abort with an error. If *maxIterations* is not set, a server-defined value may be used.\n\n"
          },
          "minDepth": {
            "type": "string",
            "description": "ANDed with any existing filters):\nvisits only nodes in at least the given depth.\n\n"
          },
          "order": {
            "type": "string",
            "description": "Traversal order can be *\"preorder\"*, *\"postorder\"* or *\"preorder-expander\"*.\n\n"
          },
          "sort": {
            "type": "string",
            "description": "Body (JavaScript) code of a custom comparison function for the edges. The signature of this function is *(l, r) -> integer* (where l and r are edges) and must return -1 if l is smaller than, +1 if l is greater than, and 0 if l and r are equal. The reason for this is the following: The order of edges returned for a certain vertex is undefined. This is because there is no natural order of edges for a vertex with multiple connected edges. To explicitly define the order in which edges on the vertex are followed, you can specify an edge comparator function with this attribute. Note that the value here has to be a string to conform to the JSON standard, which in turn is parsed as function body on the server side. Furthermore note that this attribute is only used for the standard expanders. If you use your custom expander you have to do the sorting yourself within the expander code.\n\n"
          },
          "startVertex": {
            "type": "string",
            "description": "Id of the startVertex, e.g. *\"users/foo\"*.\n\n"
          },
          "strategy": {
            "type": "string",
            "description": "Traversal strategy can be *\"depth-first\"* or *\"breadth-first\"*.\n\n"
          },
          "uniqueness": {
            "type": "string",
            "description": "Specifies uniqueness for vertices and edges visited. If set, must be an object like this:\n`\"uniqueness\": {\"vertices\": \"none\"|\"global\"|\"path\", \"edges\": \"none\"|\"global\"|\"path\"}`.\n\n"
          },
          "visitor": {
            "type": "string",
            "description": "Body (JavaScript) code of custom visitor function function signature: *(config, result, vertex, path, connected) -> void* The visitor function can do anything, but its return value is ignored. To populate a result, use the *result* variable by reference. Note that the *connected* argument is only populated when the *order* attribute is set to *\"preorder-expander\"*.\n\n"
          }
        }
      },
      "event_attributes": {
        "type": "object",
        "description": "Additional event attributes. If specified, then *attributes* should be a JSON array containing key-value attributes:\n\n"
      },
      "create_database": {
        "required": [
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Has to contain a valid GeoFabric name.\n\n"
          },
          "options": {
            "$ref": "#/components/schemas/create_database_options"
          },
          "users": {
            "type": "array",
            "description": "Has to be an array of user objects to initially create for the new GeoFabric. User information will not be changed for users that already exist. If *users* is not specified or does not contain any users, a default user *root* will be created with an empty string password. This ensures that the new GeoFabric will be accessible after it is created. Each user object can contain the following attributes:\n\n",
            "items": {
              "$ref": "#/components/schemas/create_database_users"
            }
          }
        }
      },
      "create_database_options": {
        "type": "object",
        "properties": {
          "dcList": {
            "type": "string",
            "description": "The list of Edge Locations (datacenters) as a comma-separated string. The individual elements for this parameter are your Edge Location URL prefixes up to the first *.* character. For instance if one of your Edge Location URLs is *http://myfederation-us-east-1.dev.aws.macrometa.io*, then the corresponding value of one the items for this parameter would be *myfederation-us-east-1*. You can use the */datacenter/all* REST API call to get a list of all available Edge Locations and then pick and choose from this list. It is a mandatory field, but if not specified (due to user error), it defaults to the local Edge Location.\n\n"
          },
          "spotDc": {
            "type": "string",
            "description": "The Edge Location (Datacenter) where on-spot operations for the given GeoFabric will be performed. By default a random datacenter is chosen from those which are capable.\n\n"
          }
        },
        "description": "Has to be a dictionary of Database options used when creating the GeoFabric. If this is not specified, default options are used. If one of the dict members is not specified, then defaults will be used for that dict member.\nThe members of the *options* dictionary are as follows:\n\n"
      },
      "create_database_users": {
        "type": "object",
        "properties": {
          "active": {
            "type": "boolean",
            "description": "A flag indicating whether the user account should be activated or not. The default value is *true*. If set to *false*, the user won't be able to log into the GeoFabric.\n\n"
          },
          "extra": {
            "type": "object",
            "properties": {},
            "description": "A JSON object with extra user information. The data contained in *extra* will be stored for the user but not be interpreted further by database.\n\n"
          },
          "passwd": {
            "type": "string",
            "description": "The user password as a string. If not specified, it will default to an empty string.\n\n"
          },
          "username": {
            "type": "string",
            "description": "Login name of the user to be created.\n\n"
          }
        },
        "description": ""
      },
      "api_query_properties": {
        "required": [
          "query"
        ],
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "To validate a query string without executing it, the query string can be passed to the server via an HTTP POST request.\n\n"
          }
        }
      },
      "track_query_properties": {
        "required": [
          "enabled"
        ],
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "If set to *true*, then queries will be tracked. If set to *false*, neither queries nor slow queries will be tracked.\n\n",
            "format": ""
          },
          "maxQueryStringLength": {
            "type": "integer",
            "description": "The maximum query string length to keep in the list of queries. Query strings can have arbitrary lengths, and this property can be used to save memory in case very long query strings are used. The value is specified in bytes.\n\n",
            "format": "int64"
          },
          "maxSlowQueries": {
            "type": "integer",
            "description": "The maximum number of slow queries to keep in the list of slow queries. If the list of slow queries is full, the oldest entry in it will be discarded when additional slow queries occur.\n\n",
            "format": "int64"
          },
          "slowQueryThreshold": {
            "type": "integer",
            "description": "The threshold value for treating a query as slow. A query with a runtime greater or equal to this threshold value will be put into the list of slow queries when slow query tracking is enabled. The value for *slowQueryThreshold* is specified in seconds.\n\n",
            "format": "int64"
          },
          "trackBindVars": {
            "type": "boolean",
            "description": "If set to *true*, then the bind variables used in queries will be tracked along with queries.\n\n",
            "format": ""
          },
          "trackSlowQueries": {
            "type": "boolean",
            "description": "If set to *true*, then slow queries will be tracked in the list of slow queries if their runtime exceeds the value set in *slowQueryThreshold*. In order for slow queries to be tracked, the *enabled* property must also be set to *true*.\n\n",
            "format": ""
          }
        }
      },
      "tenant_create": {
        "required": [
          "dcList",
          "email",
          "name"
        ],
        "type": "object",
        "properties": {
          "email": {
            "type": "string",
            "description": "Email address of tenant. This is non mandatory.\n\n"
          },
          "name": {
            "type": "string",
            "description": "The name of the tenant as a string. This is mandatory.\n\n"
          },
          "passwd": {
            "type": "string",
            "description": "The user password as a string. If no password is specified, the empty string will be used.\n\n"
          },
          "plan": {
            "type": "string",
            "description": "The plan name as a string. If no plan is specified, the empty string will be used.\n\n"
          },
          "attribution": {
            "type": "string",
            "description": "The attribution as a string. If no attribution is specified, the empty string will be used.\n\n"
          },
          "dcList": {
            "type": "string",
            "description": "A comma-separated string containing the datacenter names on which this tenant is to be created. If an empty string is passed in, the tenant is assumed to be global to the federation and will be created on all current datacenters in the federation.\n\n"
          },
          "metadata": {
            "$ref": "#/components/schemas/get_tenant_metadata_object_example"
          },
          "contact": {
            "$ref": "#/components/schemas/create_tenant_contact_object_example"
          }
        }
      },
      "get_tenant_example_rc_200": {
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n",
            "example": 200
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "result": {
            "$ref": "#/components/schemas/get_tenant_result_value"
          }
        }
      },
      "get_tenant_result_value": {
        "type": "object",
        "properties": {
          "limits": {
            "type": "object",
            "properties": {},
            "description": "Limits for tenants.\n"
          },
          "tenant": {
            "type": "string",
            "description": "Name of the tenant.",
            "format": "string"
          },
          "status": {
            "type": "string",
            "description": "Availability of tenant.",
            "format": "string",
            "example": "available"
          },
          "spotDc": {
            "type": "string",
            "description": "The Edge Location (Datacenter) where on-spot operations for the given GeoFabric will be performed. By default a random datacenter is chosen from those which are capable.\n\n",
            "format": "string"
          },
          "realTime": {
            "type": "boolean",
            "description": "For this tenant, whether the changes are published in a real time streams.",
            "format": "boolean",
            "example": true
          },
          "name": {
            "type": "string",
            "description": "Name of the tenant with fabric name as a suffix.",
            "format": "string"
          },
          "clusters": {
            "type": "array",
            "description": "List of datacenters in tenant.",
            "example": [
              "dc-region1",
              "dc-region2"
            ],
            "items": {
              "type": "string"
            }
          },
          "dynamo_local_tables": {
            "type": "boolean",
            "description": "Flag indicator for dynamo_local_tables.",
            "format": "boolean",
            "example": false
          },
          "attribution": {
            "type": "string",
            "description": "Attribution of the tenant.",
            "format": "string"
          },
          "features": {
            "type": "object",
            "description": "List of features with boolean value indicating that those features are enabled or not."
          },
          "plan": {
            "type": "string",
            "description": "Name of the plan.",
            "format": "string"
          },
          "metadata": {
            "type": "object",
            "properties": {},
            "description": "Object with metadata key-value pairs.",
            "example": {
              "key": "value"
            }
          }
        }
      },
      "tenant_upgrade_plan_example_rc_200": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n",
            "example": 200
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "result": {
            "type": "object",
            "properties": {
              "attribution": {
                "type": "string",
                "description": "Attribution of the tenant.",
                "format": "string"
              },
              "plan": {
                "type": "string",
                "description": "Name of the plan.",
                "format": "string"
              },
              "features": {
                "type": "object",
                "description": "List of features with boolean value indicating that those features are enabled or not."
              }
            },
            "description": "The information about what are the new attribution, plan and features attributes for tenant after plan is upgraded. one.\n"
          }
        }
      },
      "features_list_with_availability_flag_example": {
        "type": "object",
        "properties": {
          "CEP": {
            "type": "boolean",
            "description": "Name of the CEP feature.\n\n",
            "format": "boolean",
            "example": false
          },
          "DOCS": {
            "type": "boolean",
            "description": "Name of the Docs feature.\n\n",
            "format": "boolean",
            "example": false
          },
          "DYNAMO": {
            "type": "boolean",
            "description": "Name of the Dynamo feature.\n\n",
            "format": "boolean",
            "example": false
          },
          "GEO_FABRICS": {
            "type": "boolean",
            "description": "Name of the Geo Fabrics feature.\n\n",
            "format": "boolean",
            "example": false
          },
          "GRAPHS": {
            "type": "boolean",
            "description": "Name of the Graphs feature.\n\n",
            "format": "boolean",
            "example": false
          },
          "KV": {
            "type": "boolean",
            "description": "Name of the KV feature.\n\n",
            "format": "boolean",
            "example": true
          },
          "STREAMS": {
            "type": "boolean",
            "description": "Name of the streams feature.\n\n",
            "format": "boolean",
            "example": false
          },
          "USERS": {
            "type": "boolean",
            "description": "Name of the Users feature.\n\n",
            "format": "boolean",
            "example": false
          }
        }
      },
      "get_tenant_metadata_object_example": {
        "type": "object",
        "properties": {
          "key1": {
            "type": "string",
            "description": "Name of metadata key 1.\n\n",
            "format": "string",
            "example": "value1"
          },
          "key2": {
            "type": "string",
            "description": "Name of metadata key 2.\n\n",
            "format": "string",
            "example": "value2"
          }
        }
      },
      "create_tenant_contact_object_example": {
        "type": "object",
        "properties": {
          "firstname": {
            "type": "string",
            "description": "First name of user.\n\n",
            "format": "string",
            "example": "string"
          },
          "lastname": {
            "type": "string",
            "description": "Last name of user.\n\n",
            "format": "string",
            "example": "string"
          },
          "email": {
            "type": "string",
            "description": "Email address of user.\n\n",
            "format": "string",
            "example": "string"
          },
          "phone": {
            "type": "string",
            "description": "Phone number of user.\n\n",
            "format": "string",
            "example": "string"
          },
          "line1": {
            "type": "string",
            "description": "First line of address of user.\n\n",
            "format": "string",
            "example": "string"
          },
          "line2": {
            "type": "string",
            "description": "Second line of address of user.\n\n",
            "format": "string",
            "example": "string"
          },
          "city": {
            "type": "string",
            "description": "Name of the city.\n\n",
            "format": "string",
            "example": "string"
          },
          "state": {
            "type": "string",
            "description": "Name of state.\n\n",
            "format": "string",
            "example": "string"
          },
          "country": {
            "type": "string",
            "description": "Name of country.\n\n",
            "format": "string",
            "example": "string"
          },
          "zipcode": {
            "type": "string",
            "description": "Zip code of user.\n\n",
            "format": "string",
            "example": "string"
          }
        }
      },
      "tenant_modify": {
        "type": "object",
        "properties": {
          "active": {
            "type": "boolean",
            "description": "Active status of the tenant. Possible values: **true | false**.\n\n"
          },
          "status": {
            "type": "string",
            "description": "Status of the tenant. Possible values: **active | expired | delinquent | inactive** \n\n"
          },
          "metadata": {
            "type": "object",
            "properties": {},
            "description": "Object with metadata key-value pairs.",
            "example": {
              "key": "value"
            }
          }
        }
      },
      "tenant_modify_example_rc_200": {
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n",
            "example": 200
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "result": {
            "type": "object",
            "description": "Attributes of tenant after patch operation."
          }
        }
      },
      "tenant_modify_result_value": {
        "type": "object",
        "properties": {
          "tenant": {
            "type": "string",
            "description": "Name of the tenant.",
            "format": "string"
          },
          "active": {
            "type": "boolean",
            "description": "Active state of tenant.",
            "format": "boolean",
            "example": true
          },
          "status": {
            "type": "string",
            "description": "Availability of tenant.",
            "format": "string",
            "example": "available"
          },
          "metadata": {
            "type": "object",
            "properties": {},
            "description": "Object with metadata key-value pairs.",
            "example": {
              "key": "value"
            }
          }
        }
      },
      "plan_create": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Full name of the plan.\n\n"
          },
          "planId": {
            "type": "string",
            "description": "Id of the plan.\n\n"
          },
          "description": {
            "type": "string",
            "description": "Description of the plan.\n\n"
          },
          "featureGates": {
            "type": "array",
            "description": "List of the plan feature gates.\n\n",
            "items": {
              "type": "string"
            }
          },
          "attribution": {
            "type": "string",
            "description": "Attribution of the plan.\n\n"
          },
          "label": {
            "type": "string",
            "description": "Display label of the plan.\n\n"
          },
          "pricing": {
            "type": "string",
            "description": "Pricing details of the plan.\n\n"
          },
          "isBundle": {
            "type": "boolean",
            "description": "Bundle.\n\n"
          },
          "metadata": {
            "type": "object",
            "properties": {},
            "description": "Metadata of the plan, having set of key-value pairs.\n\n",
            "example": {
              "key": "value"
            }
          },
          "metrics": {
            "type": "array",
            "description": "List of metrics applicable for plan.",
            "items": {
              "$ref": "#/components/schemas/plan_metrics_example"
            }
          },
          "active": {
            "type": "boolean",
            "description": "A mandatory flag that specifies whether the plan is active.\n\n"
          },
          "demo": {
            "type": "boolean",
            "description": "An optional flag that specifies whether the plan is demo or not. Default value is false.\n\n"
          }
        }
      },
      "plan_metrics_example": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the metrics. e.g. reads, writes etc."
          },
          "value": {
            "type": "string",
            "description": "Value of the metrics. e.g. c8db_service_read_requests_count, c8db_service_write_requests_count etc."
          },
          "metricType": {
            "type": "string",
            "description": "Name of the metrics. e.g. counter, gauge, histogram."
          }
        }
      },
      "update_tenant_plan": {
        "type": "object",
        "properties": {
          "attribution": {
            "type": "string",
            "description": "Attribution of the plan.\n"
          },
          "plan": {
            "type": "string",
            "description": "Name of the plan.\n"
          },
          "tenant": {
            "type": "string",
            "description": "Name of the tenant.\n"
          }
        }
      },
      "apikey_create": {
        "required": [
          "keyid"
        ],
        "type": "object",
        "properties": {
          "keyid": {
            "type": "string",
            "description": "The id of the api key as a string.\n\n"
          }
        }
      },
      "apikey_validate": {
        "required": [
          "apikey"
        ],
        "type": "object",
        "properties": {
          "apikey": {
            "type": "string",
            "description": "The api key as a string.\n\n"
          }
        }
      },
      "user_create": {
        "required": [
          "user"
        ],
        "type": "object",
        "properties": {
          "active": {
            "type": "boolean",
            "description": "An optional flag that specifies whether the user is active.  If not specified, this will default to true.\n\n",
            "format": "boolean"
          },
          "email": {
            "type": "string",
            "description": "The email of the user as a string.\n\n"
          },
          "extra": {
            "type": "object",
            "properties": {},
            "description": "An optional JSON object with arbitrary extra data about the user.\n\n"
          },
          "passwd": {
            "type": "string",
            "description": "The user password as a string.\n\n"
          },
          "user": {
            "type": "string",
            "description": "The name of the user as a string.\n\n"
          }
        }
      },
      "user_grant_collection": {
        "required": [
          "grant"
        ],
        "type": "object",
        "properties": {
          "grant": {
            "type": "string",
            "description": "Use \"rw\" to set the collection level access to *Read/Write*.\n\nUse \"ro\" to set the collection level access to  *Read Only*.\n\nUse \"none\" to set the collection level access to *No access*.\n\n"
          }
        }
      },
      "user_grant_database": {
        "required": [
          "grant"
        ],
        "type": "object",
        "properties": {
          "grant": {
            "type": "string",
            "description": "Use \"rw\" to set the database access level to *Administrate* .\n\nUse \"ro\" to set the database access level to *Access*.\n\nUse \"none\" to set the database access level to *No access*.\n\n"
          }
        }
      },
      "user_modify": {
        "required": [
          "passwd"
        ],
        "type": "object",
        "properties": {
          "active": {
            "type": "boolean",
            "description": "An optional flag that specifies whether the user is active.  If not specified, this will default to true.\n\n",
            "format": "boolean"
          },
          "extra": {
            "type": "object",
            "properties": {},
            "description": "An optional JSON object with arbitrary extra data about the user.\n\n"
          },
          "passwd": {
            "type": "string",
            "description": "The user password as a string. Specifying a password is mandatory, but the empty string is allowed for passwords.\n\n"
          }
        }
      },
      "user_replace": {
        "required": [
          "passwd"
        ],
        "type": "object",
        "properties": {
          "active": {
            "type": "boolean",
            "description": "An optional flag that specifies whether the user is active.  If not specified, this will default to true.\n\n",
            "format": "boolean"
          },
          "extra": {
            "type": "object",
            "properties": {},
            "description": "An optional JSON object with arbitrary extra data about the user.\n\n"
          },
          "passwd": {
            "type": "string",
            "description": "The user password as a string. Specifying a password is mandatory.\n\n"
          }
        }
      },
      "user_queries_create_data_format": {
        "required": [
          "name"
        ],
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Name for the query.\n\n"
          },
          "parameter": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            },
            "description": "bindVars for the query.\n\n"
          },
          "value": {
            "type": "string",
            "description": "Value of the query.\n\n"
          }
        },
        "description": "Specify the query parameters.\n\n"
      },
      "user_queries_create_user_queries": {
        "type": "object",
        "properties": {
          "query": {
            "$ref": "#/components/schemas/user_queries_create_data_format"
          }
        }
      },
      "user_queries_execute_saved_queries": {
        "type": "object",
        "properties": {
          "bindVars": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            },
            "description": "Specify the bindVars of the query.\n\n"
          }
        }
      },
      "user_queries_execute_user_query": {
        "type": "object",
        "properties": {
          "bindVars": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            },
            "description": "Specify the bindVars of the query.\n\n"
          }
        }
      },
      "user_queries_update_data_format": {
        "required": [
          "value"
        ],
        "type": "object",
        "properties": {
          "parameter": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            },
            "description": "bindVars for the query.\n\n"
          },
          "value": {
            "type": "string",
            "description": "Value for the query.\n\n"
          }
        },
        "description": "Specify the query parameters.\n\n"
      },
      "user_queries_update_user_queries": {
        "type": "object",
        "properties": {
          "query": {
            "$ref": "#/components/schemas/user_queries_update_data_format"
          }
        }
      },
      "collection_info": {
        "required": [
          "keyOptions"
        ],
        "type": "object",
        "properties": {
          "globallyUniqueId": {
            "type": "string",
            "description": "Unique identifier of the collection.\n"
          },
          "id": {
            "type": "string",
            "description": "Unique identifier of the collection; *deprecated*.\n\n"
          },
          "isSystem": {
            "type": "boolean",
            "description": "True if this is a system collection; usually *name* will start with an underscore.\n\n"
          },
          "keyOptions": {
            "$ref": "#/components/schemas/key_generator_type"
          },
          "name": {
            "type": "string",
            "description": "Literal name of this collection.\n\n"
          },
          "numberOfShards": {
            "type": "integer",
            "description": "The number of shards of the collection.\n\n"
          },
          "shardKeys": {
            "type": "array",
            "description": "Contains the names of document attributes that are used to determine the target shard for documents.\n\n",
            "items": {
              "type": "string"
            }
          },
          "shardingStrategy": {
            "type": "string",
            "description": "The sharding strategy selected for the collection.\n\n"
          },
          "status": {
            "type": "string",
            "description": "Corresponds to **statusString**; *Only relevant for the MMFiles storage engine*\n  - 0: \"unknown\" - may be corrupted\n  - 1: (deprecated, maps to \"unknown\")\n  - 2: \"unloaded\"\n  - 3: \"loaded\"\n  - 4: \"unloading\"\n  - 5: \"deleted\"\n  - 6: \"loading\".\n\n\n\n"
          },
          "type": {
            "type": "integer",
            "description": "The type of the collection:\n  - 0: \"unknown\"\n  - 2: regular document collection\n  - 3: edge collection.\n\n"
          }
        },
        "description": "\n"
      },
      "edge_representation": {
        "type": "object",
        "properties": {
          "_from": {
            "type": "string",
            "description": "The _from value of the stored data.\n\n"
          },
          "_id": {
            "type": "string",
            "description": "The _id value of the stored data.\n\n"
          },
          "_key": {
            "type": "string",
            "description": "The _key value of the stored data.\n\n"
          },
          "_rev": {
            "type": "string",
            "description": "The _rev value of the stored data.\n\n"
          },
          "_to": {
            "type": "string",
            "description": "The _to value of the stored data.\n\n"
          }
        },
        "description": "The complete deleted edge document. Includes all attributes stored before this operation. Will only be present if returnOld is true.\n\n"
      },
      "event_create": {
        "required": [
          "entityName"
        ],
        "type": "object",
        "properties": {
          "action": {
            "type": "string",
            "description": "The activity of the event (CREATE/UPDATE/DELETE/EXECUTE/LOGIN).\n\n"
          },
          "attributes": {
            "$ref": "#/components/schemas/event_attributes"
          },
          "description": {
            "type": "string",
            "description": "Event description.\n\n"
          },
          "details": {
            "type": "string",
            "description": "Additional activity info. e.g. error message.\n\n"
          },
          "entityName": {
            "type": "string",
            "description": "The entity name of the event. e.g. name of collection; name of user etc.\n\n"
          },
          "entityType": {
            "type": "string",
            "description": "The entity type of the event (COLLECTION/GRAPH/CEP/AUTH/STREAM/GEOFABRIC).\n\n"
          },
          "status": {
            "type": "string",
            "description": "The activity status (OK/WARN/ERROR).\n\n"
          }
        }
      },
      "explain_options": {
        "type": "object",
        "properties": {
          "allPlans": {
            "type": "boolean",
            "description": "If set to *true*, all possible execution plans will be returned. The default is *false*, meaning only the optimal plan will be returned.\n\n"
          },
          "maxNumberOfPlans": {
            "type": "integer",
            "description": "An optional maximum number of plans that the optimizer is allowed to generate. Setting this attribute to a low value allows to put a cap on the amount of work the optimizer does.\n\n",
            "format": "int64"
          },
          "optimizer.rules": {
            "type": "array",
            "description": "An array of to-be-included or to-be-excluded optimizer rules can be put into this attribute, telling the optimizer to include or exclude specific rules. To disable a rule, prefix its name with a `-`, to enable a rule, prefix it with a `+`. There is also a pseudo-rule `all`, which will match all optimizer rules.\n\n",
            "items": {
              "type": "string"
            }
          }
        },
        "description": "Options for the query.\n\n"
      },
      "graph_create_http_examples": {
        "required": [
          "name"
        ],
        "type": "object",
        "properties": {
          "edgedefinitions": {
            "type": "array",
            "description": "An array of definitions for the relations of the graph.\nEach has the following type:\n\n",
            "items": {
              "$ref": "#/components/schemas/graph_edge_definition"
            }
          },
          "name": {
            "type": "string",
            "description": "Name of the graph.\n\n"
          },
          "options": {
            "$ref": "#/components/schemas/api_gharial_create_opts"
          }
        }
      },
      "graph_create_http_examples_rc_201": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "graph": {
            "$ref": "#/components/schemas/graph_representation"
          }
        }
      },
      "graph_create_http_examples_rc_202": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "graph": {
            "$ref": "#/components/schemas/graph_representation"
          }
        }
      },
      "graph_create_http_examples_rc_400": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_create_http_examples_rc_403": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_create_http_examples_rc_409": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_drop_http_examples_rc_403": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_drop_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false). It is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_create_http_examples": {
        "required": [
          "_from"
        ],
        "type": "object",
        "properties": {
          "_from": {
            "type": "string",
            "description": "The source vertex of this edge. Has to be valid within\nthe used edge definition.\n\n"
          },
          "_to": {
            "type": "string",
            "description": "The target vertex of this edge. Has to be valid within\nthe used edge definition.\n\n"
          }
        }
      },
      "graph_edge_create_http_examples_rc_201": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "edge": {
            "$ref": "#/components/schemas/edge_representation"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "new": {
            "$ref": "#/components/schemas/edge_representation"
          }
        }
      },
      "graph_edge_create_http_examples_rc_202": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "edge": {
            "$ref": "#/components/schemas/edge_representation"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false). It is false in this response.\n\n",
            "format": ""
          },
          "new": {
            "$ref": "#/components/schemas/edge_representation"
          }
        }
      },
      "graph_edge_create_http_examples_rc_400": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_create_http_examples_rc_403": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_create_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_definition_add_http_examples": {
        "required": [
          "collection"
        ],
        "type": "object",
        "properties": {
          "collection": {
            "type": "string",
            "description": "The name of the edge collection to be used.\n\n"
          },
          "from": {
            "type": "array",
            "description": "One or many vertex collections that can contain source vertices.\n\n",
            "items": {
              "type": "string"
            }
          },
          "to": {
            "type": "array",
            "description": "One or many vertex collections that can contain target vertices.\n\n",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "graph_edge_definition_add_http_examples_rc_201": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "graph": {
            "$ref": "#/components/schemas/graph_representation"
          }
        }
      },
      "graph_edge_definition_add_http_examples_rc_202": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "graph": {
            "$ref": "#/components/schemas/graph_representation"
          }
        }
      },
      "graph_edge_definition_add_http_examples_rc_400": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_definition_add_http_examples_rc_403": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_definition_add_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_definition_modify_http_examples": {
        "required": [
          "collection"
        ],
        "type": "object",
        "properties": {
          "collection": {
            "type": "string",
            "description": "The name of the edge collection to be used.\n\n"
          },
          "from": {
            "type": "array",
            "description": "One or many vertex collections that can contain source vertices.\n\n",
            "items": {
              "type": "string"
            }
          },
          "to": {
            "type": "array",
            "description": "One or many vertex collections that can contain target vertices.\n\n",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "graph_edge_definition_modify_http_examples_rc_201": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "graph": {
            "$ref": "#/components/schemas/graph_representation"
          }
        }
      },
      "graph_edge_definition_modify_http_examples_rc_202": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "graph": {
            "$ref": "#/components/schemas/graph_representation"
          }
        }
      },
      "graph_edge_definition_modify_http_examples_rc_400": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_definition_modify_http_examples_rc_403": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_definition_modify_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_definition_remove_http_examples_rc_201": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "graph": {
            "$ref": "#/components/schemas/graph_representation"
          }
        }
      },
      "graph_edge_definition_remove_http_examples_rc_202": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "graph": {
            "$ref": "#/components/schemas/graph_representation"
          }
        }
      },
      "graph_edge_definition_remove_http_examples_rc_403": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_definition_remove_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_delete_http_examples_rc_200": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "old": {
            "$ref": "#/components/schemas/edge_representation"
          },
          "removed": {
            "type": "boolean",
            "description": "Is set to true if the remove was successful.\n\n",
            "format": ""
          }
        }
      },
      "graph_edge_delete_http_examples_rc_202": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "old": {
            "$ref": "#/components/schemas/edge_representation"
          },
          "removed": {
            "type": "boolean",
            "description": "Is set to true if the remove was successful.\n\n",
            "format": ""
          }
        }
      },
      "graph_edge_delete_http_examples_rc_403": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_delete_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_delete_http_examples_rc_412": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_get_http_examples_rc_200": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "edge": {
            "$ref": "#/components/schemas/edge_representation"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          }
        }
      },
      "graph_edge_get_http_examples_rc_304": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_get_http_examples_rc_403": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_get_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_get_http_examples_rc_412": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_modify_http_examples_rc_200": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "edge": {
            "$ref": "#/components/schemas/edge_representation"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "new": {
            "$ref": "#/components/schemas/edge_representation"
          },
          "old": {
            "$ref": "#/components/schemas/edge_representation"
          }
        }
      },
      "graph_edge_modify_http_examples_rc_202": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "edge": {
            "$ref": "#/components/schemas/edge_representation"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "new": {
            "$ref": "#/components/schemas/edge_representation"
          },
          "old": {
            "$ref": "#/components/schemas/edge_representation"
          }
        }
      },
      "graph_edge_modify_http_examples_rc_403": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_modify_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_modify_http_examples_rc_412": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_replace_http_examples": {
        "required": [
          "_from"
        ],
        "type": "object",
        "properties": {
          "_from": {
            "type": "string",
            "description": "The source vertex of this edge. Has to be valid within\nthe used edge definition.\n\n"
          },
          "_to": {
            "type": "string",
            "description": "The target vertex of this edge. Has to be valid within\nthe used edge definition.\n\n"
          }
        }
      },
      "graph_edge_replace_http_examples_rc_201": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "edge": {
            "$ref": "#/components/schemas/edge_representation"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "new": {
            "$ref": "#/components/schemas/edge_representation"
          },
          "old": {
            "$ref": "#/components/schemas/edge_representation"
          }
        }
      },
      "graph_edge_replace_http_examples_rc_202": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "edge": {
            "$ref": "#/components/schemas/edge_representation"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "new": {
            "$ref": "#/components/schemas/edge_representation"
          },
          "old": {
            "$ref": "#/components/schemas/edge_representation"
          }
        }
      },
      "graph_edge_replace_http_examples_rc_403": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_replace_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_edge_replace_http_examples_rc_412": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_get_http_examples_rc_200": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "graph": {
            "$ref": "#/components/schemas/graph_representation"
          }
        }
      },
      "graph_get_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_list_edge_http_examples_rc_200": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "collections": {
            "type": "array",
            "description": "The list of all vertex collections within this graph. Includes collections in edge definitions as well as orphans.\n\n",
            "items": {
              "type": "string"
            }
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          }
        }
      },
      "graph_list_edge_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_list_http_examples_rc_200": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "graphs": {
            "type": "array",
            "description": "\n",
            "items": {
              "$ref": "#/components/schemas/graph_list"
            }
          }
        }
      },
      "graph_list_vertex_http_examples_rc_200": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "collections": {
            "type": "array",
            "description": "The list of all vertex collections within this graph.\nIncludes collections in edge definitions as well as orphans.\n\n",
            "items": {
              "type": "string"
            }
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          }
        }
      },
      "graph_list_vertex_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_collection_add_http_examples_rc_201": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "graph": {
            "$ref": "#/components/schemas/graph_representation"
          }
        }
      },
      "graph_vertex_collection_add_http_examples_rc_202": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "graph": {
            "$ref": "#/components/schemas/graph_representation"
          }
        }
      },
      "graph_vertex_collection_add_http_examples_rc_400": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_collection_add_http_examples_rc_403": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_collection_add_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_collection_remove_http_examples_rc_200": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "graph": {
            "$ref": "#/components/schemas/graph_representation"
          }
        }
      },
      "graph_vertex_collection_remove_http_examples_rc_202": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "graph": {
            "$ref": "#/components/schemas/graph_representation"
          }
        }
      },
      "graph_vertex_collection_remove_http_examples_rc_400": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_collection_remove_http_examples_rc_403": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_collection_remove_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_create_http_examples_rc_201": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "new": {
            "$ref": "#/components/schemas/vertex_representation"
          },
          "vertex": {
            "$ref": "#/components/schemas/vertex_representation"
          }
        }
      },
      "graph_vertex_create_http_examples_rc_202": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "new": {
            "$ref": "#/components/schemas/vertex_representation"
          },
          "vertex": {
            "$ref": "#/components/schemas/vertex_representation"
          }
        }
      },
      "graph_vertex_create_http_examples_rc_403": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_create_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_delete_http_examples_rc_200": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "old": {
            "$ref": "#/components/schemas/vertex_representation"
          },
          "removed": {
            "type": "boolean",
            "description": "Is set to true if the remove was successful.\n\n",
            "format": ""
          }
        }
      },
      "graph_vertex_delete_http_examples_rc_202": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "old": {
            "$ref": "#/components/schemas/vertex_representation"
          },
          "removed": {
            "type": "boolean",
            "description": "Is set to true if the remove was successful.\n\n",
            "format": ""
          }
        }
      },
      "graph_vertex_delete_http_examples_rc_403": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_delete_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_delete_http_examples_rc_412": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_get_http_examples_rc_200": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "vertex": {
            "$ref": "#/components/schemas/vertex_representation"
          }
        }
      },
      "graph_vertex_get_http_examples_rc_304": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_get_http_examples_rc_403": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_get_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_get_http_examples_rc_412": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_modify_http_examples_rc_200": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "new": {
            "$ref": "#/components/schemas/vertex_representation"
          },
          "old": {
            "$ref": "#/components/schemas/vertex_representation"
          },
          "vertex": {
            "$ref": "#/components/schemas/vertex_representation"
          }
        }
      },
      "graph_vertex_modify_http_examples_rc_202": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "new": {
            "$ref": "#/components/schemas/vertex_representation"
          },
          "old": {
            "$ref": "#/components/schemas/vertex_representation"
          },
          "vertex": {
            "$ref": "#/components/schemas/vertex_representation"
          }
        }
      },
      "graph_vertex_modify_http_examples_rc_403": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_modify_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_modify_http_examples_rc_412": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_replace_http_examples_rc_200": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "new": {
            "$ref": "#/components/schemas/vertex_representation"
          },
          "old": {
            "$ref": "#/components/schemas/vertex_representation"
          },
          "vertex": {
            "$ref": "#/components/schemas/vertex_representation"
          }
        }
      },
      "graph_vertex_replace_http_examples_rc_202": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is false in this response.\n\n",
            "format": ""
          },
          "new": {
            "$ref": "#/components/schemas/vertex_representation"
          },
          "old": {
            "$ref": "#/components/schemas/vertex_representation"
          },
          "vertex": {
            "$ref": "#/components/schemas/vertex_representation"
          }
        }
      },
      "graph_vertex_replace_http_examples_rc_403": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_replace_http_examples_rc_404": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "graph_vertex_replace_http_examples_rc_412": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The response code.\n\n"
          },
          "error": {
            "type": "boolean",
            "description": "Flag if there was an error (true) or not (false).\nIt is true in this response.\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A message created for this error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "Database error number for the error that occurred.\n\n"
          }
        }
      },
      "get_api_return_rc_200": {
        "required": [
          "server"
        ],
        "type": "object",
        "properties": {
          "details": {
            "$ref": "#/components/schemas/version_details_struct"
          },
          "server": {
            "type": "string",
            "description": "Will always contain *database*\n\n"
          },
          "version": {
            "type": "string",
            "description": "The server version string. The string has the format \"*major*.*minor*.*sub*\". *major* and *minor* will be numeric, and *sub* may contain a number or a textual version.\n\n"
          }
        }
      },
      "graph_edge_definition": {
        "type": "object",
        "properties": {
          "collection": {
            "type": "string",
            "description": "Name of the edge collection, where the edge are stored in.\n\n"
          },
          "from": {
            "type": "array",
            "description": "List of vertex collection names.\nEdges in collection can only be inserted if their _from is in any of the collections here.\n\n",
            "items": {
              "type": "string"
            }
          },
          "to": {
            "type": "array",
            "description": "List of vertex collection names.\nEdges in collection can only be inserted if their _to is in any of the collections here.\n",
            "items": {
              "type": "string"
            }
          }
        },
        "description": ""
      },
      "graph_list": {
        "type": "object",
        "properties": {
          "graph": {
            "$ref": "#/components/schemas/graph_representation"
          }
        },
        "description": ""
      },
      "graph_representation": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string",
            "description": "The internal id value of this graph. \n\n"
          },
          "_rev": {
            "type": "string",
            "description": "The revision of this graph. Can be used to make sure to not override concurrent modifications to this graph.\n\n"
          },
          "edgedefinitions": {
            "type": "array",
            "description": "An array of definitions for the relations of the graph.\nEach has the following type:\n\n",
            "items": {
              "$ref": "#/components/schemas/graph_edge_definition"
            }
          },
          "name": {
            "type": "string",
            "description": "The name of the graph.\n\n"
          },
          "orphanCollections": {
            "type": "array",
            "description": "An array of additional vertex collections.\nDocuments within these collections do not have edges within this graph.\n\n",
            "items": {
              "type": "string"
            }
          }
        },
        "description": "The information about the newly created graph\n\nThe information about the newly created graph.\n\n"
      },
      "key_generator_type": {
        "type": "object",
        "properties": {
          "allowUserKeys": {
            "type": "boolean",
            "description": "If set to *true*, then it is allowed to supply own key values in the *_key* attribute of a document. If set to *false*, then the key generator is solely responsible for generating keys and supplying own key values in the *_key* attribute of documents is considered an error.\n\n"
          },
          "lastValue": {
            "type": "integer",
            "description": "\n\n"
          },
          "type": {
            "type": "string",
            "description": "Specifies the type of the key generator. The currently available generators are *traditional*, *autoincrement*, *uuid* and *padded*.\n\n"
          }
        },
        "description": "A object which contains key generation options.\n\n"
      },
      "api_analyzer": {
        "required": [
          "name"
        ],
        "type": "object",
        "properties": {
          "features": {
            "type": "array",
            "description": "The set of features to set on the analyzer generated fields.\nThe default value is an empty array.\n\n",
            "items": {
              "type": "string"
            }
          },
          "name": {
            "type": "string",
            "description": "The analyzer name.\n\n"
          },
          "properties": {
            "type": "string",
            "description": "The properties used to configure the specified type.\nValue may be a string, an object or null.\nThe default value is *null*.\n\n"
          },
          "type": {
            "type": "string",
            "description": "The analyzer type.\n\n"
          }
        }
      },
      "api_collection": {
        "required": [
          "name"
        ],
        "type": "object",
        "properties": {
          "isSystem": {
            "type": "boolean",
            "description": "If *true*, create a  system collection. In this case *collection-name* should start with an underscore. End users should normally create non-system collections only. API implementors may be required to create system collections in very special occasions, but normally a regular collection will do.\n(The default is *false*)\n\n",
            "format": ""
          },
          "keyOptions": {
            "$ref": "#/components/schemas/api_collection_opts"
          },
          "name": {
            "type": "string",
            "description": "The name of the collection.\n\n"
          },
          "shardKeys": {
            "type": "string",
            "description": "(The default is *[ \"_key\" ]*): in a cluster, this attribute determines which document attributes are used to determine the target shard for documents. Documents are sent to shards based on the values of their shard key attributes. The values of all shard key attributes in a document are hashed, and the hash value is used to determine the target shard.\n\n**Note**: Values of shard key attributes cannot be changed once set.\n\n"
          },
          "type": {
            "type": "integer",
            "description": "(The default is *2*): the type of the collection to create.\nThe following values for *type* are valid:\n\n- *2*: document collection\n- *3*: edge collection.\n\n",
            "format": "int64"
          }
        }
      },
      "api_collection_opts": {
        "type": "object",
        "properties": {
          "allowUserKeys": {
            "type": "boolean",
            "description": "If set to *true*, then it is allowed to supply own key values in the *_key* attribute of a document. If set to *false*, then the key generator will solely be responsible for generating keys and supplying own key values in the *_key* attribute of documents is considered an error.\n\n"
          },
          "increment": {
            "type": "integer",
            "description": "Increment value for *autoincrement* key generator. Not used for other key generator types.\n\n",
            "format": "int64"
          },
          "offset": {
            "type": "integer",
            "description": "Initial offset value for *autoincrement* key generator. Not used for other key generator types.\n\n",
            "format": "int64"
          },
          "type": {
            "type": "string",
            "description": "Specifies the type of the key generator. The currently available generators are *traditional*, *autoincrement*, *uuid* and *padded*.\n\nThe *traditional* key generator generates numerical keys in ascending order.\n\nThe *autoincrement* key generator generates numerical keys in ascending order, the initial offset and the spacing can be configured\n\nThe *padded* key generator generates keys of a fixed length (16 bytes) in ascending lexicographical sort order. \n\nThe *uuid* key generator generates universally unique 128 bit keys, which are stored in hexadecimal human-readable format. This key generator can be used in a single-server or cluster to generate \"seemingly random\" keys. The keys produced by this key generator are not lexicographically sorted.\n\n"
          }
        },
        "description": "Additional options for key generation. If specified, then *keyOptions* should be a JSON array containing the following attributes:\n\n"
      },
      "api_cursor": {
        "required": [
          "query"
        ],
        "type": "object",
        "properties": {
          "batchSize": {
            "type": "integer",
            "description": "Maximum number of result documents to be transferred from the server to the client in one roundtrip. If this attribute is not set, a server-controlled default value will be used. A *batchSize* value of *0* is disallowed.\n\n",
            "format": "int64"
          },
          "bindVars": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            },
            "description": "Key/value pairs representing the bind parameters.\n\n"
          },
          "count": {
            "type": "boolean",
            "description": "Indicates whether the number of documents in the result set should be returned in the \"count\" attribute of the result. Calculating the \"count\" attribute might have a performance impact for some queries in the future so this option is turned off by default, and \"count\" is only returned when requested.\n\n",
            "format": ""
          },
          "options": {
            "$ref": "#/components/schemas/api_cursor_opts"
          },
          "query": {
            "type": "string",
            "description": "Contains the query string to be executed.\n\n"
          },
          "ttl": {
            "type": "integer",
            "description": "The time-to-live for the cursor (in seconds). The cursor will be removed on the server automatically after the specified amount of time. This is useful to ensure garbage collection of cursors that are not fully fetched by clients. If not set, a server-defined value will be used (default: 30 seconds).\n\n",
            "format": "int64"
          }
        }
      },
      "api_cursor_opts": {
        "type": "object",
        "properties": {
          "failOnWarning": {
            "type": "boolean",
            "description": "When set to *true*, the query will throw an exception and abort instead of producing a warning. This option should be used during development to catch potential issues early. When the attribute is set to *false*, warnings will not be propagated to exceptions and will be returned with the query result.\n\n"
          },
          "fullCount": {
            "type": "boolean",
            "description": "If set to *true* and the query contains a *LIMIT* clause, then the result will have an *extra* attribute with the sub-attributes *stats* and *fullCount*, `{ ... , \"extra\": { \"stats\": { \"fullCount\": 123 } } }`.\nThe *fullCount* attribute will contain the number of documents in the result before the last top-level LIMIT in the query was applied. It can be used to count the number of documents that match certain filter criteria, but only return a subset of them, in one go.\nIt is thus similar to MySQL's *SQL_CALC_FOUND_ROWS* hint. Note that setting the option will disable a few LIMIT optimizations and may lead to more documents being processed, and thus make queries run longer. Note that the *fullCount* attribute may only be present in the result if the query has a top-level LIMIT clause and the LIMIT clause is actually used in the query.\n\n"
          },
          "intermediateCommitCount": {
            "type": "integer",
            "description": "Maximum number of operations after which an intermediate commit is performed automatically.\n\n",
            "format": "int64"
          },
          "intermediateCommitSize": {
            "type": "integer",
            "description": "Maximum total size of operations after which an intermediate commit is performed automatically.\n\n",
            "format": "int64"
          },
          "maxTransactionSize": {
            "type": "integer",
            "description": "Transaction size limit in bytes.\n",
            "format": "int64"
          },
          "maxWarningCount": {
            "type": "integer",
            "description": "Limits the maximum number of warnings a query will return. The number of warnings a query will return is limited to 10 by default, but that number can be increased or decreased by setting this attribute.\n\n",
            "format": "int64"
          },
          "profile": {
            "type": "integer",
            "description": "If set to *true* or *1*, then the additional query profiling information will be returned in the sub-attribute *profile* of the *extra* return attribute, if the query result is not served from the query cache. Set to *2* the query will include execution stats per query plan node in sub-attribute *stats.nodes* of the *extra* return attribute. Additionally the query plan is returned in the sub-attribute *extra.plan*.\n\n"
          },
          "skipInaccessibleCollections": {
            "type": "boolean",
            "description": "C8QL queries (especially graph traversals) will treat collection to which a user has no access rights as if these collections were empty. Instead of returning a forbidden access error, your queries will execute normally.\n\n"
          },
          "stream": {
            "type": "boolean",
            "description": "Specify *true* and the query will be executed in a **streaming** fashion. The query result is not stored on the server, but calculated on the fly. *Beware*: long-running queries will need to hold the collection locks for as long as the query cursor exists. \n\nWhen set to *false* a query will be executed right away in its entirety. \n\nIn that case query results are either returned right away (if the result set is small enough), or stored on the database instance and accessible via the cursor API (with respect to the `ttl`). \n\nIt is advisable to *only* use this option on short-running queries or without exclusive locks.\n\nAdditionally query statistics, warnings and profiling data will only be available after the query is finished.\n\nThe default value is *false*\n\n"
          }
        },
        "description": "Key/value object with extra options for the query.\n\n"
      },
      "api_cursor_rc_201": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The HTTP status code.\n\n",
            "format": "integer"
          },
          "count": {
            "type": "integer",
            "description": "The total number of result documents available (only available if the query was executed with the *count* attribute set).\n\n",
            "format": "int64"
          },
          "error": {
            "type": "boolean",
            "description": "A flag to indicate that an error occurred (*false* in this case).\n\n",
            "format": ""
          },
          "extra": {
            "type": "object",
            "properties": {},
            "description": "An optional JSON object with extra information about the query result contained in its *stats* sub-attribute. For data-modification queries, the *extra.stats* sub-attribute will contain the number of modified documents and the number of documents that could not be modified due to an error (if *ignoreErrors* query option is specified).\n\n"
          },
          "hasMore": {
            "type": "boolean",
            "description": "A boolean indicator whether there are more results\navailable for the cursor on the server.\n\n",
            "format": ""
          },
          "id": {
            "type": "string",
            "description": "Id of temporary cursor created on the server (optional, see above).\n\n"
          },
          "result": {
            "type": "array",
            "description": "An array of result documents (might be empty if query has no results).\n\n",
            "items": {
              "type": "object",
              "properties": {}
            }
          }
        }
      },
      "api_cursor_rc_400": {
        "required": [
          "error"
        ],
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "The HTTP status code.\n\n",
            "format": "int64"
          },
          "error": {
            "type": "boolean",
            "description": "Boolean flag to indicate that an error occurred (*true* in this case)\n\n",
            "format": ""
          },
          "errorMessage": {
            "type": "string",
            "description": "A descriptive error message\nIf the query specification is complete, the server will process the query. If an error occurs during query processing, the server will respond with *HTTP 400*. Again, the body of the response will contain details about the error.\n\n"
          },
          "errorNum": {
            "type": "integer",
            "description": "The server error number.\n\n",
            "format": "int64"
          }
        }
      },
      "api_explain": {
        "required": [
          "query"
        ],
        "type": "object",
        "properties": {
          "bindVars": {
            "type": "array",
            "description": "Key/value pairs representing the bind parameters.\n\n",
            "items": {
              "type": "object",
              "properties": {}
            }
          },
          "options": {
            "$ref": "#/components/schemas/explain_options"
          },
          "query": {
            "type": "string",
            "description": "The query which you want explained; If the query references any bind variables, these must also be passed in the attribute *bindVars*. Additional options for the query can be passed in the *options* attribute.\n\n"
          }
        }
      },
      "api_export": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "C8QL query. Default: returns all documents.",
            "format": "string",
            "default": ""
          }
        }
      },
      "api_import": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "description": "Array of documents that will be created in the specified collection.",
            "items": {
              "type": "string"
            }
          },
          "details": {
            "type": "boolean",
            "description": "if *true* extra information for errors and unprocessed documents will be returned in the result.",
            "format": "boolean",
            "default": false
          }
        }
      },
      "api_gharial_create_opts": {
        "type": "object",
        "description": "A JSON object to define options for creating collections within this graph.\nIt can contain the following attributes:\n\n"
      },
      "api_index_fulltext": {
        "required": [
          "type"
        ],
        "type": "object",
        "properties": {
          "fields": {
            "type": "array",
            "description": "An array of attribute names. Currently, the array is limited\nto exactly one attribute.\n\n",
            "items": {
              "type": "string"
            }
          },
          "minLength": {
            "type": "integer",
            "description": "Minimum character length of words to index. Will default to a server-defined value if unspecified. It is thus recommended to set this value explicitly when creating the index.\n\n",
            "format": "int64"
          },
          "type": {
            "type": "string",
            "description": "Must be equal to *\"fulltext\"*.\n\n"
          }
        }
      },
      "api_index_geo": {
        "required": [
          "type"
        ],
        "type": "object",
        "properties": {
          "fields": {
            "type": "array",
            "description": "An array with one or two attribute paths.\n\nIf it is an array with one attribute path *location*, then a geo-spatial index on all documents is created using *location* as path to the coordinates. The value of the attribute must be an array with at least two double values. The array must contain the latitude (first value) and the longitude (second value). All documents, which do not have the attribute path or with value that are not suitable, are ignored.\n\nIf it is an array with two attribute paths *latitude* and *longitude*, then a geo-spatial index on all documents is created using *latitude* and *longitude* as paths the latitude and the longitude. The value of the attribute *latitude* and of the attribute *longitude* must a double. All documents, which do not have the attribute paths or which values are not suitable, are ignored.\n\n",
            "items": {
              "type": "string"
            }
          },
          "geoJson": {
            "type": "string",
            "description": "If a geo-spatial index on a *location* is constructed and *geoJson* is *true*, then the order within the array is longitude followed by latitude. This corresponds to the format described in http://geojson.org/geojson-spec.html#positions.\n\n"
          },
          "type": {
            "type": "string",
            "description": "Must be equal to *\"geo\"*.\n\n"
          }
        }
      },
      "api_index_hash": {
        "required": [
          "type"
        ],
        "type": "object",
        "properties": {
          "deduplicate": {
            "type": "boolean",
            "description": "If *false*, the deduplication of array values is turned off.\n\n",
            "format": "boolean"
          },
          "fields": {
            "type": "array",
            "description": "An array of attribute paths.\n\n",
            "items": {
              "type": "string"
            }
          },
          "sparse": {
            "type": "boolean",
            "description": "If *true*, then create a sparse index.\n\n",
            "format": ""
          },
          "type": {
            "type": "string",
            "description": "Must be equal to *\"hash\"*.\n\n"
          },
          "unique": {
            "type": "boolean",
            "description": "If *true*, then create a unique index.\n\n",
            "format": ""
          }
        }
      },
      "api_index_persistent": {
        "required": [
          "type"
        ],
        "type": "object",
        "properties": {
          "fields": {
            "type": "array",
            "description": "An array of attribute paths.\n\n",
            "items": {
              "type": "string"
            }
          },
          "sparse": {
            "type": "boolean",
            "description": "If *true*, then create a sparse index.\n\n",
            "format": ""
          },
          "type": {
            "type": "string",
            "description": "Must be equal to *\"persistent\"*.\n\n"
          },
          "unique": {
            "type": "boolean",
            "description": "If *true*, then create a unique index.\n\n",
            "format": ""
          }
        }
      },
      "api_index_skiplist": {
        "required": [
          "type"
        ],
        "type": "object",
        "properties": {
          "deduplicate": {
            "type": "boolean",
            "description": "If *false*, the deduplication of array values is turned off.\n\n",
            "format": "boolean"
          },
          "fields": {
            "type": "array",
            "description": "An array of attribute paths.\n\n",
            "items": {
              "type": "string"
            }
          },
          "sparse": {
            "type": "boolean",
            "description": "If *true*, then create a sparse index.\n\n",
            "format": ""
          },
          "type": {
            "type": "string",
            "description": "Must be equal to *\"skip-list\"*.\n\n"
          },
          "unique": {
            "type": "boolean",
            "description": "If *true*, then create a unique index.\n\n",
            "format": ""
          }
        }
      },
      "api_index_ttl": {
        "required": [
          "type"
        ],
        "type": "object",
        "properties": {
          "expireAfter": {
            "type": "number",
            "description": "The time (in seconds) after a document's creation after which the\ndocuments count as \"expired\".\n\n",
            "format": ""
          },
          "fields": {
            "type": "array",
            "description": "An array with exactly one attribute path.\n\n",
            "items": {
              "type": "string"
            }
          },
          "type": {
            "type": "string",
            "description": "Must be equal to *\"ttl\"*.\n\n"
          }
        }
      },
      "api_transaction": {
        "required": [
          "collections"
        ],
        "type": "object",
        "properties": {
          "action": {
            "type": "string",
            "description": "The actual transaction operations to be executed, in the form of stringified JavaScript code. The code will be executed on server side, with late binding. It is thus critical that the code specified in *action* properly sets up all the variables it needs.\nIf the code specified in *action* ends with a return statement, the value returned will also be returned by the REST API in the *result* attribute if the transaction committed successfully.\n\n"
          },
          "allowImplicit": {
            "type": "boolean",
            "description": "Allow reading from undeclared collections.\n\n",
            "format": "boolean"
          },
          "collections": {
            "type": "string",
            "description": "*collections* must be a JSON object that can have one or all sub-attributes *read*, *write* or *exclusive*, each being an array of collection names or a single collection name as string. Collections that will be written to in the transaction must be declared with the *write* or *exclusive* attribute or it will fail, whereas non-declared collections from which is solely read will be added lazily. The optional sub-attribute *allowImplicit* can be set to *false* to let transactions fail in case of undeclared collections for reading. Collections for reading should be fully declared if possible, to avoid deadlocks.\n\n"
          },
          "lockTimeout": {
            "type": "integer",
            "description": "An optional numeric value that can be used to set a timeout for waiting on collection locks. If not specified, a default value will be used. Setting *lockTimeout* to *0* will make database not time out waiting for a lock.\n\n",
            "format": "int64"
          },
          "maxTransactionSize": {
            "type": "integer",
            "description": "Transaction size limit in bytes. \n\n",
            "format": "int64"
          },
          "params": {
            "type": "string",
            "description": "Optional arguments passed to *action*.\n\n"
          }
        }
      },
      "api_transaction_begin": {
        "required": [
          "collections"
        ],
        "type": "object",
        "properties": {
          "allowImplicit": {
            "type": "boolean",
            "description": "Allow reading from undeclared collections.\n\n",
            "format": "boolean"
          },
          "collections": {
            "type": "string",
            "description": "*collections* must be a JSON object that can have one or all sub-attributes *read*, *write* or *exclusive*, each being an array of collection names or a single collection name as string. Collections that will be written to in the transaction must be declared with the *write* or *exclusive* attribute or it will fail, whereas non-declared collections from which is solely read will be added lazily. The optional sub-attribute *allowImplicit* can be set to *false* to let transactions fail in case of undeclared collections for reading. Collections for reading should be fully declared if possible, to avoid deadlocks.\n\n"
          },
          "lockTimeout": {
            "type": "integer",
            "description": "An optional numeric value that can be used to set a timeout for waiting on collection locks. If not specified, a default value will be used. Setting *lockTimeout* to *0* will make database not time out waiting for a lock.\n\n",
            "format": "int64"
          },
          "maxTransactionSize": {
            "type": "integer",
            "description": "Transaction size limit in bytes. \n\n",
            "format": "int64"
          }
        }
      },
      "post_metrics_query": {
        "required": [
          "querytype"
        ],
        "type": "object",
        "properties": {
          "GeoFabric": {
            "type": "string",
            "description": "GeoFabric name\n\n"
          },
          "limit": {
            "type": "integer",
            "description": "Number of results we want to receive.\n\n",
            "format": "integer"
          },
          "metrics": {
            "type": "array",
            "description": "Array of strings containing the metric names we want to receive.\n\n",
            "items": {
              "type": "string"
            }
          },
          "querytype": {
            "type": "string",
            "description": "\"list\" returns a list of all available metrics, \"get\" returns all the requested metrics, \"sum\" returns sum of all records for each of the requested metrics.\n\n"
          },
          "since": {
            "type": "integer",
            "description": "Unix timestamp in milliseconds of oldest entry we want to receive.\n\n",
            "format": "int64"
          }
        }
      },
      "setof_statistics_struct": {
        "type": "object",
        "properties": {
          "count": {
            "type": "integer",
            "description": "Number of values summarized.\n\n"
          },
          "counts": {
            "type": "array",
            "description": "Array containing the values.\n\n",
            "items": {
              "type": "integer"
            }
          },
          "sum": {
            "type": "number",
            "description": "Summarized value of all counts.\n\n",
            "format": ""
          }
        },
        "description": "Total connection times\n\nthe system time \n\nthe request times\n\nthe time requests were queued waiting for processing\n\nIO Time\n\nnumber of bytes sent to the clients\n\nnumber of bytes received from the clients.\n\n"
      },
      "system_statistics_struct": {
        "type": "object",
        "properties": {
          "majorPageFaults": {
            "type": "integer",
            "description": "Page faults\n\n"
          },
          "minorPageFaults": {
            "type": "integer",
            "description": "Page faults\n\n"
          },
          "numberOfThreads": {
            "type": "integer",
            "description": "The number of threads in the server.\n\n"
          },
          "residentSize": {
            "type": "integer",
            "description": "RSS of process\n\n"
          },
          "residentSizePercent": {
            "type": "number",
            "description": "RSS of process as a percentage\n\n",
            "format": "float"
          },
          "systemTime": {
            "type": "number",
            "description": "The system CPU time used by the server process.\n\n",
            "format": "float"
          },
          "userTime": {
            "type": "number",
            "description": "The user CPU time used by the server process.\n\n",
            "format": "float"
          },
          "virtualSize": {
            "type": "integer",
            "description": "VSS of the process.\n\n\n"
          }
        },
        "description": "Metrics gathered from the system about this process; may depend on the host OS.\n\n"
      },
      "v8_context_struct": {
        "type": "object",
        "properties": {
          "available": {
            "type": "integer",
            "description": "The number of currently spawned V8 contexts.\n\n"
          },
          "busy": {
            "type": "integer",
            "description": "The number of currently active V8 contexts.\n\n"
          },
          "dirty": {
            "type": "integer",
            "description": "The number of contexts that were previously used, and should now be garbage collected before being re-used.\n\n"
          },
          "free": {
            "type": "integer",
            "description": "The number of V8 contexts that are free to use.\n\n"
          },
          "max": {
            "type": "integer",
            "description": "The total number of V8 contexts we may spawn as configured by --javascript.v8-contexts.\n\n\n"
          },
          "memory": {
            "type": "array",
            "description": "A list of V8 memory / garbage collection watermarks; Refreshed on every garbage collection run;\nPreserves min/max memory used at that time for 10 seconds.\n\n",
            "items": {
              "$ref": "#/components/schemas/v8_isolate_memory"
            }
          }
        },
        "description": "Statistics about the V8 javascript contexts.\n\n"
      },
      "v8_isolate_memory": {
        "type": "object",
        "properties": {
          "contextId": {
            "type": "integer",
            "description": "ID of the context this set of memory statistics is from.\n\n"
          },
          "countOfTimes": {
            "type": "integer",
            "description": "How many times was the garbage collection run in these 10 seconds.\n\n"
          },
          "heapMax": {
            "type": "integer",
            "description": "High watermark of all garbage collection runs in 10 seconds.\n\n"
          },
          "heapMin": {
            "type": "integer",
            "description": "Low watermark of all garbage collection runs in these 10 seconds.\n\n\n"
          },
          "tMax": {
            "type": "number",
            "description": "The timestamp where the 10 seconds interval started.\n\n",
            "format": ""
          }
        },
        "description": ""
      },
      "version_details_struct": {
        "type": "object",
        "properties": {
          "build-date": {
            "type": "string",
            "description": "The date when this binary was created.\n\n"
          }
        },
        "description": "An optional JSON object with additional details. This is returned only if the *details* query parameter is set to *true* in the request.\n\n"
      },
      "vertex_representation": {
        "type": "object",
        "properties": {
          "_id": {
            "type": "string",
            "description": "The _id value of the stored data.\n\n"
          },
          "_key": {
            "type": "string",
            "description": "The _key value of the stored data.\n\n"
          },
          "_rev": {
            "type": "string",
            "description": "The _rev value of the stored data.\n\n"
          }
        },
        "description": "The internal attributes for the vertex.\n\n"
      },
      "error_response": {
        "type": "object",
        "properties": {
          "status": {
            "type": "integer",
            "format": "int32"
          },
          "message": {
            "type": "string"
          }
        }
      },
      "stream_app_validate_request": {
        "type": "object",
        "properties": {
          "definition": {
            "type": "string"
          }
        }
      },
      "stream_app_response": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "definition": {
            "type": "string"
          },
          "regions": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "stream_app_response_container": {
        "type": "object",
        "properties": {
          "streamApps": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/stream_app_response"
            }
          }
        }
      },
      "get_all_sample_stream_apps_response": {
        "type": "object",
        "properties": {
          "streamAppSamples": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/sample_stream_app_information"
            }
          }
        }
      },
      "sample_stream_app_information": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "definition": {
            "type": "string"
          },
          "description": {
            "type": "string"
          }
        }
      },
      "get_all_stream_apps_response": {
        "type": "object",
        "properties": {
          "streamApps": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/stream_app_information"
            }
          }
        }
      },
      "stream_app_information": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "definition": {
            "type": "string"
          },
          "regions": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "stream_app_request": {
        "type": "object",
        "properties": {
          "definition": {
            "type": "string"
          },
          "regions": {
            "uniqueItems": true,
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "stream_app_query_response": {
        "type": "object",
        "properties": {
          "records": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {}
              }
            }
          }
        }
      },
      "stream_app_query_request": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string"
          }
        }
      }
    }
  }
}